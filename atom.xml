<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>独自赏晴雨</title>
  
  
  <link href="https://www.hfcouc.work/atom.xml" rel="self"/>
  
  <link href="https://www.hfcouc.work/"/>
  <updated>2022-09-06T00:16:10.907Z</updated>
  <id>https://www.hfcouc.work/</id>
  
  <author>
    <name>Han Fangcheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A Complete Guide to Efficient Transformations of data frames</title>
    <link href="https://www.hfcouc.work/2022/09/06/dataframe-julia/"/>
    <id>https://www.hfcouc.work/2022/09/06/dataframe-julia/</id>
    <published>2022-09-06T00:12:29.000Z</published>
    <updated>2022-09-06T00:16:10.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="A-Complete-Guide-to-Efficient-Transformations-of-data-frames"><a href="#A-Complete-Guide-to-Efficient-Transformations-of-data-frames" class="headerlink" title="A Complete Guide to Efficient Transformations of data frames"></a>A Complete Guide to Efficient Transformations of data frames</h2><p align="center">    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimglf.nosdn.127.net%2Fimg%2FbzV1ZDh6L0F6bkw1U29aaWdrbS9mNUdRUUhObHBlQ2hiMG92NmJPbUhlbm5OclF6TnBqZ21BPT0.png%3FimageView%26thumbnail%3D1680x0%26quality%3D96%26stripmeta%3D0%26type%3Djpg&refer=http%3A%2F%2Fimglf.nosdn.127.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1665015297&t=bb05c7f4d4c434a69eec37f3aff70472" style="zoom: 100%;" /></p><blockquote><p>课程地址：<a href="https://www.bilibili.com/video/BV1ud4y1d7SL?spm_id_from=333.999.0.0&amp;vd_source=6177c61c946280bb88c727585de76bc8">https://www.bilibili.com/video/BV1ud4y1d7SL?spm_id_from=333.999.0.0&amp;vd_source=6177c61c946280bb88c727585de76bc8</a></p></blockquote><h3 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h3><p>首先导入需要的包：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DataFramesMeta   <span class="comment"># 此包里面包含了许多宏，同时也导入了DataFrames包</span></span><br><span class="line"><span class="keyword">using</span> Parquet2         <span class="comment"># 导入数据源</span></span><br><span class="line"><span class="keyword">using</span> Statistics       <span class="comment"># 导入一些基本的统计函数</span></span><br><span class="line"><span class="keyword">using</span> CategoricalArrays<span class="comment"># 方便切片操作</span></span><br><span class="line"><span class="keyword">using</span> GLM              <span class="comment"># 用来线性回归</span></span><br><span class="line"><span class="keyword">using</span> Plots            <span class="comment"># 绘图</span></span><br><span class="line"><span class="keyword">using</span> HypothesisTests  <span class="comment"># 假设检验</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们可以改变展示的df的大小</span></span><br><span class="line"><span class="literal">ENV</span>[<span class="string">&quot;COLUMNS&quot;</span>] = <span class="number">1000</span></span><br><span class="line"><span class="literal">ENV</span>[<span class="string">&quot;LINES&quot;</span>] = <span class="number">12</span></span><br></pre></td></tr></table></figure><p>导入数据：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds = Parquet2.Dataset(<span class="string">&quot;puzzles.parquet&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>parquet</code>格式为<code>Hadoop</code>的一种存储格式，我们可以将其转换为数据框格式：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = DataFrame(ds)</span><br></pre></td></tr></table></figure><h3 id="Walk-before-you-run-column-selection"><a href="#Walk-before-you-run-column-selection" class="headerlink" title="Walk before you run: column selection"></a>Walk before you run: column selection</h3><p>我们展示<code>DataFrames.jl</code>格式和<code>DataFramesMeta</code>格式的。</p><p>选择一列：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select(df, :Themes)</span><br><span class="line"><span class="meta">@select</span>(df, :Themes)</span><br></pre></td></tr></table></figure><p>选择多列：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select(df, <span class="string">&quot;Themes&quot;</span>, <span class="number">4</span>, [:Rating, :Moves])</span><br><span class="line"><span class="meta">@select</span>(df, :Themes, :NbPlays, :Rating, :Moves)</span><br></pre></td></tr></table></figure><p>通常<code>@select</code>只接受<code>Symbol</code>类型的参数，我们可以使用<code>$</code>符号将参数转换为<code>Symbol</code>类型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@select</span>(df, $<span class="string">&quot;Themes&quot;</span>, $<span class="number">4</span>, $[:Rating, :Moves])</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>DataFramesMate</code>格式的一般用于静态代码，其中列的名字是固定且已知的并且很容易学习。</li><li><code>DataFrames.jl</code>格式的用于动态代码很方便，其中列的名字是动态生成的。</li></ul></blockquote><h3 id="Special-columns-selectors"><a href="#Special-columns-selectors" class="headerlink" title="Special columns selectors"></a>Special columns selectors</h3><p>删除列：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, Not(:Themes))</span><br></pre></td></tr></table></figure><p>得到某一范围内的列：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, Between(<span class="string">&quot;Rating&quot;</span>, <span class="string">&quot;NbPlays&quot;</span>))</span><br></pre></td></tr></table></figure><p>也可以使用正则表达式：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, <span class="string">r&quot;P&quot;</span>)</span><br></pre></td></tr></table></figure><p>选择满足某个称谓的列：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, Cols(endswith(<span class="string">&quot;s&quot;</span>)))</span><br></pre></td></tr></table></figure><p>如果删除数据框中不存在的列怎么办？只使用<code>Not</code>会失败：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, Not(:X))  <span class="comment"># 出错</span></span><br></pre></td></tr></table></figure><p>但是我们可以将其与<code>Cols</code>结合起来：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, Not(Cols(==(<span class="string">&quot;X&quot;</span>))))</span><br></pre></td></tr></table></figure><blockquote><p><code>Cols</code>函数接收一个返回<code>ture</code>或<code>False</code>的函数(表达式)</p></blockquote><h3 id="Column-renaming"><a href="#Column-renaming" class="headerlink" title="Column renaming"></a>Column renaming</h3><p>如果只是想对列名字进行变换，使用<code>rename</code>或者<code>rename!</code>。</p><p>但是有时候我们想要单独操作这个列：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, :Themes =&gt; :Theme)</span><br></pre></td></tr></table></figure><p>我们也可以使用函数来对多个列进行变换：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, Cols(endswith(<span class="string">&quot;s&quot;</span>)) .=&gt; identity .=&gt; uppercase)</span><br></pre></td></tr></table></figure><blockquote><p>我们将上述操作进行分析：对数据框的操作语法为：<code>[input columns]  =&gt; [transform functions] =&gt; [output columns]</code>：</p><ul><li>我们首先选出满足条件的列，之后通过广播对列的元素进行操作，在这里<code>identity</code>表示保持原样</li><li>而<code>[output columns]</code>也可以是函数来对输入列的名称进行变换，但是这样变换函数只能是<code>identity</code>(在换名的前提下)。</li></ul></blockquote><h3 id="Commonly-used-selection-patterns"><a href="#Commonly-used-selection-patterns" class="headerlink" title="Commonly used selection patterns"></a>Commonly used selection patterns</h3><p>将某列移动到第一位：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, :OpeningFamily, :)</span><br></pre></td></tr></table></figure><p>将某列移动到最后一位：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, Not(:Moves), :Moves)</span><br></pre></td></tr></table></figure><p>两者一起：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df, :OpeningFamily, Not(:Moves), :Moves)</span><br></pre></td></tr></table></figure><p>当你选择多个列时，列的重复是允许的，但是选择单个列就不允许：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(df, Between(<span class="number">3</span>, <span class="number">5</span>), Between(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">select(df, :Themes, :Themes) <span class="comment"># ArgumentError: duplicate output column name: :Themes</span></span><br><span class="line">select(df, :Themes =&gt; :x, :Moves =&gt; :x) <span class="comment"># ArgumentError: duplicate output column name: :x</span></span><br></pre></td></tr></table></figure><h3 id="Jogging-operations-on-a-single-column-of-a-data-frame"><a href="#Jogging-operations-on-a-single-column-of-a-data-frame" class="headerlink" title="Jogging: operations on a single column of a data frame"></a>Jogging: operations on a single column of a data frame</h3><p>我们执行以下操作，计算一列的均值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combine(df, :Rating =&gt; mean =&gt; :Rating_mean)</span><br></pre></td></tr></table></figure><p>我们也可以把换名字删除，这样就会自动生成名字：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combine(df, :Rating =&gt; mean)</span><br></pre></td></tr></table></figure><p>也可以使用一个函数来自动生成列的名字：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combine(df, :Rating =&gt; mean =&gt; x -&gt; x * <span class="string">&quot;_mean&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用<code>DataFramesMeta.jl</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@combine</span>(df, :Rating_mean = mean(:Rating))</span><br></pre></td></tr></table></figure><p><code>combine</code>将很多行转换为一行，但是用<code>select</code>函数会将得到的结果变为跟数据框一样的行数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select(df, :Rating =&gt; mean)   <span class="comment"># 结果拓展为跟数据框一样的行数</span></span><br><span class="line"><span class="meta">@select</span>(df, :Rating_mean = mean(:Rating))   <span class="comment"># 结果与上面相同</span></span><br></pre></td></tr></table></figure><p>我们使用<code>transform</code>函数保存已有的列并在最后添加一列，这一个为<code>Moves</code>中空格的个数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(df, :Moves =&gt; ByRow(x -&gt; <span class="number">1</span> + count(==(<span class="string">&#x27; &#x27;</span>), x)) =&gt; :MoveNo)</span><br></pre></td></tr></table></figure><p>在<code>DataFramesMeta</code>中，我们使用前缀<code>r</code>来表示对行操作：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@rtransform</span>(df, :MoveNo = <span class="number">1</span>+count(==(<span class="string">&#x27; &#x27;</span>), :Moves))</span><br></pre></td></tr></table></figure><p>现在我们开始以<code>GroupDataFrame</code>为对象，类似于<code>Python</code>中<code>pandas</code>中<code>groupby</code>后得到的对象。</p><p>在这里我们使用<code>@chain</code>宏，他进行一连串的操作将上一个操作的输出作为下一个操作的输入。</p><p>我们用到<code>nrow</code>：</p><ul><li><code>nrow</code>返回数据框的行数或者每一组的行数</li><li><code>nrow =&gt; :custom_column_name</code>做同样的事情但是允许你为为列取名字。</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">@rtransform</span>(:MoveNo = <span class="number">1</span> + count(==(<span class="string">&#x27; &#x27;</span>), :Moves))</span><br><span class="line">    groupby(:MoveNo, sort=<span class="literal">true</span>)</span><br><span class="line">    <span class="meta">@combine</span>($nrow,</span><br><span class="line">            :Rating_mean = mean(:Rating),</span><br><span class="line">            :Popularity_mean = mean(:Popularity))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用<code>DataFrames</code>的格式更加紧凑：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Moves =&gt; ByRow(x -&gt; <span class="number">1</span> + count(==(<span class="string">&#x27; &#x27;</span>), x)) =&gt; :MoveNo)</span><br><span class="line">    groupby(:MoveNo, sort=<span class="literal">true</span>)</span><br><span class="line">    combine(nrow, [:Rating, :Popularity] .=&gt; mean)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下面我们研究下<code>groupby</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdf = groupby(df, :OpeningFamily, sort=<span class="literal">true</span>)</span><br><span class="line">combine(gdf, :NbPlays =&gt; mean)</span><br><span class="line"><span class="meta">@combine</span>(gdf, :Nb_Plays_mean = mean(:NbPlays))</span><br></pre></td></tr></table></figure><p>排序的话得到的结果更漂亮：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> gdf <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">@combine</span>(:Nb_Plays_mean = mean(:NbPlays))</span><br><span class="line">    sort(:Nb_Plays_mean, rev=<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果我们想对分箱数据进行分类，那么<code>CategoricalArrays</code>的<code>cut</code>函数很有用：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">10</span>)) =&gt; :Popularity_10)</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    combine(:Rating =&gt; mean)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">@transform</span>(:Popularity_10 = cut(:Popularity, <span class="number">10</span>))</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    <span class="meta">@combine</span>(:Rating_mean = mean(:Rating))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那么如果我们需要<code>rating</code>的分位数怎么办？</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">10</span>)) =&gt; :Popularity_10)</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    combine(:Rating .=&gt; [x -&gt; quantile(x, q) <span class="keyword">for</span> q <span class="keyword">in</span> [<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>]] .=&gt; string.(<span class="string">&quot;Rating&quot;</span>, <span class="number">25</span>:<span class="number">25</span>:<span class="number">75</span>))</span><br><span class="line"><span class="comment"># 这里之所以使用 .=&gt; 是因为[x -&gt; quantile(x, q) for q in [0.25, 0.5, 0.75]]有三个元素，每个元素对应于不同的列名称，</span></span><br><span class="line">    <span class="comment"># 另一种写法，同样(x -&gt; quantile(x, [0.25, 0.5, 0.75]))返回的也为三个元素的列表</span></span><br><span class="line">    combine(:Rating .=&gt; (x -&gt; quantile(x, [<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>])) .=&gt; string.(<span class="string">&quot;Rating&quot;</span>, <span class="number">25</span>:<span class="number">25</span>:<span class="number">75</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">@transform</span>(:Popularity_10 = cut(:Popularity, <span class="number">10</span>))</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    <span class="meta">@combine</span>(:Rating25 = quantile(:Rating, <span class="number">0.25</span>),</span><br><span class="line">             :Rating50 = quantile(:Rating, <span class="number">0.5</span>),</span><br><span class="line">             :Rating75 = quantile(:Rating, <span class="number">0.75</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>quantiles</code>函数可以接收一系列分位数并且返回一个列表，这样我们可以：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">10</span>)) =&gt; :Popularity_10)</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    combine(:Rating =&gt; x -&gt; quantile(x, [<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>]))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>但是这样存在问题，每一组变为了三行(将列表中的三个元素变为了三行)，这并不是我们想要的。有很多方法来解决这个问题，第一个方法为<code>Ref</code>，其将第二列的元素变为列表：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">10</span>)) =&gt; :Popularity_10)</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    combine(:Rating =&gt; (x -&gt; <span class="built_in">Ref</span>(quantile(x, [<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>]))))</span><br><span class="line">    select(:Popularity_10, :Rating_function =&gt; string.(<span class="string">&quot;Rating&quot;</span>, <span class="number">25</span>:<span class="number">25</span>:<span class="number">75</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用<code>AsTable</code>不会自动产生列名：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">10</span>)) =&gt; :Popularity_10)</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    combine(:Rating =&gt; (x -&gt; <span class="built_in">Ref</span>(quantile(x, [<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>]))))</span><br><span class="line">    select(:Popularity_10, :Rating_function =&gt; AsTable)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>不适用<code>Ref</code>我们可以：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">10</span>)) =&gt; :Popularity_10)</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    combine(:Rating =&gt; (x -&gt; [quantile(x, [<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>])]) =&gt; string.(<span class="string">&quot;Rating&quot;</span>, <span class="number">25</span>:<span class="number">25</span>:<span class="number">75</span>))</span><br><span class="line">    <span class="comment"># 这样就相当于产生了含有一个元素的列表(双重列表)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们也可以使用<code>NamedTuple</code>的方法，且<code>AsTable</code>可以使用<code>NamedTuple</code>中的列名称</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">10</span>)) =&gt; :Popularity_10)</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    combine(:Rating =&gt; (x -&gt; (; (<span class="built_in">Symbol</span>.(<span class="string">&quot;Rating&quot;</span>, <span class="number">25</span>:<span class="number">25</span>:<span class="number">75</span>) .=&gt; quantile(x, [<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>]))...)) =&gt; AsTable)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第二种方法首先我们先每一组生成三列，然后<code>unstack</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">10</span>)) =&gt; :Popularity_10)</span><br><span class="line">    groupby(:Popularity_10)</span><br><span class="line">    combine(:Rating =&gt; (x -&gt; (name=string.(<span class="string">&quot;Rating&quot;</span>, <span class="number">25</span>:<span class="number">25</span>:<span class="number">75</span>), value=quantile(x, [<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>]))) =&gt; AsTable)</span><br><span class="line">    unstack(:Popularity_10, :name, :value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># unstack函数参数(dataframe, rowkeys, colkeys, values)</span></span><br></pre></td></tr></table></figure><h3 id="Let-us-start-running-advanced-techniques"><a href="#Let-us-start-running-advanced-techniques" class="headerlink" title="Let us start running: advanced techniques"></a>Let us start running: advanced techniques</h3><p>如果我们想要对<code>Themes</code>字段进行<code>one-hot</code>编码怎么办？</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hemes_list = split.(df.Themes)</span><br><span class="line"></span><br><span class="line">all_themes = <span class="meta">@chain</span> themes_list <span class="keyword">begin</span></span><br><span class="line">    reduce(vcat, _)  <span class="comment"># _表示参数填充到这个位置</span></span><br><span class="line">    unique</span><br><span class="line">    sort</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df2 = <span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    select(:Themes, :Themes =&gt; ByRow(split) =&gt; :ThemesSplit)</span><br><span class="line">    select(:ThemesSplit, [:ThemesSplit =&gt; ByRow(x -&gt; t <span class="keyword">in</span> x) =&gt; t <span class="keyword">for</span> t <span class="keyword">in</span> all_themes])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以计算每类的个数，通过两种方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(df2,</span><br><span class="line">    :ThemesSplit =&gt; ByRow(length) =&gt; :NbThemes1,</span><br><span class="line">    AsTable(Not(:ThemesSplit)) =&gt; ByRow(sum) =&gt; :NbThemes2)</span><br></pre></td></tr></table></figure><p>我们可以通过两种方式来将多个列传入一个函数：</p><ul><li>作为一个<code>collection</code>：在这种情况下他们变为位置参数</li><li>使用<code>AsTable</code>：在这种情况下他们被作为<code>NamedTuple</code></li></ul><p>一般来说<code>AsTable</code>的方法会产生一个<code>NamedTuple</code>，编译非常耗时。</p><p>下面一个是使用位置参数的例子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">5</span>)) =&gt; :Popularity_5)</span><br><span class="line">    groupby(:Popularity_5)</span><br><span class="line">    combine([:Rating, :NbPlays] =&gt; cor)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也可以将其转换为<code>NamedTuple</code>在进行操作：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Popularity =&gt; (x -&gt; cut(x, <span class="number">5</span>)) =&gt; :Popularity_5)</span><br><span class="line">    groupby(:Popularity_5)</span><br><span class="line">    combine(AsTable([:Rating, :NbPlays]) =&gt; x -&gt; cor(x.Rating, x.NbPlays))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们看另一种<code>one-hot</code>编码的方式(这种方式有点慢)：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    [split(x) .=&gt; <span class="literal">true</span> <span class="keyword">for</span> x <span class="keyword">in</span> _.Themes]  <span class="comment"># 将每一行的Themes分解得到的此变为 词=&gt;true</span></span><br><span class="line">    DataFrame.(_)  <span class="comment"># 将每一行变为一个数据框</span></span><br><span class="line">    reduce(vcat, _, cols=:union)  <span class="comment"># 合并所有数据框，列取并集，缺失值为missing</span></span><br><span class="line">    coalesce.(<span class="literal">false</span>)    <span class="comment"># 将缺失值变为false</span></span><br><span class="line">    select(_, sort(names(_)))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们使用<code>unstack</code>函数来达到加速的目的：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    DataFrame(themes=split.(_.Themes), id=eachindex(_.Themes), fixed=<span class="literal">true</span>)</span><br><span class="line">    flatten(:themes)  <span class="comment"># 将themes展开</span></span><br><span class="line">    unstack(:id, :themes, :fixed, fill=<span class="literal">false</span>)  <span class="comment"># 将确实部位填充为false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>为了进行更为高级的转换，我们使用下列数据来建立模型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df3 = <span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    transform(:Themes =&gt; ByRow(split) =&gt; :ThemesSplit)</span><br><span class="line">    select(:Popularity,</span><br><span class="line">           :Rating =&gt; (x -&gt; cut(x, <span class="number">5</span>)) =&gt; :Rating_5,</span><br><span class="line">           [:ThemesSplit =&gt; ByRow(x -&gt; t <span class="keyword">in</span> x) =&gt; t <span class="keyword">for</span> t <span class="keyword">in</span> all_themes])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们以<code>popularity</code>为目标变量构建线性模型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model_formula = Term(:Popularity) ~ sum(Term.(<span class="built_in">Symbol</span>.(names(df3, <span class="string">r&quot;mateIn&quot;</span>))))</span><br><span class="line">model = lm(model_formula, df3)</span><br></pre></td></tr></table></figure><p>我们可以将结果转换为数据框：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame(coeftable(model))</span><br></pre></td></tr></table></figure><p>我们学习<code>combine</code>的另一种语法，你可以将一个函数作为参数传给他，以方便使用<code>do-end</code>语法。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">combine(df3) <span class="keyword">do</span> sdf  <span class="comment"># sdf表示函数的参数，do后面的相当于一个函数</span></span><br><span class="line">    model_formula = Term(:Popularity) ~ sum(Term.(<span class="built_in">Symbol</span>.(names(df3, <span class="string">r&quot;mateIn&quot;</span>))))</span><br><span class="line">    model = lm(model_formula, df3)</span><br><span class="line">    <span class="keyword">return</span> DataFrame(coeftable(model))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种方法对分组数据很有用：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">combine(groupby(df3, :Rating_5)) <span class="keyword">do</span> sdf</span><br><span class="line">    model_formula = Term(:Popularity) ~ sum(Term.(<span class="built_in">Symbol</span>.(names(sdf, <span class="string">r&quot;mateIn&quot;</span>))))</span><br><span class="line">    model = lm(model_formula, sdf)</span><br><span class="line">    <span class="keyword">return</span> DataFrame(coeftable(model))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>得到的结果很长，我们可以使用<code>unstack</code>来使结果变得简单：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df3 <span class="keyword">begin</span></span><br><span class="line">    groupby(:Rating_5)</span><br><span class="line">    combine(_) <span class="keyword">do</span> sdf</span><br><span class="line">        model_formula = Term(:Popularity) ~ sum(Term.(<span class="built_in">Symbol</span>.(names(sdf, <span class="string">r&quot;mateIn&quot;</span>))))</span><br><span class="line">        model = lm(model_formula, sdf)</span><br><span class="line">        <span class="keyword">return</span> DataFrame(coeftable(model))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    unstack(<span class="string">&quot;Rating_5&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Coef.&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们看有多少的值为$1$。我们用两种方法实现，同时学习<code>@chain</code>的<code>@aside</code>选项：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df3 <span class="keyword">begin</span></span><br><span class="line">    select(Cols(startswith(<span class="string">&quot;mateIn&quot;</span>)) =&gt; (+) =&gt; :NoTag)</span><br><span class="line">    <span class="meta">@aside</span> <span class="meta">@show</span> mean(_.NoTag)  <span class="comment"># @aside表示上面的结果不为他的输入，他也不为下一行的输入，即chain跳过他</span></span><br><span class="line">    groupby(:NoTag)</span><br><span class="line">    combine(nrow)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下面我们展示如何将多列变为一列：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df3, AsTable(Cols(startswith(<span class="string">&quot;mateIn&quot;</span>))) =&gt; ByRow(identity))</span><br></pre></td></tr></table></figure><p>我们再使用<code>AsTable</code>就会复原：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df3, AsTable(Cols(startswith(<span class="string">&quot;mateIn&quot;</span>))) =&gt; ByRow(identity) =&gt; AsTable)</span><br></pre></td></tr></table></figure><p>下面是一个例子，从列的集合中选出满足某个条件的列的名称：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(df3, AsTable(Cols(startswith(<span class="string">&quot;mateIn&quot;</span>))) =&gt; ByRow(findfirst) =&gt; :mate)</span><br></pre></td></tr></table></figure><p>我们看一下他们的分布：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df3 <span class="keyword">begin</span></span><br><span class="line">    select(AsTable(Cols(startswith(<span class="string">&quot;mateIn&quot;</span>))) =&gt; ByRow(findfirst) =&gt; :mate)</span><br><span class="line">    groupby(:mate)</span><br><span class="line">    combine(nrow)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们把<code>mate</code>列转换为字符串类型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@chain</span> df3 <span class="keyword">begin</span></span><br><span class="line">    select(AsTable(Cols(startswith(<span class="string">&quot;mateIn&quot;</span>))) =&gt; ByRow(string∘findfirst) =&gt; :mate)</span><br><span class="line">    groupby(:mate, sort=<span class="literal">true</span>)</span><br><span class="line">    combine(nrow)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Subsetting-rows"><a href="#Subsetting-rows" class="headerlink" title="Subsetting rows"></a>Subsetting rows</h3><p><code>subset</code>可以用于选择行：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subset(df, :OpeningFamily =&gt; ByRow(==(<span class="string">&quot;Caro-Kann_Defense&quot;</span>)))</span><br></pre></td></tr></table></figure><p><code>DataFrameMeta</code>的方法更漂亮：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@rsubset</span>(df, :OpeningFamily == <span class="string">&quot;Caro-Kann_Defense&quot;</span>)</span><br></pre></td></tr></table></figure><p>也可以满足多个条件：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subset(df, :OpeningFamily =&gt; ByRow(==(<span class="string">&quot;Caro-Kann_Defense&quot;</span>)), :Popularity =&gt; x-&gt; x.&gt;mean(x))</span><br><span class="line"><span class="meta">@subset</span>(df, :OpeningFamily .== <span class="string">&quot;Caro-Kann_Defense&quot;</span>, :Popularity .&gt; mean(:Popularity))</span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df4 = <span class="meta">@chain</span> df <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">@select</span>(:OpeningFamily, :HighPopularity = :Popularity .&gt; mean(:Popularity))</span><br><span class="line">    groupby(:OpeningFamily)</span><br><span class="line">    <span class="meta">@combine</span>($nrow, :MeanHighPopularity = mean(:HighPopularity))</span><br><span class="line">    sort(:MeanHighPopularity, rev=<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">scatter(df4.nrow, df4.MeanHighPopularity,</span><br><span class="line">        xlabel=<span class="string">&quot;number of puzzles&quot;</span>,</span><br><span class="line">        ylabel=<span class="string">&quot;probability of above average popularity&quot;</span>,</span><br><span class="line">        label=<span class="literal">nothing</span>,</span><br><span class="line">        xaxis=:log)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Julia" scheme="https://www.hfcouc.work/tags/Julia/"/>
    
    <category term="编程" scheme="https://www.hfcouc.work/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Statistical Rethinking:Chapter6</title>
    <link href="https://www.hfcouc.work/2022/07/26/rt6/"/>
    <id>https://www.hfcouc.work/2022/07/26/rt6/</id>
    <published>2022-07-26T08:12:41.000Z</published>
    <updated>2022-07-26T08:14:59.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Overfitting-Regularization-and-Information-Criteria"><a href="#Overfitting-Regularization-and-Information-Criteria" class="headerlink" title="Overfitting, Regularization, and Information Criteria"></a>Overfitting, Regularization, and Information Criteria</h2><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/INT1.png" alt=""></p><span id="more"></span><p>我们要应对两个问题：过拟合和欠拟合，过拟合一般采用正则化的方式进行解决，而欠拟合一般采用信息准则的方式。</p><h3 id="The-problem-with-parameters"><a href="#The-problem-with-parameters" class="headerlink" title="The problem with parameters"></a>The problem with parameters</h3><p>我们前面提到增加相互关联的预测变量会对预测产生不好的影响，那添加不相关的预测会怎么样呢。添加不相互关联的预测也会对我们的模型造成影响，会使我们的模型对数据更敏感，从而造成过拟合。</p><h4 id="More-parameters-always-improve-fit"><a href="#More-parameters-always-improve-fit" class="headerlink" title="More parameters always improve fit"></a>More parameters always improve fit</h4><p>我们考虑如下数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sppnames &lt;- <span class="built_in">c</span>(<span class="string">&quot;afarensis&quot;</span>, <span class="string">&quot;africanus&quot;</span>, <span class="string">&quot;habilis&quot;</span>, <span class="string">&quot;boisei&quot;</span>, <span class="string">&quot;rudolfensis&quot;</span>,</span><br><span class="line">              <span class="string">&quot;ergaster&quot;</span>, <span class="string">&quot;sapiens&quot;</span>)</span><br><span class="line">brainvolcc &lt;- <span class="built_in">c</span>(<span class="number">438</span>, <span class="number">452</span>, <span class="number">612</span>, <span class="number">521</span>, <span class="number">752</span>, <span class="number">871</span>, <span class="number">1350</span>)</span><br><span class="line">masskg &lt;- <span class="built_in">c</span>(<span class="number">37.0</span>, <span class="number">35.5</span>, <span class="number">34.5</span>, <span class="number">41.5</span>, <span class="number">55.5</span>, <span class="number">61.0</span>, <span class="number">53.5</span>)</span><br><span class="line">d &lt;- data.frame(species=sppnames, brain=brainvolcc, mass=masskg)</span><br></pre></td></tr></table></figure><p>我们按照模型复杂度增加对其进行建模：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m6.1 &lt;- lm(brain~mass, data = d)</span><br><span class="line">m6.2 &lt;- lm(brain~mass+I(mass^<span class="number">2</span>), data = d)</span><br><span class="line">m6.3 &lt;- lm( brain ~ mass + I(mass^<span class="number">2</span>) + I(mass^<span class="number">3</span>) , data=d )</span><br><span class="line">m6.4 &lt;- lm( brain ~ mass + I(mass^<span class="number">2</span>) + I(mass^<span class="number">3</span>) + I(mass^<span class="number">4</span>) ,</span><br><span class="line">            data=d )</span><br><span class="line">m6.5 &lt;- lm( brain ~ mass + I(mass^<span class="number">2</span>) + I(mass^<span class="number">3</span>) + I(mass^<span class="number">4</span>) +</span><br><span class="line">              I(mass^<span class="number">5</span>) , data=d )</span><br><span class="line">m6.6 &lt;- lm( brain ~ mass + I(mass^<span class="number">2</span>) + I(mass^<span class="number">3</span>) + I(mass^<span class="number">4</span>) +</span><br><span class="line">              I(mass^<span class="number">5</span>) + I(mass^<span class="number">6</span>) , data=d )</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/INT2.jpg" alt=""></p><blockquote><p>可以看到第6个模型可以精准拟合各个数据，但是却出现了脑容量为负数的情况，这肯定是错误的。</p></blockquote><h4 id="Too-few-parameters-hurts-too"><a href="#Too-few-parameters-hurts-too" class="headerlink" title="Too few parameters hurts, too"></a>Too few parameters hurts, too</h4><p>但是参数数量过少也是不行的，如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m6.7 &lt;- lm( brain ~ <span class="number">1</span> , data=d )</span><br></pre></td></tr></table></figure><p>得到的是一条水平线，预测效果也很差。<br>看模型是不是欠拟合也可以通过观察其是否对数据敏感，与过拟合对数据敏感相反，欠拟合对数据不敏感。</p><h3 id="Information-theory-and-model-performance"><a href="#Information-theory-and-model-performance" class="headerlink" title="Information theory and model performance"></a>Information theory and model performance</h3><p>我们要估计的是<strong>样本外偏差</strong>。</p><h4 id="Information-and-uncertainty"><a href="#Information-and-uncertainty" class="headerlink" title="Information and uncertainty"></a>Information and uncertainty</h4><p>信息是从学习结果中减少的不确定性。我们现在需要去衡量不确定性，而衡量不确定性的指标需要满足下列三个条件：</p><ol><li>需要是连续的</li><li>需要随着可能事件种类的增加而增加</li><li>是可加的</li></ol><p>满足上述三个条件我们使用熵来衡量不确定性：</p><script type="math/tex; mode=display">H(p) = -\sum_i p_i\log(p_i)</script><h4 id="From-entropy-to-accuracy"><a href="#From-entropy-to-accuracy" class="headerlink" title="From entropy to accuracy"></a>From entropy to accuracy</h4><p>我们利用KL散度来衡量两个概率分布之间的距离：</p><script type="math/tex; mode=display">D_{\text{KL}}(p,q) = \sum_i p_i(\log(p_i)-\log(q_i)) = \sum_i p_i\log\left(\frac{p_i}{q_i}\right)</script><p>相当于用$q$近似$p$的熵进去$q$本身的熵，为用$q$近似$p$引进的不确定性。</p><h4 id="From-divergence-to-deviance"><a href="#From-divergence-to-deviance" class="headerlink" title="From divergence to deviance"></a>From divergence to deviance</h4><p>在计算KL散度时我们假设真实的概率分布我们是知道的，但是这与现实不符，如果我们知道真实的概率分布就没有必要进行下面的工作了。<br>但是我们没有必要知道真实的概率分布，对于候选分布我们只需要知道其$\mathbb{E}[\log(q)]$并进行比较即可，而将每个观察到的情况的对数概率相加就可以提供$\mathbb{E}[\log(q)]$的近似值，因此我们定义模型的偏差：</p><script type="math/tex; mode=display">D(q) = -2\sum_i \log(q_i)</script><p>我们可以计算任何模型的偏差，通过最大后验估计得到的概率分布来计算每一个观测的概率，之后计算偏差。我们可以使用R语言的<code>logLik</code>函数：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m6.1 &lt;- lm(brain~mass, d)</span><br><span class="line">(-<span class="number">2</span>) * logLik(m6.1)</span><br></pre></td></tr></table></figure><h4 id="From-deviance-to-out-of-sample"><a href="#From-deviance-to-out-of-sample" class="headerlink" title="From deviance to out-of-sample"></a>From deviance to out-of-sample</h4><p>散度也只是对样本内数据进行估计，随着模型复杂度的增加，样本内散度也会逐渐降低，这时候我们就需要引进训练集和测试集的概念：</p><ol><li>假设有一个大小为$N$的训练集</li><li>在训练集上拟合模型，计算散度记为$D_{\text{train}}$</li><li>假设另一组大小为$N$的样本通过同一种方法产生，称为测试数据。</li><li>计算测试数据上的散度，记为$D_{\text{test}}$。</li></ol><h3 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h3><p>过拟合是因为我们的模型倾向于从训练数据中学习更多的东西，当我们的先验为平缓或趋于平缓的时候，模型认为任何的参数都是同等可能的，那么模型将会从数据中学习更多的数据。</p><p>一种方法是添加怀疑的先验(skeptical prior)，它能降低从数据中学习的速率，最常见的先验是正则化先验。如下面的模型：</p><script type="math/tex; mode=display">\begin{aligned}y_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta x_{i} \\\alpha & \sim \operatorname{Normal}(0,100) \\\beta & \sim \operatorname{Normal}(0,1) \\\sigma & \sim \operatorname{Uniform}(0,10)\end{aligned}</script><p>对于上述模型，我们对于$\alpha$的先验是很平坦的，但是对于$\beta$的先验是很倾斜的，将$\beta$限制在某个范围。但是过于倾斜的正则先验也会对模型产生不好的效果，过于倾斜的先验会影响从数据中学到信息，从而导致欠拟合，为了防止此类问题发生，我们可以采用交叉验证的方式选取合适的先验。</p><h3 id="Information-criteria"><a href="#Information-criteria" class="headerlink" title="Information criteria"></a>Information criteria</h3><p>赤池信息准则(Akaike information criterion)提供了一个非常简单的平均样本外偏差估计值：</p><script type="math/tex; mode=display">\text{AIC} = D_{\text{train}}+2p</script><p>其中$p$为参数的数目，这个定义反映了训练和测试偏差之间的关系。<br>但是AIC的应用存在如下限制：</p><ol><li>先验必须是平坦的或者被似然的分量压制</li><li>后验分布为近似多元分布</li><li>样本大小$N$远大于参数数目$k$<br>因为平坦的先验一般是不好的先验，所以我们需要更一般的指标，DIC(Deviance Information Criterion)偏差信息准则允许信息丰富的先验，但是仍然假设后验分布为多元高斯分布并且$N\gg k$，WAIC(Widely Applicable Information Criterion)对后验分布的形状不存在任何假设。</li></ol><h4 id="DIC"><a href="#DIC" class="headerlink" title="DIC"></a>DIC</h4><p>DIC从训练偏差的后验分布中计算得出。因为我们的参数具有后验分布，所以通过参数计算出的偏差也存在后验分布。因此现在定义$D$为偏差的后验分布，令$\bar{D}$表示$D$的均值，定义$\hat{D}$为在后验均值处计算得到的偏差，也就是说我们计算参数的后验均值的，将得到的后验均值代入得到偏差$\hat{D}$。一旦我们计算完成，DIC定义为：</p><script type="math/tex; mode=display">\text{DIC} = \bar{D}+(\bar{D}-\hat{D}) = \bar{D}+p_D</script><p>$p_D$类似于AIC中的参数数量，它是衡量模型在拟合训练样本方面的灵活性的“有效”参数数量。</p><h4 id="WAIC"><a href="#WAIC" class="headerlink" title="WAIC"></a>WAIC</h4><p>WAIC的特点是他是逐点的，预测的不确定性在数据中被逐点考虑。定义$\Pr(y_i)$为训练数据$i$的平均似然，我们所有点的平均似然的对数相加：</p><script type="math/tex; mode=display">\text{lppd} = \sum_{i=1}^N \log \Pr(y_i)</script><p>WAIC的第二个部分为有效参数数量$p_{\text{WAIC}}$。定义$V(y_i)$为在训练样本$i$的对数似然的方差，$p_{\text{WAIC}}$定义为：</p><script type="math/tex; mode=display">p_{\text{WAIC}} = \sum_{i=1}^N V(y_i)</script><p>则WAIC定义为：</p><script type="math/tex; mode=display">\text{WAIC} = -2(\text{lppd}-p_{\text{WAIC}})</script><p>因为WAIC需要将数据分割成独立的观测$i=1,\cdots,N$，在某些情况下很难定义，如在时间序列中。</p><h3 id="Using-information-criteria"><a href="#Using-information-criteria" class="headerlink" title="Using information criteria"></a>Using information criteria</h3><h4 id="Model-comparison"><a href="#Model-comparison" class="headerlink" title="Model comparison"></a>Model comparison</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(rethinking)</span><br><span class="line">data(milk)</span><br><span class="line">d &lt;- milk[complete.cases(milk),]</span><br><span class="line">d$neocortex &lt;- d$neocortex.perc / <span class="number">100</span></span><br></pre></td></tr></table></figure><p>这就做好的模型比较的第一步，保证各个模型使用的数据相同。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a.start &lt;- mean(d$kcal.per.g)</span><br><span class="line">sigma.start &lt;- <span class="built_in">log</span>(sd(d$kcal.per.g))</span><br><span class="line"></span><br><span class="line">m6.11 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm(a, <span class="built_in">exp</span>(log.sigma))</span><br><span class="line">  ),</span><br><span class="line">  data = d, start=<span class="built_in">list</span>(a=a.start, log.sigma=sigma.start)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">m6.12 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm(mu, <span class="built_in">exp</span>(log.sigma)),</span><br><span class="line">    mu &lt;- a + bn*neocortex</span><br><span class="line">  ),</span><br><span class="line">  data = d, start=<span class="built_in">list</span>(a=a.start, bn=<span class="number">0</span>, log.sigma=sigma.start)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">m6.13 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm(mu, <span class="built_in">exp</span>(log.sigma)),</span><br><span class="line">    mu &lt;- a + bm*<span class="built_in">log</span>(mass)</span><br><span class="line">  ),</span><br><span class="line">  data=d, start=<span class="built_in">list</span>(a=a.start,bm=<span class="number">0</span>,log.sigma=sigma.start)</span><br><span class="line">)</span><br><span class="line">m6.14 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm(mu, <span class="built_in">exp</span>(log.sigma)),</span><br><span class="line">    mu &lt;- a + bn*neocortex + bm*<span class="built_in">log</span>(mass)</span><br><span class="line">  ),</span><br><span class="line">  data=d, start = <span class="built_in">list</span>(a=a.start, bn=<span class="number">0</span>, bm=<span class="number">0</span>, log.sigma=sigma.start)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们将集合WAIC和参数估计来对模型进行评估。</p><h5 id="Comparing-WAIC-values"><a href="#Comparing-WAIC-values" class="headerlink" title="Comparing WAIC values"></a>Comparing WAIC values</h5><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WAIC(m6.14)</span><br><span class="line">       WAIC     lppd  penalty  std_err</span><br><span class="line"><span class="number">1</span> -<span class="number">15.06584</span> <span class="number">12.35506</span> <span class="number">4.822137</span> <span class="number">7.514096</span></span><br></pre></td></tr></table></figure><p>我们也可以通过WAIC来对不同的模型进行比较：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">milk.models &lt;- compare(m6.11, m6.12, m6.13, m6.14)</span><br><span class="line"></span><br><span class="line">       WAIC   SE dWAIC  dSE pWAIC weight</span><br><span class="line">m6.14 -<span class="number">15.0</span> <span class="number">7.57</span>   <span class="number">0.0</span>   <span class="literal">NA</span>   <span class="number">4.8</span>   <span class="number">0.93</span></span><br><span class="line">m6.11  -<span class="number">8.3</span> <span class="number">4.66</span>   <span class="number">6.7</span> <span class="number">7.44</span>   <span class="number">1.8</span>   <span class="number">0.03</span></span><br><span class="line">m6.13  -<span class="number">7.4</span> <span class="number">5.82</span>   <span class="number">7.5</span> <span class="number">5.54</span>   <span class="number">3.3</span>   <span class="number">0.02</span></span><br><span class="line">m6.12  -<span class="number">6.1</span> <span class="number">4.35</span>   <span class="number">8.9</span> <span class="number">7.69</span>   <span class="number">3.0</span>   <span class="number">0.01</span></span><br></pre></td></tr></table></figure><ul><li>WAIC指的是每个模型的WAIC值，越小越好</li><li>pWAIC指的是参数的有效个数，这为每个模型在拟合样本方面的灵活性提供了线索。</li><li>dWAIC是每个WAIC与最低WAIC之间的差值。</li><li>weight 是每个模型的 Akaike 权重。这些值是转换后的信息标准值。</li><li>SE为WAIC估计的标准误差</li><li>dSE是每个模型与排名靠前的模型之间WAIC 差异的标准误差，所以第一个是缺失的</li></ul><p>Akaike权重通过重新缩放来提供帮助，其公式为：</p><script type="math/tex; mode=display">w_i = \frac{\exp(-\frac{1}{2}\text{dWAIC}_i)}{\sum_{j=1}^m\exp(-\frac{1}{2}\text{dWAIC}_j)}</script><p>dWAIC与得出的表的dWAIC意义相同。模型的权重是对模型对新数据做出最佳预测的概率的估计，以所考虑的模型集为条件。</p><h5 id="Comparing-estimates"><a href="#Comparing-estimates" class="headerlink" title="Comparing estimates"></a>Comparing estimates</h5><p>比较估计值至少在两个主要方面有帮助。首先，对了解为什么一个或多个特定模型具有较低的 WAIC 值是有用的，其次，不管 WAIC 值如何，我们经常想知道某个参数的后验分布在模型中是否稳定。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">coeftab(m6.11,m6.12,m6.13,m6.14)</span><br><span class="line"></span><br><span class="line">          m6.11   m6.12   m6.13   m6.14  </span><br><span class="line">a            <span class="number">0.66</span>    <span class="number">0.35</span>    <span class="number">0.71</span>   -<span class="number">1.09</span></span><br><span class="line">log.sigma   -<span class="number">1.79</span>   -<span class="number">1.80</span>   -<span class="number">1.85</span>   -<span class="number">2.16</span></span><br><span class="line">bn             <span class="literal">NA</span>    <span class="number">0.45</span>      <span class="literal">NA</span>    <span class="number">2.79</span></span><br><span class="line">bm             <span class="literal">NA</span>      <span class="literal">NA</span>   -<span class="number">0.03</span>   -<span class="number">0.10</span></span><br><span class="line">nobs           <span class="number">17</span>      <span class="number">17</span>      <span class="number">17</span>      <span class="number">17</span></span><br></pre></td></tr></table></figure><h4 id="Model-averaging"><a href="#Model-averaging" class="headerlink" title="Model averaging"></a>Model averaging</h4><p>我们之前已经知道当从模型中模拟预测时怎么保持参数的不确定性，现在我们有同样相似的问题，怎么保持模型的不确定性。为了回顾，我们生成并绘制具有最小WAIC的模型的反事实预测(counterfactual predictions )。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nc.seq &lt;- seq(from=<span class="number">0.5</span>,to=<span class="number">0.8</span>,length.out=<span class="number">30</span>) </span><br><span class="line">d.predict &lt;- <span class="built_in">list</span>(</span><br><span class="line">kcal.per.g = <span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">30</span>), <span class="comment"># empty outcome </span></span><br><span class="line">neocortex = nc.seq, <span class="comment"># sequence of neocortex </span></span><br><span class="line">mass = <span class="built_in">rep</span>(<span class="number">4.5</span>,<span class="number">30</span>) <span class="comment"># average mass</span></span><br><span class="line">)</span><br><span class="line">pred.m6.14 &lt;- link( m6.14 , data=d.predict )</span><br><span class="line">mu &lt;- apply( pred.m6.14 , <span class="number">2</span> , mean )</span><br><span class="line">mu.PI &lt;- apply( pred.m6.14 , <span class="number">2</span> , PI )</span><br><span class="line"><span class="comment"># plot it all</span></span><br><span class="line">plot( kcal.per.g ~ neocortex , d , col=rangi2 ) </span><br><span class="line">lines( nc.seq , mu , lty=<span class="number">2</span> )</span><br><span class="line">lines( nc.seq , mu.PI[<span class="number">1</span>,] , lty=<span class="number">2</span> ) </span><br><span class="line">lines( nc.seq , mu.PI[<span class="number">2</span>,] , lty=<span class="number">2</span> )</span><br></pre></td></tr></table></figure><p>下面我们计算添加模型平均后验预测，下面时步骤：</p><ol><li>计算每个模型的WAIC</li><li>计算每个模型的权重</li><li>计算每个模型的预测结果</li><li>使用模型权重作为比例，将这些值组合成一个预测集合。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">milk.ensemble &lt;- ensemble( m6.11 , m6.12 , m6.13 , m6.14 , data=d.predict )</span><br><span class="line">mu &lt;- apply( milk.ensemble$link , <span class="number">2</span> , mean )</span><br><span class="line">mu.PI &lt;- apply( milk.ensemble$link , <span class="number">2</span> , PI ) </span><br><span class="line">lines( nc.seq , mu )</span><br><span class="line">shade( mu.PI , nc.seq )</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Overfitting-Regularization-and-Information-Criteria&quot;&gt;&lt;a href=&quot;#Overfitting-Regularization-and-Information-Criteria&quot; class=&quot;headerlink&quot; title=&quot;Overfitting, Regularization, and Information Criteria&quot;&gt;&lt;/a&gt;Overfitting, Regularization, and Information Criteria&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/HFC666/image/master/img/INT1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="书籍阅读" scheme="https://www.hfcouc.work/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="概率编程" scheme="https://www.hfcouc.work/tags/%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B/"/>
    
    <category term="贝叶斯统计" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1/"/>
    
    <category term="Statistical Rethinking" scheme="https://www.hfcouc.work/tags/Statistical-Rethinking/"/>
    
  </entry>
  
  <entry>
    <title>算法导论课程第二周</title>
    <link href="https://www.hfcouc.work/2022/07/26/alo2/"/>
    <id>https://www.hfcouc.work/2022/07/26/alo2/</id>
    <published>2022-07-25T22:31:19.000Z</published>
    <updated>2022-07-25T22:35:52.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p align="center">    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp2.itc.cn%2Fimages01%2F20200915%2Fcd3178c68249454aa8e8206ed7626cb6.jpeg&refer=http%3A%2F%2Fp2.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661380513&t=cc08b97050020b95b97750370a407272" style="zoom: 100%;" /></p><blockquote><p>课程链接：<a href="https://ocw.mit.edu/6-006S20">https://ocw.mit.edu/6-006S20</a></p></blockquote><span id="more"></span><h2 id="Sets-and-Sorting"><a href="#Sets-and-Sorting" class="headerlink" title="Sets and Sorting"></a>Sets and Sorting</h2><h3 id="Set-interface"><a href="#Set-interface" class="headerlink" title="Set interface"></a>Set interface</h3><ul><li>包含具有唯一键的元素</li><li>一般我们令键为元素本身，但是也可能存储更多的信息</li><li>支持的操作<ul><li>Container<ul><li><code>build(X)</code>：给定可迭代的$X$，用$X$中的元素构建序列</li><li><code>len()</code>：返回排列好的元素的个数</li></ul></li><li>Dynamic：<ul><li><code>insert(x)</code>：将$x$添加到集合(如果<code>x.key</code>已经存在则替换即可)</li><li><code>delete(k)</code>：删除并返回键为<code>k</code>的元素</li></ul></li><li>Order<ul><li><code>iter_ord()</code>：以键的顺序返回排列好的元素</li><li><code>find_min()</code>：找到键最小的元素</li><li><code>find_max()</code>：找到键最大的元素</li><li><code>find_next(k)</code>：找到键比<code>k</code>大的最小的键对应的元素</li><li><code>find_prev(k)</code>：找到键比<code>k</code>小的最大的键对应的元素</li></ul></li></ul></li><li>特殊的接口：字典</li><li>将元素以任意的顺序排列可以实现一个集合(不是很高效)</li><li>将元素以键升序来排列<ul><li>更快找到<code>min/max</code></li><li>更快通过二分法找到元素$\mathcal{O}(\log n)$<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/set1.jpg" alt=""></li></ul></li></ul><blockquote><p>构建的复杂度为$n\log n$是因为我们在构建的过程中需要排序，对一个元素排序的复杂度为$\log n$，$n$个为$n\log n$。寻找元素即采用二分法，时间复杂度为$\log n$，插入删除元素既涉及寻找元素有涉及元素插入或删除后的移位，复杂为$\log n+n=n$，找到下一个和上一个元素的复杂度与找到某个元素相同，为$\log n$。</p></blockquote><p>那么下面我们关心的就是如何进行排序了：<br>排序</p><ul><li>输入：具有$n$个元素/键的数组(array)$A$</li><li>输出：对$A$进行排序后得到的数组$B$</li><li>排序为destructive的如果它重写$A$，既并没有创建新的数组，$B$只是$A$的排序版本</li><li>排序为in place的如果它利用$\mathcal{O}(1)$额外的空间(如创建循环时的临时变量)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorted_Array_Set</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A = Array_Seq()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.A)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_order</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A.build(X)</span><br><span class="line"></span><br><span class="line">        self._sort()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_sort</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_binary_search</span>(<span class="params">self, k, i, j</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        m = (i + j) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        x = self.A.get_at(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key &gt; k: <span class="keyword">return</span> self._binary_search(k ,i ,m-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key &lt; k: <span class="keyword">return</span> self._binary_search(k, m+<span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_min</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; <span class="number">0</span>: <span class="keyword">return</span> self.A.get_at(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; <span class="number">0</span>: <span class="keyword">return</span> self.A.get_at(<span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) ==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key == k: <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key &gt; k:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(self): <span class="keyword">return</span> self.A.get_at(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_prev</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key &lt; k:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(self): <span class="keyword">return</span> self.A.get_at(i-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            self.A.insert_first(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            i = self._binary_search(x.key, <span class="number">0</span>, <span class="built_in">len</span>(self.A)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            k = self.A.get_at(i).key</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k == x.key:</span><br><span class="line"></span><br><span class="line">                self.A.set_at(i, x)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k &gt; x.key: self.A.insert_at(i, x)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>: self.A.insert_at(i+<span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self.A) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> self.A.get_at(i).key == k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.A.delete_at(i)</span><br></pre></td></tr></table></figure><h3 id="Permutation-Sort"><a href="#Permutation-Sort" class="headerlink" title="Permutation Sort"></a>Permutation Sort</h3><ul><li>存在$A$的$n!$种排列，其中一个是排列好的顺序</li><li>对于每一个排列，查看其是否排列好的复杂度为$\Theta(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation_sort</span>(<span class="params">A</span>):</span></span><br><span class="line"><span class="keyword">for</span> B <span class="keyword">in</span> permutations(A):</span><br><span class="line"><span class="keyword">if</span> is_sorted(B):</span><br><span class="line"><span class="keyword">return</span> B</span><br></pre></td></tr></table></figure><p>时间复杂为$\Omega(n!\cdot n)$，为指数级的。</p><h3 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h3><ul><li>找到A[:i+1]中最大的数并将其放到A[i]中</li><li>递归地对A[:i]进行排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">A, i=<span class="literal">None</span></span>)   # <span class="title">T</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="title">i</span> <span class="title">is</span> <span class="title">None</span>:</span> i = <span class="built_in">len</span>(A) - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>:                    <span class="comment"># O(1)</span></span><br><span class="line">j = prefix_max(A, i)  <span class="comment"># S(i)</span></span><br><span class="line">A[i], A[j] = A[j], A[i]</span><br><span class="line">selection_sort(A, i-<span class="number">1</span>)   <span class="comment"># T(i-1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prefix_max</span>(<span class="params">A, i</span>):</span>            <span class="comment"># S(i)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>:                    <span class="comment"># O(1)</span></span><br><span class="line">j = prefix_max(A, i-<span class="number">1</span>)   <span class="comment"># S(i-1)</span></span><br><span class="line"><span class="keyword">if</span> A[i] &lt; A[j]:          <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">return</span> j             <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">return</span> i                     <span class="comment"># O(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们来分析一下<code>prefix_max</code>函数：</p><ul><li>Base case：对于$i=0$，数组有一个元素，所以最大的索引为$i$</li><li>归纳：假设对于$i$是正确的，最大的要么是A[:i]中的要么是A[i]，返回最大的索引</li><li>$S(1)=\Theta(1), S(n) = S(n-1)+\Theta(1)$<ul><li>替换：$S(n)=\Theta(n), cn=\Theta(1)+c(n-1)\Rightarrow 1 = \Theta(1)$<br>再分析一下<code>selection_sort</code>函数：</li></ul></li><li>Base case：对于$i=0$，数组含有一个元素，因此是排列好的</li><li>归纳：假设对于$i$是正确的，排列好的输出的最后一个元素为数组的最大的元素，并且算法将其放在那里；则A[:i]是排列好的</li><li>$T(1)=\Theta(1), T(n) = T(n-1)+\Theta(n)$<ul><li>替换：$T(n)=\Theta(n^2),cn^2=\Theta(n)+c(n-1)^2\Rightarrow c(2n-1)=\Theta(n)$</li></ul></li></ul><blockquote><p>步骤为先把全部$n$个元素的最大值挑出来放在最后面，之后将剩余的$n-1$个元素的最大值挑出来放在$n-1$位置，递归下去</p></blockquote><h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><ul><li>递归地排列A[:i]</li><li>排列A[:i+1]假设A[:i]已经通过重复地交换排列好了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">A, i = <span class="literal">None</span></span>):</span>       <span class="comment"># T(i)</span></span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">is</span> <span class="literal">None</span>: i = <span class="built_in">len</span>(A) - <span class="number">1</span>       <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>:                          <span class="comment"># O(1)</span></span><br><span class="line">insertion_sort(A, i-<span class="number">1</span>)         <span class="comment"># T(i-1)</span></span><br><span class="line">insert_last(A, i)              <span class="comment"># S(i)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_last</span>(<span class="params">A, i</span>):</span>                 <span class="comment"># S(i)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &lt; A[i-<span class="number">1</span>]:        <span class="comment"># O(1)</span></span><br><span class="line">A[i], A[i-<span class="number">1</span>]  = A[i-<span class="number">1</span>], A[i]   <span class="comment"># O(1)</span></span><br><span class="line">insert_last(A, i-<span class="number">1</span>)            <span class="comment"># S(i-1)</span></span><br></pre></td></tr></table></figure><p>先分析一下<code>insert_last</code>函数：</p><ul><li>Base case：对于$i=0$，数组只有一个元素所以是排列好的</li><li>归纳：假设对于$i$是正确的，如果A[i] &gt;= A[i-1]，数组是排列好的；否则交换后两个元素</li><li>$S(1) = \Theta(1), S(n)=S(n-1)+\Theta(1)\Rightarrow S(n)=\Theta(n)$<br>之后分析一下<code>insertion_sort</code>函数：</li><li>Base case：对于$i=0$，数组只有一个元素因此是排列好的</li><li>归纳：假设对于$i$时正确，算法通过归纳排列A[:i]，之后<code>insert_last</code>正确地排列剩余的部分</li><li>$T(1)=\Theta(1), T(n) = T(n-1)+\Theta(n)\Rightarrow T(n) = \Theta(n^2)$</li></ul><blockquote><p>总的思路就是先排列好前$i$个数据，之后通过逐次比较将下一个元素插入正确的位置来排列第$i+1$个元素。</p></blockquote><p>选择排序和插入排序都是<code>in place</code>排序，意味着它们需要至多常数复杂度的额外空间。而插入排序是稳定的，即再处理具有相同值的排序时相同值的原有顺序不变，而选择排序是不稳定的。如在排列$[2,1,1^\prime]$，插入排序的结果为$[1,1^\prime,2]$，而选择排序的结果为$[1^\prime,1,2]$。</p><h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><ul><li>递归地排列前一半和后一半</li><li>将排列好的两半混合成一个排列好的列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">A, a = <span class="number">0</span>, b = <span class="literal">None</span></span>):</span>                  <span class="comment"># T(b - a = n)</span></span><br><span class="line"><span class="keyword">if</span>  b <span class="keyword">in</span> <span class="literal">None</span>: b = <span class="built_in">len</span>(A)                        <span class="comment"># O(1)</span></span><br><span class="line"> <span class="keyword">if</span> <span class="number">1</span> &lt; b - a :                                   <span class="comment"># O(1)</span></span><br><span class="line">c = (a + b + <span class="number">1</span>) // <span class="number">2</span>                         <span class="comment"># O(1)</span></span><br><span class="line">merge_sort(A, a, c)                          <span class="comment"># T(n/2)</span></span><br><span class="line">merge_sort(A, c, b)                          <span class="comment"># T(n/2)</span></span><br><span class="line">L, R = A[a:c], A[c:b]                        <span class="comment"># O(n)</span></span><br><span class="line">merge(L, R, A, <span class="built_in">len</span>(L), <span class="built_in">len</span>(R), a, b)         <span class="comment"># S(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">L, R, A, i, j, a, b</span>):</span>                            <span class="comment"># S(b - a = n)</span></span><br><span class="line"><span class="keyword">if</span> a &lt; b:                                              <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">if</span> (j &lt;= <span class="number">0</span>) <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] &gt; R[j - <span class="number">1</span>]):    <span class="comment"># O(1)</span></span><br><span class="line">A[b - <span class="number">1</span>] = L[i - <span class="number">1</span>]                            <span class="comment"># O(1)</span></span><br><span class="line">i = i - <span class="number">1</span>                                      <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">else</span>:                                              <span class="comment"># O(1)</span></span><br><span class="line">A[b - <span class="number">1</span>] = R[j - <span class="number">1</span>]                            <span class="comment"># O(1)</span></span><br><span class="line">j = j - <span class="number">1</span>                                      <span class="comment"># O(1)</span></span><br><span class="line">merge(L, R, A, i, j, a, b-<span class="number">1</span>)                       <span class="comment"># S(n-1)</span></span><br></pre></td></tr></table></figure><p>首先先分析一下merge函数：</p><ul><li>Base case：对于$n=0$，数组为空，因此排序正确</li><li>归纳：假设对于$i$是正确的，元素A[r]必须是L和R中最大的元素，并且因为它们是排列好的，取最大的元素递归地进行排序</li><li>$S(0) = \Theta(1),S(n)=S(n-1)+\Theta(1)\Rightarrow S(n)=\Theta(n)$<br>下面是<code>merge_sort</code>函数：</li><li>Base case：对于$n=1$，数组含有一个元素因此是排列好的</li><li>归纳：假设对于$k&lt;n$是正确的，算法通过归纳排列两个一半，之后将其混合成一个排列好的数组</li><li>$T(1) = \Theta(1), T(n)=2T(n/2)+\Theta(n)$</li><li>替换：假设$T(n)=\Theta(n\log n), cn\log n = \Theta(n) + 2c(n/2)\log(n/2)\Rightarrow cn\log(2) = \Theta(n)$<br>归并排序使用线性的额外空间，因此不是<code>in place</code>算法。</li></ul><h3 id="Recurrences"><a href="#Recurrences" class="headerlink" title="Recurrences"></a>Recurrences</h3><p>有三种方法来解决Recurrences(递归)问题：</p><ul><li>替换：猜测一个结果来替换证明递归成立</li><li>Recursion Tree：绘制树来表示递归将节点处的计算数求和</li><li>Master定理：一个解决大多数递归问题的通用公式。</li></ul><h4 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h4><p>给定下列形式的递归关系式：$T(n) = aT(n/b)+f(n)$并且$T(1)=\Theta(1)$，分支因子$a\ge1$，问题规模缩减因子$b&gt;1$并且渐进非负函数$f(n)$，Master Theorem通过比较$f(n)$和递归树底部的叶子数量$a^{\log_b^n}=n^{\log_b a}$来给出答案。当$f(n)$渐进增长速度大于$n^{\log_ba}$，在每一层做的工作呈几何下降因此根节点占主要地位；否则当$f(n)$增长缓慢，在每一个节点的工作量成几何增加因此每一层的工作占主导。<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/set2.jpg" alt=""></p><script type="math/tex; mode=display">\begin{array}{c|l|l}\text { case } & \text { solution } & \text { conditions } \\\hline 1 & T(n)=\Theta\left(n^{\log _{b} a}\right) & f(n)=O\left(n^{\log _{b} a-\varepsilon}\right) \text { for some constant } \varepsilon>0 \\\hline 2 & T(n)=\Theta\left(n^{\log _{b} a} \log ^{k+1} n\right) & f(n)=\Theta\left(n^{\log _{b} a} \log ^{k} n\right) \text { for some constant } k \geq 0 \\\hline 3 & T(n)=\Theta(f(n)) & f(n)=\Omega\left(n^{\log _{b} a+\varepsilon}\right) \text { for some constant } \varepsilon>0 \\& & \text { and } a f(n / b)<c f(n) \text { for some constant } 0<c<1\end{array}</script><p>Master Theorem当$f(n)$为多项式时可以简化，也就是递归的形式为$T(n)=aT(n/b)+\Theta(n^c),c\ge0$。</p><script type="math/tex; mode=display">\begin{array}{c|l|l|l}\text { case } & \text { solution } & \text { conditions } & \text { intuition } \\\hline 1 & T(n)=\Theta\left(n^{\log _{b} a}\right) & c<\log _{b} a & \text { Work done at leaves dominates } \\\hline 2 & T(n)=\Theta\left(n^{c} \log n\right) & c=\log _{b} a & \text { Work balanced across the tree } \\\hline 3 & T(n)=\Theta\left(n^{c}\right) & c>\log _{b} a & \text { Work done at root dominates }\end{array}</script><p>练习：<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/set3.jpg" alt=""></p><h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><p>Comparison Model：</p><ul><li>在这个模型中，假设算法只能通过比较来区分元素</li><li>Comparable items：只支持元素对之间比较的黑盒</li><li>比较为$&lt;,\le,&gt;,\ge,=,\neq$，输出是二元的：正确或错误</li><li>目标：存储$n$个可比较的元素，支持<code>find(k)</code>操作</li><li>运行时间以比较的表现为下界，因此数比较的次数</li></ul><p>Decision Tree：</p><ul><li>任何算法都可以被看作是一个决策树</li><li>内部的一个节点可以被看作一个二元比较，分支为True或False</li><li>对于一个比较算法，决策树是二元的</li><li>一个叶子表示算法终止，产生算法的输出</li><li>一个根节点到叶子节点的路径表示在某些输入上算法的执行</li><li>对每一个算法输出至少有一个节点，因此需要至少$\ge n+1$叶子节点(包含不存在)</li></ul><p>Comparison Search Lower Bonud</p><ul><li>比较查询算法(comparison search algorithm)最差情况下的运行时间是什么？</li><li>运行时间$\ge$比较$\ge$任何从根节点到叶子节点路径最大的长度$\ge$树的长度</li><li>任何节点数$\ge n$的二元树的最小高度是多少？</li><li>长度$\ge [\log (n+1)]-1=\Omega(\log n)$，因此任何比较排序的运行时间为$\Omega(\log n)$。</li><li>排序数组可以达到这个界限。</li><li>更一般地，叶子数为$\Theta(n)$和最大分支因子为$b$的树的长度为$\Omega(\log_b n)$。</li><li>为了更快，我们需要一个允许super-constant $w(1)$分支因子的操作，不过要怎么办？</li></ul><p>Direct Access Array</p><ul><li>利用Word-RAM $\mathcal{O}(1)$时间复杂度获取索引，线性的分支因子。</li><li>给定元素唯一整数键$k\in \{0,\cdots,u-1\}$，将其存储在一个数组中，索引为$k$</li><li>如果键可以存储在一个机器字节中，即$u\le 2^w$，最差$\mathcal{O}(1)$获取元素</li><li>但是空间$\mathcal{O}(u)$，当$n\ll u$时会很糟糕</li><li>例如如果键位十个字母的名字，如果一个比特一个名字，需要$26^{10}\approx 17.6$ TB空间</li><li>如何使用更少的空间呢？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectAccessArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, u</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A = [<span class="literal">None</span>] * u</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.A[k]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A[x.key] = x</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A[k] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(self.A)):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.A[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> self.A[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.A)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.A[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> self.A[i]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_max</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.A)):</span><br><span class="line"></span><br><span class="line">            x = self.A[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">                self.A[i] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>Hashing</p><ul><li>如果$n\ll u$，将键映射到小范围$m=\Theta(n)$并且使用小的direct access array</li><li>哈希函数：$h(k):\{0,\cdots, u-1\rightarrow \{0,\cdots,m-1\}$(也被称为哈希映射)</li><li>Direct access array 称为哈希表，$h(k)$被称为键$k$的哈希</li><li>如果$m\ll u$，根据鸠巢原理，没有哈希函数是单射的</li><li>总是存在键$a\neq b$使得$h(a)=h(b)$：冲突了(Collision)</li><li>不能将不同的元素存储在相同的索引处，所以存储在哪呢？要么：<ul><li>存储在数组中的其他位置(open addressing)：分析比较复杂，但是普遍和实用</li><li>存储在支持动态集合接口的其他数据结构中(chaining)</li></ul></li></ul><p>Chaining</p><ul><li>将冲突存储在另一个数据结构中(a chain)</li><li>如果键大致均匀地分布在索引上，链的大小为$n/m=n/\Omega(n)=\mathcal{O}(1)$</li><li>如果链的大小为$\mathcal{O}(1)$，则所有的操作需要$\mathcal{O}(1)$时间！</li><li>如果不是，许多元素映射到同一个位置，即$h(k)=\text{constant}$，链大小为$\Theta(n)$</li><li>需要好的哈希函数，但是什么是好的哈希函数呢？</li></ul><p>Hash Functions</p><ul><li>Division(bad)：$h(k) = (k \text{ mod }m)$<ul><li>当键是均匀分布的话很好</li><li>$m$对于存储的键应该避免对称</li><li>大于$2,10$的幂的大素数可以</li><li>Python实用加有一个混合的Division的一个版本</li><li>如果$u\gg n$，每一个哈希函数将有相同的产生$\mathcal{n}$长度链的输入</li><li>不要用固定的哈希函数。随机抽选一些(但是要小心)</li></ul></li><li>Universal(good, theoretically)：$h_{ab}(k)=(((ak+b)\text{ mod }p)\text{ mod }m)$<ul><li>哈希族$\mathcal{H}(p,m) = \{h_{ab}\mid a,b\in \{0,\cdots,p-1\} \text{ and }a\neq 0\}$</li><li>通过一个固定的素数$p&gt;u$进行参数化，其中$a,b$选自$\{0,1,\cdots,p-1\}$</li><li>$\mathcal{H}$为Universal family：$\Pr_{h\in\mathcal{H}}\{h(k_i)=h(k_j)\}\le 1/m\quad \forall k_i\neq k_j\in \{0,\cdots,u-1\}$</li><li>为什么universality是有用的呢？它暗示了短的链的长度(期望)</li><li>$X_{ij}$指示随机变量在$h\in\mathcal{H}: X_{ij}=1\text{ if }h(k_i)=h(k_j),X_{ij}=0\text{ otherwise}$</li><li>在索引$h(k_i)$处的链的长度为随机变量$X_i=\sim_j X_{ij}$</li><li>在索引$h(k_i)$处链的期望长度：</li></ul></li></ul><script type="math/tex; mode=display">\begin{aligned}\underset{h \in \mathcal{H}}{\mathbb{E}}\left\{X_{i}\right\}=\underset{h \in \mathcal{H}}{\mathbb{E}}\left\{\sum_{j} X_{i j}\right\}=\sum_{j} \underset{h \in \mathcal{H}}{\mathbb{E}}\left\{X_{i j}\right\} &=1+\sum_{j \neq i} \underset{h \in \mathcal{H}}{\mathbb{E}}\left\{X_{i j}\right\} \\&=1+\sum_{j \neq i}(1) \operatorname{Pr}_{h \in \mathcal{H}}\left\{h\left(k_{i}\right)=h\left(k_{j}\right)\right\}+(0) \underset{h \in \mathcal{H}}{\operatorname{Pr}}\left\{h\left(k_{i}\right) \neq h\left(k_{j}\right)\right\} \\& \leq 1+\sum_{j \neq i} 1 / m=1+(n-1) / m\end{aligned}</script><ul><li>因为$m = \Omega(n)$，所以上面得到的结果为$1+(n-1)/m=\mathcal{O}(1)$，所以期望为$\mathcal{O}(1)$</li></ul><p>Dynamic</p><ul><li>如果$n/m$远大于$1$，用随机选择的新的哈希函数重新构建新的大小$m$</li><li>与动态数组的分析方法一致，cost可以在很多动态操作上分摊(amortized)</li><li>因此一个哈希表可以以期望$\mathcal{O}(1)$的分摊时间来实现动态集合操作</li></ul><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/set4.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp2.itc.cn%2Fimages01%2F20200915%2Fcd3178c68249454aa8e8206ed7626cb6.jpeg&amp;refer=http%3A%2F%2Fp2.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1661380513&amp;t=cc08b97050020b95b97750370a407272&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;课程链接：&lt;a href=&quot;https://ocw.mit.edu/6-006S20&quot;&gt;https://ocw.mit.edu/6-006S20&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="编程" scheme="https://www.hfcouc.work/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法导论课程第一周</title>
    <link href="https://www.hfcouc.work/2022/07/19/alo1/"/>
    <id>https://www.hfcouc.work/2022/07/19/alo1/</id>
    <published>2022-07-19T06:53:32.000Z</published>
    <updated>2022-07-25T22:34:21.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p align="center">    <img src="https://img2.baidu.com/it/u=3208607819,4065748703&fm=253&fmt=auto&app=138&f=PNG?w=670&h=500" style="zoom: 100%;" /></p><blockquote><p>课程链接：<a href="https://ocw.mit.edu/6-006S20">https://ocw.mit.edu/6-006S20</a></p></blockquote><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本课程的目的是教你去解决计算问题，同时证明的解决方案是正确和搞笑的。<br>问题：</p><ul><li>从问题输入到正确输出的二元关系</li><li>提供正确输出必须满足的条件</li><li>非一般情况：<ul><li>例子：在这个房间里，有生日一样的同学吗</li></ul></li><li>一般情况：<ul><li>例子：给定任意$n$个学生，有没有生日相同的同学<br>算法</li></ul></li><li>将每个输入映射到单个(确定)输出的过程</li><li>算法解决了问题当对于每一个问题输入他都能返回正确的输出</li><li>例子：一个解决生日匹配的算法<ul><li>保存生日和姓名的记录(初始为空)</li><li>以一种顺序采访每一位同学<ul><li>如果生日存在在记录中，返回找到了匹配队</li><li>否则将生日和姓名添加到记录中</li></ul></li><li>返回空如果最后一个通过也没有匹配成功</li></ul></li></ul><p>正确性：</p><ul><li>程序/算法有固定的大小，所以如何证明其正确性</li><li>对于小的输入，可以分析例子</li><li>对于任意大的输入，算法必须是可以递归或循环的</li><li>必须使用归纳(induction)</li><li>例子：证明生日匹配算法的正确性<ul><li>在$k$上归纳：记录的同学的人数</li><li>假设(Hypothesis)：如果前$k$个存在匹配，在采访第$k+1$个学生之前返回匹配</li><li>Base case：$k=0$时，$k$没有包含匹配</li><li>假设归纳假设对于$k=k^\prime$成立，考虑$k^\prime+1$</li><li>如果前$k^\prime$个存在一个匹配，那么在归纳之前就已经返回了</li><li>如果前$k^\prime$没有匹配，因此如果前$k^\prime+1$个存在匹配，匹配包括$k^\prime+1$</li><li>算法直接检查学生$k^\prime+1$在是否在前$k^\prime$出现</li></ul></li></ul><p>效率(Efficiency)：</p><ul><li>一个算法产生一个正确输出有多快<ul><li>可以衡量时间，但是时间与机器的性能有关</li><li>可以衡量具有固定时间操作的个数</li><li>与输入大小有关系：越大说明需要更长时间</li><li>是高效的如果是输入大小的多项式函数</li><li>有些时候对于某个问题不存在高效的算法</li></ul></li><li>渐进符号：忽略常数项和低阶项<ul><li>上界$\mathcal{O}$，下界$\Omega$，严格界限$\Theta$</li><li>以下时间估计基于<code>1GHz</code>单核机器上每个周期的一次操作</li></ul></li></ul><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|c|}\hline \text { input } & \text { constant } & \text { logarithmic } & \text { linear } & \text { log-linear } & \text { quadratic } & \text { polynomial } & \text { exponential } \\\hline n & \Theta(1) & \Theta(\log n) & \Theta(n) & \Theta(n \log n) & \Theta\left(n^{2}\right) & \Theta\left(n^{c}\right) & 2^{\Theta\left(n^{c}\right)} \\\hline 1000 & 1 & \approx 10 & 1000 & \approx 10,000 & 1,000,000 & 1000^{c} & 2^{1000} \approx 10^{301} \\\hline \text { Time } & 1 n s & 10 n s & 1 \mu s & 10 \mu s & 1 m s & 10^{3 c-9} s & 10^{281} \text { millenia } \\\hline\end{array}</script><p>计算模型：</p><ul><li>说明可以在$\mathcal{O}(1)$时间内在机器上执行哪些操作</li><li>这类模型被称为<code>Word-RAM</code></li><li>Machine word：$w$位的一个块($w$为一个$w$-bit Word-RAM的字长)</li><li>Memory：可以寻址的字长序列</li><li>处理器支持很多常数时间的操作，在$\mathcal{O}(1)$字数<ul><li>正数算数：$+,-,<em>,//,\%</em>$</li><li>逻辑运算：<code>`&amp;&amp;，||，!，==，&lt;,&gt;,&lt;=,=&gt;</code></li><li>比特算数：<code>&amp;,|,&lt;&lt;,&gt;&gt;</code></li><li>给定word$a$，可以在读取地址$a$的字，写数据到地址$a$</li></ul></li><li>内存地址必须可以访问在内存中的任何位置<ul><li>需要$w\ge$表示最大内存地址的位数</li><li>$32$位的最大为$4$GB内存，$64$位的最大为$16$EB</li></ul></li></ul><p>数据结构</p><ul><li>数据结构是存储无限值数据的一种方式，并支持一系列操作</li><li>一系列操作的集合被称为接口(interface)<ul><li>序列</li><li>集合</li></ul></li><li>数据结构可能使用不同的方法实现相同的接口</li><li>例子：静态列表：固定长度，静态序列接口<ul><li>StaticArray(n)：分配大小为$n$的静态数组以$\Theta(n)$的时间</li><li>StaticArray.get_at(i)：返回索引为$i$的数据以$\Theta(1)$的时间</li><li>StaticArray.set_at(i,x)：将索引为$i$的位置写入数据$x$以$\Theta(1)$的时间</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">birthday_match</span>(<span class="params">students</span>):</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Find a pair of students with the same birthday</span></span><br><span class="line"><span class="string">Input: tuple of student(name, bday) tuples</span></span><br><span class="line"><span class="string">Output: tuple of student names or None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">n = <span class="built_in">len</span>(students)         <span class="comment">#O(1)</span></span><br><span class="line">record = StaticArray(n)   <span class="comment"># O(n)</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):        <span class="comment"># n</span></span><br><span class="line">(name1, bay1) = students[k] <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):    <span class="comment"># k</span></span><br><span class="line">(name2, bday2) = record.get_at(i)   <span class="comment">#O(1)</span></span><br><span class="line"><span class="keyword">if</span> bday1 == bday2:       <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">return</span> (name1, name2)</span><br><span class="line">record.set_at(k ,(name1, bday1))    <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>时间复杂度为：</p><script type="math/tex; mode=display">O(n) + \sum_{k=0}^{n-1}(O(1)+k\cdot O(1)) = O(n^2)</script><p>为$n$的多项式函数，所以该算法是高效的。</p><h3 id="Asymptotic-Notation"><a href="#Asymptotic-Notation" class="headerlink" title="Asymptotic Notation"></a>Asymptotic Notation</h3><p>下面我们详细地说明一下渐进符号：<br>$O(f(n))$表示定义域为自然数满足下列性质的函数的集合：<br>$O$符号：非负函数$g(n)$属于$O(f(n))$当且仅当存在正实数$c$和正整数$n_0$使得对于所有的$n\ge n_0$都有$g(n)\le c\cdot f(n)$。<br>$\Omega$符号：非负函数$g(n)$属于$\Omega(f(n))$当且仅当存在正实数$c$和正整数$n_0$使得对于所有的$n\ge n_0$都有$c\cdot f(n)\le g(n)$。<br>$\Theta$符号：非复函数$g(n)$属于$\Theta(f(n))$当且仅当$g(n)\in O(f(n))\cap \Omega(f(n))$。</p><h2 id="DATA-STRUCTURES-AND-DYNAMIC-ARRAYS"><a href="#DATA-STRUCTURES-AND-DYNAMIC-ARRAYS" class="headerlink" title="DATA STRUCTURES AND DYNAMIC ARRAYS"></a>DATA STRUCTURES AND DYNAMIC ARRAYS</h2><p>首先我们先区分一下接口(Interface(API/ADT))和数据结构(Data Structure)。<br>接口相当于是规范，他告诉我们可以存储什么样的数据，而数据结构会给你一个实际的表示(representation)来告诉你如何去存储数据。接口告诉我们支持什么样的操作，数据结构给我们实现这些操作的算法。你可以把结构理解为问题，而数据结构则是解决方案。</p><p>我们将会讨论两类重要的接口：</p><ul><li>集合(set)</li><li>序列(sequence)<br>我们也将会讨论两个主要的数据结构的工具：</li><li>数组(arrays)</li><li>基于指针的(pointer based)</li></ul><h3 id="Static-sequence-interface"><a href="#Static-sequence-interface" class="headerlink" title="Static sequence interface"></a>Static sequence interface</h3><p>static sequence interface：存储序列$x_0,x_1,\cdots,x_{n-1}$，并且支持以下操作：</p><ul><li>build(X)：对$X$中的元素创建一个新的数据结构</li><li>len(X)：返回$X$的长度$n$</li><li>iter_seq()：以序列的顺序输出$x_0,x_1,\cdots,x_{n-1}$</li><li>get_at(i)：或者$X$中索引为$i$的$x_i$</li><li>set_at(i,X)：将$x_i$设置为$x$<br>解决这一问题的数据结构我们称为static array：数组中的数据在内存中的存储是连续的。这就意味着当我们访问数组中的某个索引的元素就等价于访问内存中数据的初始位置加上元素在数组中内存的索引的位置。同时我们假设对数组数据访问花费的时间是常数（这要求机器的字节数(现在一般为$64$位，可以一次读取$2^{64}$字节的数据)$w\ge \log n$）。也就意味着我们在<code>get_at</code>、<code>len</code>和<code>set_at</code>操作花费的时间是$\mathcal{O}(1)$，而在<code>build</code>和<code>iter_seq</code>操作花费时间为$\mathcal{O}(n)$。<br>我们是如何创建静态数组的呢？有很多的内存分配模型(Memory allocation model)：在这里我们假设分配一个长度为$n$的数组耗费的时间为$\mathcal{O}(n)$，这样还可以得到我们消耗的空间为$\mathcal{O}(\text{time})$。</li></ul><h3 id="Dynamic-sequence-interface"><a href="#Dynamic-sequence-interface" class="headerlink" title="Dynamic sequence interface"></a>Dynamic sequence interface</h3><p>他是静态数组加上下面几个操作：</p><ul><li>insert_at(i,x)：在索引$i$处插入$x$，后面的以此后移</li><li>deleta_at(i)：删除索引处$i$的数据，后面的依次前移</li><li>insert_first(x)：将x插入第一个位置</li><li>delete_first(x)：删除并返回第一个元素</li><li>insert_last(x)：将x添加到最后一个位置</li><li>delete_last(x)：删除并返回最后一个元素</li></ul><p>链表指的是前一个对象除了存储自己的数值外，还存储下一个对象的地址。静态数组指的是长度不会改变的数组。下面我们比较一下两者。<br>当我们在数组的第一个位置插入或删除元素时，静态列表需要所有的元素都向后或向前移动，耗费的时间复杂度为$\mathcal{O}(n)$，而由于静态数组的长度是不能变换的，所以在末尾添加元素需要我们将原有的数组重新复制一遍，耗费的时间复杂度为$\mathcal{O}(n)$；而链表在第一个位置插入元素只需要将头指针指向要插入的元素，将要插入的元素储存的地址指向原来的第一个元素的地址，删除第一个元素的话只需要将头指针指向第二个元素的地址，时间复杂度为$\mathcal{O}(1)$，但是当需要访问数据时，我们需要这个寻址，耗费的时间复杂度为$\mathcal{O}(n)$。<br>可以看出静态数组在非动态操作(查询元素等)的时间复杂度要比链表低，而链表的动态操作(插入、删除元素)的时间复杂度比较低，现在我们将两者擅长的操作结合在一起，即得到动态数组。</p><h3 id="Dynamic-arrays"><a href="#Dynamic-arrays" class="headerlink" title="Dynamic arrays"></a>Dynamic arrays</h3><p>动态数组在Python中即为列表(list)。<br>动态数组放松了数组大小必须为$n$的约束，我们令数组的大小为$\Theta(n)\ge n$。<br>动态数组的头包含了数组的首地址、存储的数据的数量和数组的大小，当我们在数组最后插入元素时，如果数组的大小还够，直接在后面插入即可，但是如果此时数组的大小正好等于数组中元素的大小，我们需要重新分配一个数组，其大小为原来的$2$倍或者其他，也可以为原来的大小$+5$，但是当我们这样做时，我们需要每$5$次都重新分配一次内存，但是相比较于静态数组每一次都要重新分配一下内存还是好的。<br>假设我们有一个空的动态列表，我们每一次往里面加入元素，第一次加入一个我们将去大小扩充为$1$，第二次加入元素，我们将其大小扩充为$2$，第三次加入元素我们将其扩充为$4$，第四次加入不扩充，第五次加入元素扩充为$8$，这样以此类推，那么对于长度的$n$的数组我们花费的时间复杂度为：</p><script type="math/tex; mode=display">\sum_{i=1}^{\log_2 n}2^i = \mathcal{O}(n)</script><p>可以看出其时间复杂度为线性的。我们将这种现象称为Amortization：如果任何$K$个操作耗费的时间复杂度$\le K\cdot T(n)$，那么每个操作的时间复杂度为$T(n)$。所以每次在最后面插入一个元素的时间复杂度为$\mathcal{O}(1)$。</p><p>所以我们最终的结果为：<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/alo1.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://img2.baidu.com/it/u=3208607819,4065748703&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=670&amp;h=500&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;课程链接：&lt;a href=&quot;https://ocw.mit.edu/6-006S20&quot;&gt;https://ocw.mit.edu/6-006S20&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="编程" scheme="https://www.hfcouc.work/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>B站课程Mathematica剩余部分</title>
    <link href="https://www.hfcouc.work/2022/07/18/math2/"/>
    <id>https://www.hfcouc.work/2022/07/18/math2/</id>
    <published>2022-07-18T06:58:49.000Z</published>
    <updated>2022-07-19T06:59:28.798Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p align="center">    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F13376661231%2F641&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660719664&t=7a06182fcd2599240cf9b86397be591b" style="zoom: 100%;" /></p><blockquote><p> B站课程链接：<a href="https://www.bilibili.com/video/BV1av411N7Xi?spm_id_from=333.999.0.0&amp;vd_source=6177c61c946280bb88c727585de76bc8">https://www.bilibili.com/video/BV1av411N7Xi?spm_id_from=333.999.0.0&amp;vd_source=6177c61c946280bb88c727585de76bc8</a></p></blockquote><span id="more"></span><h2 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h2><h3 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h3><p><code>Mathematica</code>的第二原理：计算即重写。所谓重写，即将匹配成功的模式改为其他形式。Mathematica就是由一大堆重写规则组成的。</p><p>重写规则的一般形式是：</p><p><code>(模式)    (重写符号)    (重写结果)</code></p><p>其中重写符号有四种：<code>-&gt;、:&gt;、=、:=</code>，分别叫做规则、延迟规则、赋值、延迟赋值。重写结果则是一个表达式，它可以依赖重写符号左边被命名的子模式。</p><p>规则与延迟规则是一种较为安全的重写机制，因为只有在你应用它们的时候它们才起作用。而赋值和延迟赋值则是添加到系统内部的一种重写规则，一旦添加进去就立刻起作用，并永远存在，除非你手动移除它们(<code>=.、Clear、Remove</code>)。</p><p>最常见的规则出现在<code>Solve</code>类函数的返回值中：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = Solve[x^<span class="number">3</span> - <span class="number">3</span> x + <span class="number">2</span> == <span class="number">0</span>, x]</span><br><span class="line">&#123;&#123;x -&gt; -<span class="number">2</span>&#125;, &#123;x -&gt; <span class="number">1</span>&#125;, &#123;x -&gt; <span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>Solve</code>的结果是不唯一的，<code>Mathematica</code>并不知道我们打算用哪一个，所以只好将它们存储为规则，我们可以从中挑选出我们想要的，然后将它应用在其他地方。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Expand</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">^</span><span class="number">4</span> <span class="operator">+</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="number">1</span> <span class="operator">/.</span> <span class="variable">result</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>我们也可以不挑选，这样得到一个由不同规则到来的结果构成的表。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expand[x^<span class="number">4</span> + x^<span class="number">2</span> + <span class="number">1</span> /. result]</span><br><span class="line">&#123;<span class="number">21</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>注意在上述操作时，<code>x</code>并未发生改变。</p><p>规则比赋值灵活，因为赋值是定义全局变量。全局变量一旦重命名就很容易造成程序错误。这是<code>Mathematica</code>中最常见的一类错误。为了避免这种错误才有了这种模块化的机制。</p><p>规则的左边可以是模式：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rule</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">g</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">rule</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">25</span> <span class="operator">+</span> <span class="variable">g</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>得到的结果与我们的期望一致，但是</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">rule = (f[x_] -&gt; x^<span class="number">2</span>);</span><br><span class="line">f[<span class="number">5</span>] + g[<span class="number">2</span>] /. rule</span><br><span class="line">&gt; <span class="number">1</span> + g[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>就会出现问题，这是因为规则直接将全局变量带入了，变成了：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rule</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是如果使用延迟规则：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">rule = f[x_] :&gt; x^<span class="number">2</span>;</span><br><span class="line">f[<span class="number">5</span>] + g[<span class="number">2</span>] /. rule</span><br><span class="line">&gt; <span class="number">25</span> + g[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>规则和延迟规则(以及赋值和延迟赋值)的区别在于：规则指向的表达式会被<code>Mathematica</code>立刻取值，以后应用这条规则时将直接引用这个值；而延迟规则指向的表达式会被<code>Mathematica</code>认为是一个程序的入口，之后每次应用这条规则时，<code>Mathematica</code>都会重新计算一边这个表达式。</p><p>当规则不止一条时，我们把所有规则组成一个表，然后应用它。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">(</span><span class="variable">a</span><span class="operator">^</span><span class="variable">b</span><span class="punctuation">)</span><span class="operator">^</span><span class="variable">c</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="punctuation">(</span><span class="type">x_</span><span class="operator">^</span><span class="type">y_</span><span class="punctuation">)</span><span class="operator">^</span><span class="type">z_</span> <span class="operator">:&gt;</span> <span class="variable">x</span><span class="operator">^</span><span class="punctuation">(</span><span class="variable">y</span> <span class="variable">z</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">a</span> <span class="operator">-&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="variable">b</span> <span class="operator">-&gt;</span> <span class="number">3</span><span class="operator">,</span> <span class="variable">c</span> <span class="operator">-&gt;</span> <span class="number">4</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">a</span><span class="operator">^</span><span class="punctuation">(</span><span class="variable">b</span> <span class="variable">c</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>我们发现只应用了第一个规则，其他规则都没用。这是因为匹配到规则表中的某个规则后，这个规则将会被应用一次，他之后的规则将被忽略。如果向反复匹配、应用，直到找不出可进一步化简的模式，可以用<code>//.</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rule</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="built_in">Log</span><span class="punctuation">[</span><span class="type">x_</span> <span class="type">y_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">rule</span></span><br><span class="line"><span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">rule</span> <span class="operator">/.</span> <span class="variable">rule</span></span><br><span class="line"><span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span> <span class="operator">//.</span> <span class="variable">rule</span></span><br><span class="line"><span class="built_in">FixedPoint</span><span class="punctuation">[</span><span class="type">#</span> <span class="operator">/.</span> <span class="variable">rule</span> <span class="operator">&amp;,</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">c</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">d</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">c</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">d</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><code>FixedPoint</code>函数将一个函数应用到某个对象，直到这个对象不变为止，<code>.//</code>就是这样实现的。</p><p>运算符<code>/.</code>和<code>//.</code>的全名分别是ReplaceAll和ReplaceRepeated，它们的一个共同特点是它们会对它们左边表达式的每个子表达式进行匹配和替换。有些时候我们希望控制这种搜索的深度，这时候就需要用Replace这个函数。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Replace</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">^</span><span class="number">2</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">-&gt;</span> <span class="variable">a</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Replace</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">^</span><span class="number">2</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">-&gt;</span> <span class="variable">a</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Replace</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">^</span><span class="number">2</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">-&gt;</span> <span class="variable">a</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">a</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">a</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Replace只返回第一个匹配成功的重写结果，有时候我们希望考察所有可能的重写结果，这时候可以用ReplaceList这个函数。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Replace</span><span class="punctuation">[</span><span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">+</span> <span class="type">y_</span> <span class="operator">:&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">ReplaceList</span><span class="punctuation">[</span><span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">+</span> <span class="type">y_</span> <span class="operator">:&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="operator">,</span> <span class="variable">a</span> <span class="operator">+</span> <span class="variable">c</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="operator">,</span> <span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span> <span class="operator">+</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line"> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>例：打印乘法表</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">times</span><span class="punctuation">[</span><span class="type">x_</span><span class="operator">,</span> <span class="type">y_</span><span class="punctuation">]</span> <span class="operator">:=</span> </span><br><span class="line">  <span class="built_in">ToString</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="operator">&lt;&gt;</span> <span class="string">&quot;x&quot;</span> <span class="operator">&lt;&gt;</span> <span class="built_in">ToString</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span> <span class="operator">&lt;&gt;</span> <span class="string">&quot;=&quot;</span> <span class="operator">&lt;&gt;</span> <span class="built_in">ToString</span><span class="punctuation">[</span><span class="variable">x</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="string">&quot;1x1=1&quot;</span><span class="operator">,</span> <span class="string">&quot;1x2=2&quot;</span><span class="operator">,</span> <span class="string">&quot;1x3=3&quot;</span><span class="operator">,</span> <span class="string">&quot;1x4=4&quot;</span><span class="operator">,</span> <span class="string">&quot;1x5=5&quot;</span><span class="operator">,</span> <span class="string">&quot;1x6=6&quot;</span><span class="operator">,</span> <span class="string">&quot;1x7=7&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;1x8=8&quot;</span><span class="operator">,</span> <span class="string">&quot;1x9=9&quot;</span><span class="operator">,</span> <span class="string">&quot;2x2=4&quot;</span><span class="operator">,</span> <span class="string">&quot;2x3=6&quot;</span><span class="operator">,</span> <span class="string">&quot;2x4=8&quot;</span><span class="operator">,</span> <span class="string">&quot;2x5=10&quot;</span><span class="operator">,</span> <span class="string">&quot;2x6=12&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;2x7=14&quot;</span><span class="operator">,</span> <span class="string">&quot;2x8=16&quot;</span><span class="operator">,</span> <span class="string">&quot;2x9=18&quot;</span><span class="operator">,</span> <span class="string">&quot;3x3=9&quot;</span><span class="operator">,</span> <span class="string">&quot;3x4=12&quot;</span><span class="operator">,</span> <span class="string">&quot;3x5=15&quot;</span><span class="operator">,</span> <span class="string">&quot;3x6=18&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;3x7=21&quot;</span><span class="operator">,</span> <span class="string">&quot;3x8=24&quot;</span><span class="operator">,</span> <span class="string">&quot;3x9=27&quot;</span><span class="operator">,</span> <span class="string">&quot;4x4=16&quot;</span><span class="operator">,</span> <span class="string">&quot;4x5=20&quot;</span><span class="operator">,</span> <span class="string">&quot;4x6=24&quot;</span><span class="operator">,</span> <span class="string">&quot;4x7=28&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;4x8=32&quot;</span><span class="operator">,</span> <span class="string">&quot;4x9=36&quot;</span><span class="operator">,</span> <span class="string">&quot;5x5=25&quot;</span><span class="operator">,</span> <span class="string">&quot;5x6=30&quot;</span><span class="operator">,</span> <span class="string">&quot;5x7=35&quot;</span><span class="operator">,</span> <span class="string">&quot;5x8=40&quot;</span><span class="operator">,</span> <span class="string">&quot;5x9=45&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;6x6=36&quot;</span><span class="operator">,</span> <span class="string">&quot;6x7=42&quot;</span><span class="operator">,</span> <span class="string">&quot;6x8=48&quot;</span><span class="operator">,</span> <span class="string">&quot;6x9=54&quot;</span><span class="operator">,</span> <span class="string">&quot;7x7=49&quot;</span><span class="operator">,</span> <span class="string">&quot;7x8=56&quot;</span><span class="operator">,</span> <span class="string">&quot;7x9=63&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;8x8=64&quot;</span><span class="operator">,</span> <span class="string">&quot;8x9=72&quot;</span><span class="operator">,</span> <span class="string">&quot;9x9=81&quot;</span><span class="punctuation">&#125;</span><span class="variable">timesTable</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> </span><br><span class="line">  <span class="variable">times</span> <span class="operator">@@@</span> </span><br><span class="line">   <span class="built_in">Sort</span><span class="punctuation">[</span><span class="built_in">ReplaceList</span><span class="punctuation">[</span></span><br><span class="line">     <span class="built_in">Range</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span> <span class="operator">:&gt;</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> </span><br><span class="line">        <span class="type">y_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span> <span class="operator">:&gt;</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">timesTable</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="string">&quot;1x1=1&quot;</span><span class="operator">,</span> <span class="string">&quot;1x2=2&quot;</span><span class="operator">,</span> <span class="string">&quot;1x3=3&quot;</span><span class="operator">,</span> <span class="string">&quot;1x4=4&quot;</span><span class="operator">,</span> <span class="string">&quot;1x5=5&quot;</span><span class="operator">,</span> <span class="string">&quot;1x6=6&quot;</span><span class="operator">,</span> <span class="string">&quot;1x7=7&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;1x8=8&quot;</span><span class="operator">,</span> <span class="string">&quot;1x9=9&quot;</span><span class="operator">,</span> <span class="string">&quot;2x2=4&quot;</span><span class="operator">,</span> <span class="string">&quot;2x3=6&quot;</span><span class="operator">,</span> <span class="string">&quot;2x4=8&quot;</span><span class="operator">,</span> <span class="string">&quot;2x5=10&quot;</span><span class="operator">,</span> <span class="string">&quot;2x6=12&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;2x7=14&quot;</span><span class="operator">,</span> <span class="string">&quot;2x8=16&quot;</span><span class="operator">,</span> <span class="string">&quot;2x9=18&quot;</span><span class="operator">,</span> <span class="string">&quot;3x3=9&quot;</span><span class="operator">,</span> <span class="string">&quot;3x4=12&quot;</span><span class="operator">,</span> <span class="string">&quot;3x5=15&quot;</span><span class="operator">,</span> <span class="string">&quot;3x6=18&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;3x7=21&quot;</span><span class="operator">,</span> <span class="string">&quot;3x8=24&quot;</span><span class="operator">,</span> <span class="string">&quot;3x9=27&quot;</span><span class="operator">,</span> <span class="string">&quot;4x4=16&quot;</span><span class="operator">,</span> <span class="string">&quot;4x5=20&quot;</span><span class="operator">,</span> <span class="string">&quot;4x6=24&quot;</span><span class="operator">,</span> <span class="string">&quot;4x7=28&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;4x8=32&quot;</span><span class="operator">,</span> <span class="string">&quot;4x9=36&quot;</span><span class="operator">,</span> <span class="string">&quot;5x5=25&quot;</span><span class="operator">,</span> <span class="string">&quot;5x6=30&quot;</span><span class="operator">,</span> <span class="string">&quot;5x7=35&quot;</span><span class="operator">,</span> <span class="string">&quot;5x8=40&quot;</span><span class="operator">,</span> <span class="string">&quot;5x9=45&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;6x6=36&quot;</span><span class="operator">,</span> <span class="string">&quot;6x7=42&quot;</span><span class="operator">,</span> <span class="string">&quot;6x8=48&quot;</span><span class="operator">,</span> <span class="string">&quot;6x9=54&quot;</span><span class="operator">,</span> <span class="string">&quot;7x7=49&quot;</span><span class="operator">,</span> <span class="string">&quot;7x8=56&quot;</span><span class="operator">,</span> <span class="string">&quot;7x9=63&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;8x8=64&quot;</span><span class="operator">,</span> <span class="string">&quot;8x9=72&quot;</span><span class="operator">,</span> <span class="string">&quot;9x9=81&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>之前我们提到过<code>@@</code>可以换头，而<code>@@@</code>可以换内部的头：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">head</span> <span class="operator">@@@</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">k</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">head</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">head</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">head</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>规则(Rule、Delayed)和替换(Replace、ReplaceAll、ReplaceRepeated、ReplaceList)是比较安全的重写机制，下面我们看不安全的重写、即赋值。</p><p>赋值与规则的一大不同是：赋值操作所定义的重写方法则总是从属于某个符号的，而规则是独立存在的。</p><p>为什么会如此？因为如果不将全局规则(赋值)分派给某个符号，而是作为独立规则存在，那么在做任何计算的时候，都要检查以下待计算的表达式中是否有能够匹配全局规则的子表达式存在，这是极大的浪费。如果全局规则从属于某个符号，那么只有在遇到这个符号的时候我们才需要去尝试匹配，这就比较有效率。</p><p>运算符<code>=.</code>每次清掉一条赋值，如果想要清空所有赋值，可以用<code>Clear</code>函数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">n</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=.</span> <span class="comment">(*只清除f[1]*)</span></span><br><span class="line"><span class="built_in">Clear</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">]</span> <span class="comment">(*清空所有f*)</span></span><br><span class="line"><span class="built_in">Clear</span><span class="punctuation">[</span><span class="string">&quot;Global`*&quot;</span><span class="punctuation">]</span><span class="comment">(*清空所有变量*)</span></span><br></pre></td></tr></table></figure><p>Clear的作用是清掉规则，之后的符号还存在于系统中，还占着内存。如果想完全移除这个变量，将它占用的内存释放掉，则应该用Remove。</p><p>赋值行为也可以以其他的形式出现：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">i</span><span class="operator">=</span><span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">x</span><span class="operator">=</span><span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">i</span><span class="operator">++</span></span><br><span class="line"><span class="variable">i</span><span class="operator">--</span></span><br><span class="line"><span class="operator">++</span><span class="variable">i</span></span><br><span class="line"><span class="operator">--</span><span class="variable">i</span></span><br><span class="line"><span class="variable">i</span> <span class="operator">+=</span> <span class="variable">di</span></span><br><span class="line"><span class="variable">i</span> <span class="operator">-=</span> <span class="variable">di</span></span><br><span class="line"><span class="variable">x</span> <span class="operator">*=</span> <span class="variable">c</span></span><br><span class="line"><span class="variable">x</span> <span class="operator">/=</span> <span class="variable">c</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span><span class="operator">+</span> <span class="variable">di</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">c</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>赋值还可以同时进行</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">x</span> <span class="operator">=</span> <span class="variable">y</span> <span class="operator">=</span> <span class="variable">value</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">&#125;</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="variable">value1</span><span class="operator">,</span> <span class="variable">value2</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">&#125;</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>有一些函数可以改变其参数的值：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">list</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">AppendTo</span><span class="punctuation">[</span><span class="variable">list</span> <span class="operator">,</span><span class="variable">d</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">PrependTo</span><span class="punctuation">[</span><span class="variable">list</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>再次强调一下，AppendTo和PrependTo这两个函数是比较慢的。对于比较长的表，尽量不要反复用它们。</p><p>当习惯于C语言编程的人编写Mathematica程序的时候，总是喜欢用表来存储数组。</p><p>事实上在Mathematica中，更好的做法是把数组视为从自然数到其他集合的函数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">a</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">a</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">n</span><span class="operator">/</span><span class="number">2</span> <span class="operator">/;</span> <span class="built_in">EvenQ</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Array</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="number">10</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">[</span><span class="number">7</span><span class="punctuation">]</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">]</span><span class="operator">,</span> <span class="number">5</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这样的好处是，函数对象不需要初始化，也不需要指定尺寸。</p><p>另外，函数的自变量可以是任何东西，所以可以实现一些更有趣的结构。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张三<span class="punctuation">[</span>身高<span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1.75</span> <span class="variable">m</span><span class="operator">;</span></span><br><span class="line">张三<span class="punctuation">[</span>体重<span class="punctuation">]</span> <span class="operator">=</span> <span class="number">70</span> <span class="variable">kg</span><span class="operator">;</span></span><br><span class="line">谁<span class="type">_</span><span class="punctuation">[</span><span class="variable">BMI</span><span class="punctuation">]</span> <span class="operator">^:=</span> 谁<span class="punctuation">[</span>体重<span class="punctuation">]</span> <span class="operator">/</span> 谁<span class="punctuation">[</span>身高<span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="operator">;</span></span><br><span class="line">张三<span class="punctuation">[</span><span class="variable">BMI</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">(</span><span class="number">22.8571</span> <span class="variable">kg</span><span class="punctuation">)</span><span class="operator">/</span><span class="variable">m</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这种写法实际上体现了一种面向对象编程的想法，下面是另一种更花哨的写法：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张三 <span class="operator">/:</span> 张三<span class="operator">.</span>身高 <span class="operator">=</span> <span class="number">1.75</span> <span class="variable">m</span><span class="operator">;</span></span><br><span class="line">张三 <span class="operator">/:</span> 张三<span class="operator">.</span>体重 <span class="operator">=</span> <span class="number">70</span> <span class="variable">kg</span><span class="operator">;</span></span><br><span class="line"><span class="variable">BMI</span> <span class="operator">/:</span> <span class="punctuation">(</span>谁<span class="type">_</span><span class="punctuation">)</span><span class="operator">.</span><span class="variable">BMI</span> <span class="operator">:=</span> <span class="punctuation">(</span>谁<span class="operator">.</span>体重<span class="punctuation">)</span><span class="operator">/</span><span class="punctuation">(</span>谁<span class="operator">.</span>身高<span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line">张三<span class="operator">.</span><span class="variable">BMI</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">(</span><span class="number">22.8571</span> <span class="variable">kg</span><span class="punctuation">)</span><span class="operator">/</span><span class="variable">m</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>新出现的两个运算符<code>^:=</code>和<code>/:</code>我们稍后再解释。</p><p>赋值和规则的另一个重大不同是：多次赋值产出的规则表是按照从特殊到一般的顺序来应用的，而且与它们出现的顺序无关；规则表则不同，应用顺序等于它们在表中的排列顺序。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">g</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">g</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这里<code>f[1]=1</code>和<code>g[n]=1</code>为特殊规则，故不管顺序如何，结果都是<code>&#123;1,3&#125;</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="variable">h</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="variable">h</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">h</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="variable">h</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="number">1</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而规则则与顺序有关。</p><p>如果要使用很长的规则表<code>&#123;p1-&gt;r1,p2-&gt;r2,......&#125;</code>，最好用<code>Mathematica</code>内部函数<code>Dispatch</code>压缩一下，这样可以提高替换的效率。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rules</span> <span class="operator">=</span> <span class="built_in">Table</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="built_in">RandomInteger</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="variable">i</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">dispatch</span> <span class="operator">=</span> <span class="built_in">Dispatch</span><span class="punctuation">[</span><span class="variable">rules</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="built_in">Table</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">rules</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="built_in">Table</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">dispatch</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">2.125</span><span class="operator">,</span> <span class="built_in">Null</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">0.015625</span><span class="operator">,</span> <span class="built_in">Null</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Mathematica</code>中同时赋值、延迟赋值和全局规则等原理可以帮助我们实现一种非常优雅的机制。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">20</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">0.015625</span><span class="operator">,</span> <span class="number">10946</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="number">20</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">0.</span><span class="operator">,</span> <span class="number">10946</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到比之前快了很多。在后一种实现中，因为多了一个同时赋值，所以之前计算过的值都被自动存储下来，这对于递归函数来说非常重要，因为可以减少大量的重复计算。</p><p>我们之前说过，赋值这个规则总是从属于某个符号的。一个重要的问题是，到底从属于哪个符号？</p><p>对于下面的语句</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">F</span><span class="punctuation">[</span><span class="variable">X1</span><span class="operator">,</span><span class="variable">X2</span><span class="operator">,...,</span><span class="variable">Xn</span><span class="punctuation">]</span><span class="operator">=</span><span class="variable">value</span></span><br></pre></td></tr></table></figure><p>Mathematica默认这样一条规则是从属于符号F。</p><p>但这未必是我们想要的，例如前面张三的BMI这个例子中，左边表达式的头”谁_”是一个模式，而不是固定的符号，这时候就无法分配这条规则。另一种情况是：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">log</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">log</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">log</span><span class="punctuation">[</span><span class="variable">x</span> <span class="variable">y</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>因为左边表达式的头为<code>Plus</code>，我们无法改变其规则。尽管我们可以通过解除保护的方法强行对函数Plus增加一条规则，但这不是正确的做法。因为这样做的后果是，系统每次进行加法运算都不得不检查待计算的表达式是否符合我们增加的这条规则，这是极大的资源浪费。</p><p>对于这两种情况，我们都需要一种机制，来指定规则所从属的对象。例如在第一个例子中，我们可以将这条规则指定给BMI这个符号，在第二个例子中，我们可以将规则给自定义函数log。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">log</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">log</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span> <span class="operator">^:=</span> <span class="variable">log</span><span class="punctuation">[</span><span class="variable">x</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="operator">?</span><span class="variable">log</span></span><br><span class="line"><span class="operator">&gt;</span>  <span class="variable">UpValue</span> <span class="variable">Definitions</span><span class="variable">log</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span><span class="operator">+</span><span class="variable">log</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span><span class="operator">^:=</span><span class="variable">log</span><span class="punctuation">[</span><span class="variable">x</span> <span class="variable">y</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>可以看到这条规则附属于log。</p><p>一般来说，运算符<code>^:=</code>会将这条规则指定给下层的所有不受保护的函数，此时赋值号右边的值叫做这些函数的<code>upvalue</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">^:=</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="built_in">Sin</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><p>此时规则挂在<code>f</code>下的函数<code>g</code>和<code>h</code>上。</p><p>如果我们想要更明确地指派规则，可以用：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">g</span> <span class="operator">/:</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="built_in">Sin</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><p>这样规则就只定义在<code>g</code>上。</p><p>但是需要注意的是，这种规则指派只能改动一层，如果再深一层就不被允许了。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">g</span><span class="operator">/:</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">h</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">:=</span> <span class="variable">x</span><span class="operator">+</span><span class="number">1</span><span class="operator">;</span><span class="comment">(*出错*)</span></span><br></pre></td></tr></table></figure><h2 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h2><h3 id="函数与泛函编程"><a href="#函数与泛函编程" class="headerlink" title="函数与泛函编程"></a>函数与泛函编程</h3><p>前缀、中缀和后缀：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span><span class="operator">@</span><span class="variable">x</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">x</span><span class="operator">~</span><span class="variable">f</span><span class="operator">~</span><span class="variable">y</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span><span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span><span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span><span class="operator">@</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span><span class="operator">@</span><span class="variable">g</span><span class="operator">@</span><span class="variable">x</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="variable">x</span> <span class="operator">//</span> <span class="variable">g</span> <span class="operator">//</span> <span class="variable">f</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h4 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h4><p><code>Orderless</code>：交换性</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetAttributes</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="built_in">Orderless</span><span class="punctuation">]</span><span class="operator">;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span> <span class="operator">==</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">True</span></span><br></pre></td></tr></table></figure><p><code>Flat</code>：结合性</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetAttributes</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="built_in">Flat</span><span class="punctuation">]</span><span class="operator">;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span> <span class="operator">==</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">True</span></span><br></pre></td></tr></table></figure><p><code>OneIdentity</code></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetAttributes</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="built_in">OneIdentity</span><span class="punctuation">]</span><span class="operator">;</span> <span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="operator">:</span> <span class="number">0</span><span class="operator">,</span> <span class="type">y_</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">True</span></span><br></pre></td></tr></table></figure><p><code>Listable</code></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetAttributes</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="built_in">Listable</span><span class="punctuation">]</span><span class="operator">;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>自定义筛选函数</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">S</span> <span class="operator">=</span> <span class="built_in">Normal</span><span class="operator">@</span><span class="built_in">Series</span><span class="punctuation">[</span><span class="built_in">Cos</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">/</span><span class="punctuation">(</span><span class="variable">x</span><span class="operator">^</span><span class="number">4</span> <span class="built_in">Tan</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span><span class="operator">/</span><span class="variable">x</span><span class="operator">^</span><span class="number">5</span> <span class="operator">-</span> <span class="number">5</span><span class="operator">/</span><span class="punctuation">(</span><span class="number">6</span> <span class="variable">x</span><span class="operator">^</span><span class="number">3</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="number">67</span><span class="operator">/</span><span class="punctuation">(</span><span class="number">360</span> <span class="variable">x</span><span class="punctuation">)</span> <span class="operator">-</span> <span class="punctuation">(</span><span class="number">19</span> <span class="variable">x</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">3024</span> <span class="operator">+</span> <span class="punctuation">(</span><span class="number">247</span> <span class="variable">x</span><span class="operator">^</span><span class="number">3</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">604800</span> <span class="operator">+</span> <span class="punctuation">(</span></span><br><span class="line"> <span class="number">89</span> <span class="variable">x</span><span class="operator">^</span><span class="number">5</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">4790016</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Plus</span> <span class="operator">@@</span> <span class="built_in">Cases</span><span class="punctuation">[</span><span class="variable">S</span><span class="operator">,</span> <span class="type">a_</span><span class="operator">.</span> <span class="variable">x</span><span class="operator">^</span><span class="type">d_</span> <span class="operator">/;</span> <span class="variable">d</span> <span class="operator">&lt;</span> <span class="number">0</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Select</span><span class="punctuation">[</span><span class="variable">S</span><span class="operator">,</span> <span class="punctuation">(</span><span class="type">#</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="type">a_</span><span class="operator">.</span> <span class="variable">x</span><span class="operator">^</span><span class="type">d_</span> <span class="operator">:&gt;</span> <span class="variable">d</span><span class="punctuation">&#125;</span><span class="punctuation">)</span> <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Select</span><span class="punctuation">[</span><span class="variable">S</span><span class="operator">,</span> <span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="type">#</span><span class="operator">,</span> <span class="type">a_</span><span class="operator">.</span> <span class="variable">x</span><span class="operator">^</span><span class="type">d_</span> <span class="operator">/;</span> <span class="variable">d</span> <span class="operator">&lt;</span> <span class="number">0</span><span class="punctuation">]</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h4 id="带下标的函数"><a href="#带下标的函数" class="headerlink" title="带下标的函数"></a>带下标的函数</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">p</span> <span class="operator">=</span> <span class="built_in">Plus</span> <span class="operator">@@</span> <span class="punctuation">(</span><span class="punctuation">(</span><span class="variable">g</span> <span class="operator">@@</span> <span class="type">#</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="built_in">Times</span> <span class="operator">@@</span> <span class="variable">u</span> <span class="operator">/@</span> <span class="type">#</span> <span class="operator">&amp;</span> <span class="operator">/@</span> <span class="variable">Partitions</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line"> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">3</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">5</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="函数的函数"><a href="#函数的函数" class="headerlink" title="函数的函数"></a>函数的函数</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span> <span class="operator">=</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">+</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">y$</span><span class="operator">,</span> <span class="number">2</span> <span class="operator">+</span> <span class="variable">y$</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这里<code>y$</code>表示一个临时变量。</p><h4 id="泛函操作"><a href="#泛函操作" class="headerlink" title="泛函操作"></a>泛函操作</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span> <span class="operator">/@</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>关于MapIndexed，不止可以得到映射后的值，还会得到索引。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MapIndexed</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">3</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">(*还可以指定深度*)</span></span><br><span class="line"><span class="built_in">MapIndexed</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">e</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line">   <span class="variable">f</span><span class="punctuation">[</span><span class="number">3</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">e</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">e</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">L</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">d</span><span class="punctuation">&#125;</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">MapIndexed</span><span class="punctuation">[</span></span><br><span class="line"> <span class="built_in">Print</span><span class="punctuation">[</span><span class="string">&quot;The position of &quot;</span><span class="operator">,</span> <span class="type">#1</span><span class="operator">,</span> <span class="string">&quot; in the List &quot;</span><span class="operator">,</span> <span class="string">&quot; is &quot;</span><span class="operator">,</span> <span class="type">#2</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line">   <span class="string">&quot;.&quot;</span><span class="punctuation">]</span> <span class="operator">&amp;,</span> <span class="variable">L</span></span><br><span class="line"> <span class="punctuation">]</span></span><br><span class="line"> <span class="operator">&gt;</span> <span class="variable">The</span> <span class="variable">position</span> <span class="variable">of</span> <span class="variable">a</span> <span class="variable">in</span> <span class="variable">the</span> <span class="built_in">List</span>  <span class="variable">is</span> <span class="number">1.</span></span><br><span class="line"> <span class="operator">&gt;</span> <span class="variable">The</span> <span class="variable">position</span> <span class="variable">of</span> <span class="variable">b</span> <span class="variable">in</span> <span class="variable">the</span> <span class="built_in">List</span>  <span class="variable">is</span> <span class="number">2.</span></span><br><span class="line"> <span class="operator">&gt;</span> <span class="variable">The</span> <span class="variable">position</span> <span class="variable">of</span> <span class="variable">c</span> <span class="variable">in</span> <span class="variable">the</span> <span class="built_in">List</span>  <span class="variable">is</span> <span class="number">3.</span></span><br><span class="line"> <span class="operator">&gt;</span> <span class="variable">The</span> <span class="variable">position</span> <span class="variable">of</span> <span class="variable">d</span> <span class="variable">in</span> <span class="variable">the</span> <span class="built_in">List</span>  <span class="variable">is</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure><p>其中<code>#1</code>表示函数的第一个参数，<code>#2</code>表示第二个参数。</p><p><code>MapThread</code>函数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MapThread</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">p</span><span class="operator">,</span> <span class="variable">q</span><span class="operator">,</span> <span class="variable">r</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">(*注意每一个列表必须同样大小*)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">p</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="operator">,</span> <span class="variable">q</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="operator">,</span> <span class="variable">r</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们也可以用已有的函数实现：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span> <span class="operator">@@@</span> <span class="built_in">Transpose</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">p</span><span class="operator">,</span> <span class="variable">q</span><span class="operator">,</span> <span class="variable">r</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">u</span><span class="operator">,</span> <span class="variable">v</span><span class="operator">,</span> <span class="variable">w</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">p</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="operator">,</span> <span class="variable">q</span><span class="operator">,</span> <span class="variable">v</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="operator">,</span> <span class="variable">r</span><span class="operator">,</span> <span class="variable">w</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>Scan函数也有类似于Map函数的用法，但是存在一点不同：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Scan</span><span class="punctuation">[</span><span class="built_in">Print</span><span class="punctuation">[</span><span class="string">&quot;Hey! I&#x27;m &quot;</span><span class="operator">,</span> <span class="type">#</span><span class="punctuation">]</span> <span class="operator">&amp;,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">a</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">c</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span><span class="punctuation">[</span><span class="built_in">Print</span><span class="punctuation">[</span><span class="string">&quot;Hey! I&#x27;m &quot;</span><span class="operator">,</span> <span class="type">#</span><span class="punctuation">]</span> <span class="operator">&amp;,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">a</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">c</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="built_in">Null</span><span class="operator">,</span> <span class="built_in">Null</span><span class="operator">,</span> <span class="built_in">Null</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>Scan不关心中间的返回值。<br>Through函数：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Through</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="variable">f</span> <span class="operator">+</span> <span class="variable">g</span> <span class="operator">+</span> <span class="variable">h</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Through</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">]</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">h</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p><h4 id="函数迭代"><a href="#函数迭代" class="headerlink" title="函数迭代"></a>函数迭代</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Nest</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">NestList</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="函数不动点"><a href="#函数不动点" class="headerlink" title="函数不动点"></a>函数不动点</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">N</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="variable">x</span> <span class="operator">+</span> <span class="number">2</span><span class="operator">/</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">2</span><span class="operator">,</span> <span class="number">20</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FixedPoint</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1.4142135623730950488</span></span><br><span class="line"><span class="built_in">FixedPointList</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">1.5000000000000000000</span><span class="operator">,</span> <span class="number">1.4166666666666666667</span><span class="operator">,</span> \</span><br><span class="line"><span class="number">1.4142156862745098039</span><span class="operator">,</span> <span class="number">1.4142135623746899106</span><span class="operator">,</span> <span class="number">1.4142135623730950488</span><span class="operator">,</span> \</span><br><span class="line"><span class="number">1.4142135623730950488</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="条件迭代"><a href="#条件迭代" class="headerlink" title="条件迭代"></a>条件迭代</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NestWhile</span><span class="punctuation">[</span><span class="type">#</span><span class="operator">^</span><span class="number">2</span> <span class="operator">&amp;,</span> <span class="number">2</span><span class="operator">,</span> <span class="punctuation">(</span><span class="type">#</span> <span class="operator">&lt;</span> <span class="number">10</span><span class="operator">^</span><span class="number">10</span><span class="punctuation">)</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">NestWhileList</span><span class="punctuation">[</span><span class="type">#</span><span class="operator">^</span><span class="number">2</span> <span class="operator">&amp;,</span> <span class="number">2</span><span class="operator">,</span> <span class="punctuation">(</span><span class="type">#</span> <span class="operator">&lt;</span> <span class="number">10</span><span class="operator">^</span><span class="number">10</span><span class="punctuation">)</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">18446744073709551616</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">2</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> <span class="number">256</span><span class="operator">,</span> <span class="number">65536</span><span class="operator">,</span> <span class="number">4294967296</span><span class="operator">,</span> <span class="number">18446744073709551616</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>条件迭代也可以用于求解不动点<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">N</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="variable">x</span> <span class="operator">+</span> <span class="number">3</span><span class="operator">/</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">2</span><span class="operator">,</span> <span class="number">20</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">NestWhile</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="built_in">Unequal</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1.7320508075688772935</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NestWhileList</span><span class="punctuation">[</span><span class="built_in">Mod</span><span class="punctuation">[</span><span class="number">3</span> <span class="type">#</span><span class="operator">,</span> <span class="number">57</span><span class="punctuation">]</span> <span class="operator">&amp;,</span> <span class="number">1</span><span class="operator">,</span> <span class="built_in">Unequal</span><span class="operator">,</span> <span class="built_in">All</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">9</span><span class="operator">,</span> <span class="number">27</span><span class="operator">,</span> <span class="number">24</span><span class="operator">,</span> <span class="number">15</span><span class="operator">,</span> <span class="number">45</span><span class="operator">,</span> <span class="number">21</span><span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> <span class="number">18</span><span class="operator">,</span> <span class="number">54</span><span class="operator">,</span> <span class="number">48</span><span class="operator">,</span> <span class="number">30</span><span class="operator">,</span> <span class="number">33</span><span class="operator">,</span> <span class="number">42</span><span class="operator">,</span> <span class="number">12</span><span class="operator">,</span> <span class="number">36</span><span class="operator">,</span> <span class="number">51</span><span class="operator">,</span> \</span><br><span class="line"><span class="number">39</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="折叠运算"><a href="#折叠运算" class="headerlink" title="折叠运算"></a>折叠运算</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Fold</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FoldList</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">x</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第六周"><a href="#第六周" class="headerlink" title="第六周"></a>第六周</h2><h3 id="模块化、语境和包"><a href="#模块化、语境和包" class="headerlink" title="模块化、语境和包"></a>模块化、语境和包</h3><p>在Mathematica中，变量默认为全局变量。这是因为大多数Mathematica程序都比较短小，因此只要靠用户自己维护就可以避免全局变量重名带来的各种问题。但是有些时候人们也需要编制大型的Mathematica程序，这时候就需要将一些全局变量隔离、打包的机制，这就是今天要将的模块化、语境和包等概念。<br>模块化：Module<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">y</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">y</span> <span class="operator">=</span> <span class="variable">x</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span> <span class="variable">x</span><span class="operator">/</span><span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">10</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">y</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span><span class="operator">/</span><span class="number">11</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><br>Module的作用是定义一个封闭的环境。其中存在一些局部变量(由第一个参数(必须是一个表)的元素组成)。当Module表达式求值完毕之后，这个环境就不存在了，其中的局部变量自然也会消失。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">print</span> <span class="operator">:=</span> <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">y</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">print</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">y$14115</span></span><br></pre></td></tr></table></figure><br>在Module中，局部变量<code>y</code>被替换为带有内部编号的一种变量<code>y$num</code>，其中<code>num</code>是一个自然数，取自Mathematica内部的一个计数变量<script type="math/tex">ModuleNumber`。每次调用Module或者具有类似功能的结构时都会增加`$ModuleNumber`，于是`y</script>后面的数字永远不相同，所以也就不会有重名问题。<br>我们可以用<code>Unique</code>生成计数器：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="built_in">Unique</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="built_in">Unique</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="built_in">Unique</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="variable">x$14690</span></span><br><span class="line"><span class="variable">x$14691</span></span><br><span class="line"><span class="variable">x$14692</span></span><br></pre></td></tr></table></figure><br>注意，带<code>$</code>和编号的变量具有Temporary属性：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="string">&quot; has attributes &quot;</span><span class="operator">,</span> <span class="built_in">Attributes</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">x$15746</span> <span class="variable">has</span> <span class="variable">attributes</span> <span class="punctuation">&#123;</span><span class="built_in">Temporary</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>我们可以使用<code>?x*</code>来查看<code>x</code>的临时属性。<br>带有临时属性的变量在生存期结束时就会被系统<code>Remove</code>，除非它们生存期内被显式地返回给外部的全局环境。<br>我们下面考察以下另一种结构<code>with</code>来与<code>Module</code>做一下对比：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="variable">a</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">a</span></span><br></pre></td></tr></table></figure><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">4</span><span class="operator">;</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">(*打印5，警告，n不能再被赋值了*)</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">4</span><span class="operator">;</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">&#125;</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">-&gt;</span> <span class="number">5</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">4</span></span><br><span class="line"><span class="comment">(* 因为是先打印，再替换，所以打印出的是4 *)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ReleaseHold</span><span class="punctuation">[</span><span class="built_in">Hold</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">4</span><span class="operator">;</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">-&gt;</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="comment">(*首先先将(n = 4; Print[n]) hold住，使其变为一个表达式而不执行，替换完成后释放hold执行*)</span></span><br></pre></td></tr></table></figure></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">n</span></span><br></pre></td></tr></table></figure><p>With的作用是定义一个封闭的环境，其中存在一些局部变量。在With的第二个参数表达式中所有这些常量都会直接替换成第一个参数中赋值语句右边的值。在这个环境中，局部常量的值是不变的。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">a</span> <span class="operator">=</span> <span class="variable">x</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="variable">a</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">n</span> <span class="operator">=</span> <span class="variable">b</span><span class="operator">;</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">a</span></span><br><span class="line"><span class="variable">x</span></span><br><span class="line"><span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">b</span></span><br></pre></td></tr></table></figure><br>注意，在这个例子中，<code>a</code>是一个外部环境的变量，Mathematica的变量实际上都是指针。所以，在With内部，n是与a相等的指针，当我们写n=b时，实际上是在写a=b，它的作用是把a的值换成b的值，n和a始终始终是指向同一个地方，所以”n”仍是常量。<br>但是如果变成<code>n=1;n=b</code>就会警告，因为如果<code>n=1</code>，那么我们就无法将常量<code>1</code>赋值为其他的值。<br>Module和With的内部环境叫做相应的局部变量或局部变量的作用域。下面我们看几种隐式出现的作用域：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span> <span class="operator">=</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">+</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">y$</span><span class="operator">,</span> <span class="variable">y</span> <span class="operator">+</span> <span class="variable">y$</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>在这个例子中，<code>f</code>的函数体部分因为某种外部原因，这是Mathematica就会把内层的变量<code>y</code>自动命名为<code>y$</code>，这是一个临时变量，他会在函数定义结束后被销毁。另一个自动改名的例子：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">w</span> <span class="operator">=</span> <span class="variable">x</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="variable">w</span> <span class="operator">+</span> <span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">x$_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="variable">x</span> <span class="operator">+</span> <span class="variable">x$</span></span><br></pre></td></tr></table></figure><br>Function定义的是纯函数，或者叫匿名函数、$\lambda-$表达式，它们的参数是所谓的哑变量，可以随意换名字而不影响定义。Mathematica在这里做的正是这样一件事，其原因是为了避免与可能存在的全局变量重名。<br>除了Module、With、Function以外，各种赋值，规则中的模式名称(x_、x__、x:pattern)也具有自动改名的功能，这些赋值、规则语句就成为这些改名后的临时变量的作用域。注意，常量是不能自动改名的。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">x</span> <span class="operator">=</span>  <span class="number">1</span><span class="operator">;</span> <span class="variable">y</span> <span class="operator">=</span> <span class="variable">a</span><span class="operator">;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="punctuation">(</span><span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="operator">;</span> <span class="variable">g</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="punctuation">(</span><span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="operator">;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">2</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">(*第一个居于报错，因为我们想赋值1=2*)</span></span><br></pre></td></tr></table></figure><br>再看一些哑变量的例子：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">i</span> <span class="operator">=</span> <span class="number">50</span><span class="operator">;</span> <span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span><span class="operator">;</span><span class="comment">(*此例子中x必须是变量，不能是常数，否则不能做积分变量*)</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="built_in">Sum</span><span class="punctuation">[</span><span class="variable">i</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">100</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">,</span> <span class="built_in">Integrate</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">5050</span><span class="operator">,</span> <span class="number">1</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">50</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">p</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">Integrate</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="variable">x</span><span class="operator">^</span><span class="variable">n</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">p</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="comment">(*局部变量与全局变量混淆*)</span></span><br><span class="line"><span class="variable">q</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Integrate</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="variable">x</span><span class="operator">^</span><span class="variable">n</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">q</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p><p>Module和With都是通过改名的办法将作用域内的变量变为与外部变量不同的局部变量。有的时候我们需要另外一种隔离手段，我们想要构造一个作用域，其中局部变量与全局变量具有相同的”名字”和不同的”值”，这就要用Block来做隔离。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Block</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">3</span> <span class="operator">+</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">+</span> <span class="variable">a</span><span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">3</span> <span class="operator">+</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">+</span> <span class="variable">a</span><span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Block</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">3</span> <span class="operator">+</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">3</span> <span class="operator">+</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">+</span> <span class="variable">a</span><span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><br>我们可以换一种角度来解释两者的不同。在上面的例子中，Module里的局部变量只生存在Module内，它不会跟踪y的定义跑出到Module外面去；另一方面，Block里的局部变量x会跟踪出去，找出y中出现的所有x，然后替换，所以它的作用域可以从Block延伸出去，侵入到y的作用域中。上面提到的积分变量必须是变量是因为积分是用<code>Block</code>实现的。</p><p>利用这些域规则我们可以创造出很对有趣的函数。<br>闭包的例子：计数器产生器<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">CounterCreator</span><span class="punctuation">[</span><span class="type">first_</span><span class="operator">:</span> <span class="number">1</span><span class="operator">,</span> <span class="type">delta_</span><span class="operator">:</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">:=</span> </span><br><span class="line"> <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">i</span> <span class="operator">=</span> <span class="variable">first</span> <span class="operator">-</span> <span class="variable">delta</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span> <span class="operator">+=</span> <span class="variable">delta</span><span class="punctuation">&#125;</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">counter1</span> <span class="operator">=</span> <span class="variable">CounterCreator</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">counter2</span> <span class="operator">=</span> <span class="variable">CounterCreator</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">counter3</span> <span class="operator">=</span> <span class="variable">CounterCreator</span><span class="punctuation">[</span><span class="number">19</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><br>这样就创建了三个计数器，各个计数器之间互不干扰。<br>另一个闭包的例子，状态机：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">StateMachine</span> <span class="operator">=</span> </span><br><span class="line">  <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">i</span><span class="punctuation">&#125;</span><span class="operator">,</span> </span><br><span class="line">   <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">func</span><span class="operator">,</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> </span><br><span class="line">    <span class="built_in">Switch</span><span class="punctuation">[</span><span class="variable">func</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="variable">i</span> <span class="operator">&amp;,</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">++</span><span class="variable">i</span> <span class="operator">&amp;,</span> <span class="number">2</span><span class="operator">,</span> <span class="operator">--</span><span class="variable">i</span> <span class="operator">&amp;,</span> <span class="number">3</span><span class="operator">,</span> <span class="punctuation">(</span><span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span> <span class="operator">&amp;,</span> <span class="type">_</span><span class="operator">,</span> </span><br><span class="line">     <span class="built_in">Print</span><span class="punctuation">[</span><span class="string">&quot;Illegal function!&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">read</span> <span class="operator">=</span> <span class="variable">StateMachine</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">up</span> <span class="operator">=</span> <span class="variable">StateMachine</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">down</span> <span class="operator">=</span> <span class="variable">StateMachine</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">reset</span> <span class="operator">=</span> <span class="variable">StateMachine</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><br>这四个相互影响。<br>在各种程序语言中，还有一种显式指定作用域的方法。典型的例子就是C++语言中的命名空间(namespace)。在Mathematica中也有一种类似的机制，叫做语境(Context)。<br>Global`是Mathematica的默认语境，所有用户自己定义的符号、函数都存在于这个语境中。用户也可以自己定义语境：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">foo</span><span class="operator">`</span><span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">;</span></span><br><span class="line"><span class="comment">(*语境也可以嵌套*)</span></span><br><span class="line"><span class="variable">foo</span><span class="operator">`</span><span class="variable">bar</span><span class="operator">`</span><span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><br>语境就像是文件系统中的文件夹，语境下面的嵌套语境就像文件夹下的子文件夹。语境中的符号、函数则像文件夹中的各种文件。无论如何，我们在Mathematica中总存在于一个语境中，它可以通过变量<code>$Context</code>访问。<br>如果Mathematica遇到一个符号，他首先会在当前语境中查找这个符号的意义。如果找不到，则会在<code>$ContextPath</code>所指定语境路径按顺序查找这个符号。<br>我们可以通过赋值改变当前语境，也可以向语境路径中添加我们的语境：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$Context</span> <span class="operator">=</span> <span class="string">&quot;foo`&quot;</span></span><br><span class="line"><span class="built_in">$ContextPath</span> <span class="operator">=</span> <span class="built_in">PrependTo</span><span class="punctuation">[</span><span class="built_in">$ContextPath</span><span class="operator">,</span> <span class="string">&quot;bar&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>函数<code>Context[]</code>可以查找当前语境或者某个符号所属的语境：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Context</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Context</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>函数<code>Contexts</code>可以列出所有的语境，或者按通配符列出相应的语境：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Contexts</span><span class="punctuation">[</span><span class="string">&quot;System`**&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>语境可以通过<code>Begin[&quot;Content&quot;]</code>和<code>End[]</code>进出：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Begin</span><span class="punctuation">[</span><span class="string">&quot;新语境&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">=</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">End</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>我们后面介绍包(package)的概念、包都自带一个语境。如果导入了某个程序包，那么它的语境会自动添加为语境路径的第一个语境。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Needs</span><span class="punctuation">[</span><span class="string">&quot;Quaternions&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">$ContextPath</span></span><br></pre></td></tr></table></figure></p><h2 id="第七周"><a href="#第七周" class="headerlink" title="第七周"></a>第七周</h2><h3 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h3><p>要谈优化，首先要有测量：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="built_in">FactorInteger</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">^</span><span class="punctuation">(</span><span class="number">2</span><span class="operator">^</span><span class="number">8</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">AbsoluteTiming</span><span class="punctuation">[</span><span class="built_in">FactorInteger</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">^</span><span class="punctuation">(</span><span class="number">2</span><span class="operator">^</span><span class="number">8</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="number">0.359375</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">1238926361552897</span><span class="operator">,</span> </span><br><span class="line">   <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">93461639715357977769163558199606896584051237541638188580280321</span>\</span><br><span class="line"><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="number">0.365291</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">1238926361552897</span><span class="operator">,</span> </span><br><span class="line">   <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">93461639715357977769163558199606896584051237541638188580280321</span>\</span><br><span class="line"><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>还有空间的度量<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">pts</span> <span class="operator">=</span> <span class="built_in">RandomReal</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">10000</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">gr</span> <span class="operator">=</span> <span class="built_in">Graphics</span><span class="punctuation">[</span><span class="built_in">Point</span> <span class="operator">/@</span> <span class="variable">pts</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">grMulti</span> <span class="operator">=</span> <span class="built_in">Graphics</span><span class="punctuation">[</span><span class="built_in">Point</span><span class="punctuation">[</span><span class="variable">pts</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ByteCount</span> <span class="operator">/@</span> <span class="punctuation">&#123;</span><span class="variable">gr</span><span class="operator">,</span> <span class="variable">grMulti</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="number">1760128</span><span class="operator">,</span> <span class="number">160248</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>除此之外，还有<code>MemoryInUse</code>等。<br>我们主要关心对时间的优化，有以下几条大的原则：</p><ol><li>不要重复造轮子，尽量用Mathematica自己的函数。</li><li>不要自己写循环：要尽可能地将循环都转为表处理。</li><li>要善于用数学。</li><li>知道得越多，算得越快。</li><li>简单比复杂好</li><li>纯函数比模式匹配快<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><code>StringLength</code>获取字符串长度、<code>StringJoin</code>连接字符串。<code>&lt;&gt;</code>字符串连接。<br><code>CharacterRange[&quot;a&quot;,&quot;z&quot;]</code>：生成从”a”到”z”的ASSIC码。<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">alphabet</span> <span class="operator">=</span> <span class="built_in">StringJoin</span><span class="punctuation">[</span><span class="built_in">CharacterRange</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="operator">,</span> <span class="string">&quot;z&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringTake</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringDrop</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringPart</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringTake</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">12</span><span class="operator">,</span> <span class="number">16</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringTake</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">12</span> <span class="operator">;;</span> <span class="number">16</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>字符串模式：<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">d</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">d</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="string">&quot;abcd&quot;</span><span class="operator">,</span> <span class="type">___</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">___</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="string">&quot;abccd&quot;</span><span class="operator">,</span> <span class="type">___</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">___</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringFreeQ</span><span class="punctuation">[</span><span class="string">&quot;aabbccdd&quot;</span><span class="operator">,</span> <span class="string">&quot;bc&quot;</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="string">&quot;d&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringCases</span><span class="punctuation">[</span><span class="string">&quot;aabbccdd&quot;</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringCases</span><span class="punctuation">[</span><span class="string">&quot;aabbccdd&quot;</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">:&gt;</span> <span class="variable">x</span> <span class="operator">&lt;&gt;</span> <span class="variable">x</span> <span class="operator">&lt;&gt;</span> <span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringPosition</span><span class="punctuation">[</span><span class="string">&quot;aabbccdd&quot;</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">y_</span> <span class="operator">~~</span> <span class="type">y_</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringCount</span><span class="punctuation">[</span><span class="string">&quot;abcadcadcbqwertaac&quot;</span><span class="operator">,</span> <span class="string">&quot;a&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringCount</span><span class="punctuation">[</span><span class="string">&quot;abcadcadcbqwertaac&quot;</span><span class="operator">,</span> <span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">_</span> <span class="operator">~~</span> <span class="string">&quot;c&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringReplace</span><span class="punctuation">[</span><span class="string">&quot;abbaabbaa&quot;</span><span class="operator">,</span> <span class="string">&quot;ab&quot;</span> <span class="operator">-&gt;</span> <span class="string">&quot;X&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringReplace</span><span class="punctuation">[</span><span class="string">&quot;ababbabbaaababa&quot;</span><span class="operator">,</span> <span class="string">&quot;ab&quot;</span> <span class="operator">..</span> <span class="operator">-&gt;</span> <span class="string">&quot;X&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringReplaceList</span><span class="punctuation">[</span><span class="string">&quot;ccccc&quot;</span><span class="operator">,</span> <span class="string">&quot;c&quot;</span> <span class="operator">-&gt;</span> <span class="string">&quot;XYX&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringReplaceList</span><span class="punctuation">[</span><span class="string">&quot;abcdeabacde&quot;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="string">&quot;abc&quot;</span> <span class="operator">-&gt;</span> <span class="string">&quot;X&quot;</span><span class="operator">,</span> <span class="string">&quot;cde&quot;</span> <span class="operator">-&gt;</span> <span class="string">&quot;Y&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringReplace</span><span class="punctuation">[</span><span class="string">&quot;the cat in the hat&quot;</span><span class="operator">,</span>  </span><br><span class="line"> <span class="built_in">Except</span><span class="punctuation">[</span><span class="built_in">Characters</span><span class="punctuation">[</span><span class="string">&quot;aeiou&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="string">&quot;&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a bbb cccc aa d&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a----bbb---ccc--dddd&quot;</span><span class="operator">,</span> <span class="string">&quot;--&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a----bbb---ccc--dddd&quot;</span><span class="operator">,</span> <span class="string">&quot;-&quot;</span> <span class="operator">..</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a--.-bbb- -|-ccc--ddd&quot;</span><span class="operator">,</span> <span class="punctuation">(</span><span class="string">&quot;-&quot;</span> <span class="operator">|</span> <span class="string">&quot;.&quot;</span> <span class="operator">|</span> <span class="string">&quot;|&quot;</span> <span class="operator">|</span> <span class="string">&quot; &quot;</span><span class="punctuation">)</span> <span class="operator">..</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>字符串的完整形式：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">_</span> <span class="operator">~~</span> <span class="string">&quot;b&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">__</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">___</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">..</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">...</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Repeated</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">RepeatedNull</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>其他字符串模式：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a bbb \t cc \rcc aa \n d&quot;</span><span class="operator">,</span> <span class="built_in">Whitespace</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a384bcibeyu198e7wr&quot;</span><span class="operator">,</span> <span class="built_in">CharacterRange</span><span class="punctuation">[</span><span class="string">&quot;0&quot;</span><span class="operator">,</span> <span class="string">&quot;9&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a384bcibeyu198e7wr&quot;</span><span class="operator">,</span> <span class="built_in">LetterCharacter</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="string">&quot;abaababb&quot;</span><span class="operator">,</span> <span class="built_in">StartOfString</span> <span class="operator">~~</span> <span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">__</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="string">&quot;abaababb&quot;</span><span class="operator">,</span> <span class="type">__</span> <span class="operator">~~</span> <span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="built_in">EndOfString</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>将一般的表达式转换为字符串搜索会提速：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">test</span> <span class="operator">=</span> <span class="built_in">Range</span><span class="punctuation">[</span><span class="number">1000</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">test</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="number">50</span><span class="operator">,</span> <span class="number">75</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Position</span><span class="punctuation">[</span><span class="variable">test</span><span class="operator">,</span> <span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="variable">test</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span><span class="punctuation">]</span> <span class="operator">//</span> <span class="built_in">Timing</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">50</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">75</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">3.71875</span><span class="operator">,</span> <span class="built_in">True</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">teststr</span> <span class="operator">=</span> <span class="built_in">FromCharacterCode</span><span class="punctuation">[</span><span class="variable">test</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">StringPosition</span><span class="punctuation">[</span><span class="variable">teststr</span><span class="operator">,</span> <span class="built_in">FromCharacterCode</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="variable">teststr</span><span class="operator">,</span> </span><br><span class="line">  <span class="built_in">StringExpression</span><span class="punctuation">[</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">//</span> <span class="built_in">Timing</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">5</span><span class="operator">,</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">50</span><span class="operator">,</span> <span class="number">50</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">75</span><span class="operator">,</span> <span class="number">75</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">0.015625</span><span class="operator">,</span> <span class="built_in">True</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F13376661231%2F641&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1660719664&amp;t=7a06182fcd2599240cf9b86397be591b&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;


&lt;blockquote&gt;
&lt;p&gt; B站课程链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1av411N7Xi?spm_id_from=333.999.0.0&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;https://www.bilibili.com/video/BV1av411N7Xi?spm_id_from=333.999.0.0&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://www.hfcouc.work/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Mathematica" scheme="https://www.hfcouc.work/tags/Mathematica/"/>
    
  </entry>
  
  <entry>
    <title>Statistical Rethinking:Chapter5</title>
    <link href="https://www.hfcouc.work/2022/07/16/rt5/"/>
    <id>https://www.hfcouc.work/2022/07/16/rt5/</id>
    <published>2022-07-16T09:34:46.000Z</published>
    <updated>2022-07-16T09:40:29.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Multivariate-Linear-Models"><a href="#Multivariate-Linear-Models" class="headerlink" title="Multivariate Linear Models"></a>Multivariate Linear Models</h2><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/MLN1.png" alt=""></p><span id="more"></span><p>美国平均每人多少华夫饼店与离婚率存在着相关关系，一般某个州平均每人每个华夫饼店的数量越多，离婚率越高，但是两者之间并没有明显的因果关系，主要是南部的州含有较多的华夫饼店并且不允许未婚同居。所以相关性在自然界非常常见，但是相关并不意味着因果关系，我们需要工具来区分单纯的关联和因果关系。这就是为什么如此多的统计工作致力于多元回归，使用多个预测变量来模拟输出变量。</p><h3 id="Spurious-association"><a href="#Spurious-association" class="headerlink" title="Spurious association"></a>Spurious association</h3><p>假设我们用结婚率和结婚时的年龄两个变量来预测离婚率，我们的模型为：</p><script type="math/tex; mode=display">\begin{aligned}D_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta_{R} R_{i}+\beta_{A} A_{i} \\\alpha & \sim \operatorname{Normal}(10,10) \\\beta_{R} & \sim \operatorname{Normal}(0,1) \\\beta_{A} & \sim \operatorname{Normal}(0,1) \\\sigma & \sim \operatorname{Uniform}(0,10)\end{aligned}</script><p>下面我们拟合模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归一化数据</span></span><br><span class="line">d$MedianAgeMarriage.s &lt;- (d$MedianAgeMarriage-mean(d$MedianAgeMarriage))/</span><br><span class="line">  sd(d$MedianAgeMarriage)</span><br><span class="line"></span><br><span class="line">d$Marriage.s &lt;- (d$Marriage - mean(d$Marriage))/sd(d$Marriage)</span><br><span class="line"></span><br><span class="line">m5.3 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    Divorce ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + bR*Marriage.s + bA*MedianAgeMarriage.s,</span><br><span class="line">    a ~ dnorm(<span class="number">10</span>, <span class="number">10</span>),</span><br><span class="line">    bR ~ dnorm(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    bA ~ dnorm(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  ),</span><br><span class="line">  data = d</span><br><span class="line">)</span><br><span class="line">precis(m5.3)</span><br><span class="line"></span><br><span class="line">       mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a      <span class="number">9.69</span> <span class="number">0.20</span>  <span class="number">9.36</span> <span class="number">10.01</span></span><br><span class="line">bR    -<span class="number">0.13</span> <span class="number">0.28</span> -<span class="number">0.58</span>  <span class="number">0.31</span></span><br><span class="line">bA    -<span class="number">1.13</span> <span class="number">0.28</span> -<span class="number">1.58</span> -<span class="number">0.69</span></span><br><span class="line">sigma  <span class="number">1.44</span> <span class="number">0.14</span>  <span class="number">1.21</span>  <span class="number">1.67</span></span><br></pre></td></tr></table></figure><p>可以看到bR非常接近于零，而bA的值离零很远。我们可以说，一旦我们知道了一个州的结婚年龄的中位数，就几乎没有或没有额外的预测能力来了解该州的结婚率。</p><p>我们也可以绘制多元后验，包括：</p><ul><li>Predictor residual plots：这些图展示输出值与预测残差值的关系</li><li>Counterfactual plots</li><li>Posterior prediction plots</li></ul><p>下面先看Predictor residual plots：<br>在我们关于离婚率的多变量模型中，我们有两个预测变量(结婚率和结婚年龄的中位数)。为了计算每一个的预测残差，我们需要利用另一个预测变量对其进行建模，因此对于结婚率，下列模型是我们需要的：</p><script type="math/tex; mode=display">\begin{aligned}R_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta A_{i} \\\alpha & \sim \operatorname{Normal}(0,10) \\\beta & \sim \operatorname{Normal}(0,1) \\\sigma & \sim \operatorname{Uniform}(0,10)\end{aligned}</script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m5.4 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    Marriage.s ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + b*MedianAgeMarriage.s,</span><br><span class="line">    a ~ dnorm(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">    b ~ dnorm(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  ),</span><br><span class="line">  data = d</span><br><span class="line">)</span><br><span class="line">mu &lt;- coef(m5.4)[<span class="string">&#x27;a&#x27;</span>] + coef(m5.4)[<span class="string">&#x27;b&#x27;</span>]*d$MedianAgeMarriage.s</span><br><span class="line">m.resid &lt;- d$Marriage.s - mu</span><br></pre></td></tr></table></figure><p>得到残差，我们可以以它为横坐标，以离婚率为纵坐标绘制如下图所示的图：<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/MLN2.jpg" alt=""></p><blockquote><p>左边的图，垂直的虚线表示结婚率等于预测值(残差为零)，左边的区域表示结婚率低于期望值，而右边的区域表示结婚率高于期望值。左右两边的离婚率大小大致相等，所以说明结婚率和离婚率的关系较小。也可以将残差理解为结婚率在去除结婚年龄的中位数的影响后得到的东西。<br>右边的图类似。</p></blockquote><p>Counterfactual plots：固定一个变量不变，其他变量对于输出变量的影响。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A.avg &lt;- mean(d$MedianAgeMarriage.s)</span><br><span class="line">R.seq &lt;- seq(from=-<span class="number">3</span>, to=<span class="number">3</span>, length.out=<span class="number">30</span>)</span><br><span class="line">pred.data &lt;- data.frame(</span><br><span class="line">  Marriage.s = R.seq,</span><br><span class="line">  MedianAgeMarriage.s=A.avg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">mu &lt;- link(m5.3, data = pred.data)</span><br><span class="line">mu.mean &lt;- apply(mu, <span class="number">2</span>, mean)</span><br><span class="line">mu.PI &lt;- apply(mu, <span class="number">2</span>, PI)</span><br><span class="line"></span><br><span class="line">R.sim &lt;- sim(m5.3, data = pred.data, n=<span class="number">1e4</span>)</span><br><span class="line">R.PI &lt;- apply(R.sim, <span class="number">2</span>, PI)</span><br><span class="line"></span><br><span class="line">plot(Divorce ~ Marriage.s, data=d, type=<span class="string">&quot;n&quot;</span>)</span><br><span class="line">mtext(<span class="string">&quot;MedianAgeMarriage.s=0&quot;</span>)</span><br><span class="line">lines(R.seq, mu.mean)</span><br><span class="line">shade(mu.PI, R.seq)</span><br><span class="line">shade(R.PI, R.seq)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们也可以绘制另一个变量的结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R.avg &lt;- mean( d$Marriage.s )</span><br><span class="line">A.seq &lt;- seq( from=-<span class="number">3</span> , to=<span class="number">3.5</span> , length.out=<span class="number">30</span> )</span><br><span class="line">pred.data2 &lt;- data.frame(</span><br><span class="line">Marriage.s=R.avg, </span><br><span class="line">MedianAgeMarriage.s=A.seq</span><br><span class="line">)</span><br><span class="line">mu &lt;- link( m5.3 , data=pred.data2 )</span><br><span class="line">mu.mean &lt;- apply( mu , <span class="number">2</span> , mean )</span><br><span class="line">mu.PI &lt;- apply( mu , <span class="number">2</span> , PI )</span><br><span class="line">A.sim &lt;- sim( m5.3 , data=pred.data2 , n=<span class="number">1e4</span> )</span><br><span class="line">A.PI &lt;- apply( A.sim , <span class="number">2</span> , PI )</span><br><span class="line">plot( Divorce ~ MedianAgeMarriage.s , data=d , type=<span class="string">&quot;n&quot;</span> ) </span><br><span class="line">mtext( <span class="string">&quot;Marriage.s = 0&quot;</span> )</span><br><span class="line">lines( A.seq , mu.mean ) </span><br><span class="line">shade( mu.PI , A.seq ) </span><br><span class="line">shade( A.PI , A.seq )</span><br></pre></td></tr></table></figure><p>结果为<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/MLN3.jpg" alt=""></p><blockquote><p>由此可以看出结婚率与离婚率几乎没有什么关系。</p></blockquote><p>Posterior prediction plots：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mu &lt;- link(m5.3)</span><br><span class="line">mu.mean &lt;- apply(mu, <span class="number">2</span>, mean)</span><br><span class="line">mu.PI &lt;- apply(mu, <span class="number">2</span>, PI)</span><br><span class="line"></span><br><span class="line">divorce.sim &lt;- sim(m5.3, n=<span class="number">1e4</span>)</span><br><span class="line">divorce.PI &lt;- apply(divorce.sim, <span class="number">2</span>, PI)</span><br><span class="line"></span><br><span class="line">plot(mu.mean~d$Divorce, col=rangi2, ylim=<span class="built_in">range</span>(mu.PI), xlab=<span class="string">&quot;Observed divorce&quot;</span>, ylab=<span class="string">&quot;Predicted divorce&quot;</span>)</span><br><span class="line">abline(a=<span class="number">0</span>, b=<span class="number">1</span>, lty=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:nrow(d)) &#123;</span><br><span class="line">  lines(<span class="built_in">rep</span>(d$Divorce[i],<span class="number">2</span>), <span class="built_in">c</span>(mu.PI[<span class="number">1</span>,i], mu.PI[<span class="number">2</span>,i]),col=rangi2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用另一种方法绘制：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">divorce.resid &lt;- d$Divorce - mu.mean</span><br><span class="line">o &lt;- order(divorce.resid)</span><br><span class="line">dotchart(divorce.resid[o], labels = d$Loc[o], xlim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">5</span>),cex=<span class="number">0.6</span>)</span><br><span class="line">abline(v=<span class="number">0</span>, col=col.alpha(<span class="string">&quot;black&quot;</span>,<span class="number">0.2</span>))</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:nrow(d)) &#123;</span><br><span class="line">  j &lt;- o[i]</span><br><span class="line">  lines(d$Divorce[j]-<span class="built_in">c</span>(mu.PI[<span class="number">1</span>,j], mu.PI[<span class="number">2</span>,j]), <span class="built_in">rep</span>(i,<span class="number">2</span>))</span><br><span class="line">  points(d$Divorce[j]-<span class="built_in">c</span>(divorce.PI[<span class="number">1</span>,j], divorce.PI[<span class="number">2</span>,j]), <span class="built_in">rep</span>(i,<span class="number">2</span>),</span><br><span class="line">         pch=<span class="number">3</span>, cex=<span class="number">0.6</span>, col=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Masked-relationship"><a href="#Masked-relationship" class="headerlink" title="Masked relationship"></a>Masked relationship</h3><p>下面我们将使用一个新的数据集：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">d &lt;- milk</span><br></pre></td></tr></table></figure><p>我们考虑数据集中的如下三个变量：</p><ul><li><code>kcal.per.g</code>：每克牛奶的卡路里热量</li><li><code>mass</code>：雌性平均体重，单位千克</li><li><code>neocortex.perc</code>：新皮质质量占大脑总质量的百分比<br>这里的问题是牛奶的能量含量（这里用千卡来衡量）与大脑新皮层的百分比有关。我们最终也需要雌性体重，以查看隐藏变量之间关系的掩蔽。<br>我们首先需要删除含有缺失值的行：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcc &lt;- d[complete.cases(d),]</span><br></pre></td></tr></table></figure><p>下面我们构建模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m5.5 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + bn*neocortex.perc,</span><br><span class="line">    a ~ dnorm(<span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">    bn ~ dnorm(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">  ),</span><br><span class="line">  data = dcc</span><br><span class="line">)</span><br><span class="line">precis(m5.5)</span><br><span class="line"></span><br><span class="line">&gt; precis(m5.5, digits = <span class="number">3</span>)</span><br><span class="line">       mean    sd   <span class="number">5.5</span>% 94.5%</span><br><span class="line">a     <span class="number">0.353</span> <span class="number">0.471</span> -<span class="number">0.399</span> <span class="number">1.106</span></span><br><span class="line">bn    <span class="number">0.005</span> <span class="number">0.007</span> -<span class="number">0.007</span> <span class="number">0.016</span></span><br><span class="line">sigma <span class="number">0.166</span> <span class="number">0.028</span>  <span class="number">0.120</span> <span class="number">0.211</span></span><br></pre></td></tr></table></figure><p>可以用<code>neocortex.perc</code>来拟合模型得到的结果并不好，系数接近于0。下面我们用变量<code>mass</code>的对数试一下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dcc$log.mass &lt;- <span class="built_in">log</span>(dcc$mass)</span><br><span class="line">m5.6 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm( mu , sigma ) ,</span><br><span class="line">    mu &lt;- a + bm*log.mass ,</span><br><span class="line">    a ~ dnorm ( <span class="number">0</span> , <span class="number">100</span> ) ,</span><br><span class="line">    bm ~ dnorm ( <span class="number">0</span> , <span class="number">1</span> ) ,</span><br><span class="line">    sigma ~ dunif( <span class="number">0</span> , <span class="number">1</span> )</span><br><span class="line">  ) ,</span><br><span class="line">  data=dcc )</span><br><span class="line">precis(m5.6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a      <span class="number">0.71</span> <span class="number">0.05</span>  <span class="number">0.63</span>  <span class="number">0.78</span></span><br><span class="line">bm    -<span class="number">0.03</span> <span class="number">0.02</span> -<span class="number">0.06</span>  <span class="number">0.00</span></span><br><span class="line">sigma  <span class="number">0.16</span> <span class="number">0.03</span>  <span class="number">0.11</span>  <span class="number">0.20</span></span><br></pre></td></tr></table></figure><p>可以看到结果也不是很好，那么我们试试将两个变量同时加入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">m5.7 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm( mu , sigma ) ,</span><br><span class="line">    mu &lt;- a + bn*neocortex.perc + bm*log.mass ,</span><br><span class="line">    a ~ dnorm ( <span class="number">0</span> , <span class="number">100</span> ) ,</span><br><span class="line">    bn ~ dnorm ( <span class="number">0</span> , <span class="number">1</span> ) ,</span><br><span class="line">    bm ~ dnorm ( <span class="number">0</span> , <span class="number">1</span> ) ,</span><br><span class="line">    sigma ~ dunif( <span class="number">0</span> , <span class="number">1</span> )</span><br><span class="line">  ) ,</span><br><span class="line">  data=dcc)</span><br><span class="line">precis(m5.7)</span><br><span class="line"></span><br><span class="line">&gt; precis(m5.7)</span><br><span class="line">       mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a     -<span class="number">1.08</span> <span class="number">0.47</span> -<span class="number">1.83</span> -<span class="number">0.34</span></span><br><span class="line">bn     <span class="number">0.03</span> <span class="number">0.01</span>  <span class="number">0.02</span>  <span class="number">0.04</span></span><br><span class="line">bm    -<span class="number">0.10</span> <span class="number">0.02</span> -<span class="number">0.13</span> -<span class="number">0.06</span></span><br><span class="line">sigma  <span class="number">0.11</span> <span class="number">0.02</span>  <span class="number">0.08</span>  <span class="number">0.15</span></span><br></pre></td></tr></table></figure><p>可以看到当两个变量结合后其与预测变量的相关性都得到了提升。<br>下面我们绘制在<code>log(mass)</code>固定的情况下其余两个变量之间的关系：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mean.log.mass &lt;- mean( <span class="built_in">log</span>(dcc$mass) ) </span><br><span class="line">np.seq &lt;- 0:<span class="number">100</span></span><br><span class="line">pred.data &lt;- data.frame(</span><br><span class="line">  neocortex.perc=np.seq, </span><br><span class="line">  log.mass=mean.log.mass</span><br><span class="line">)</span><br><span class="line">mu &lt;- link( m5.7 , data=pred.data , n=<span class="number">1e4</span> )</span><br><span class="line">mu.mean &lt;- apply( mu , <span class="number">2</span> , mean )</span><br><span class="line">mu.PI &lt;- apply( mu , <span class="number">2</span> , PI )</span><br><span class="line">plot( kcal.per.g ~ neocortex.perc , data=dcc , type=<span class="string">&quot;n&quot;</span> ) </span><br><span class="line">lines( np.seq , mu.mean )</span><br><span class="line">lines( np.seq , mu.PI[<span class="number">1</span>,] , lty=<span class="number">2</span> ) </span><br><span class="line">lines( np.seq , mu.PI[<span class="number">2</span>,] , lty=<span class="number">2</span> )</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/MLN4.jpeg" alt=""><br>可以看到<code>neocortex.perc</code>与<code>kcal.per.g</code>的相关性得到了增强。为什么将新皮质和体重添加到同一模型中会导致两者的估计效应更大？在这种情况下，有两个变量与结果相关，但一个与结果正相关，另一个与结果负相关。此外，两个解释变量彼此呈正相关。结果，它们倾向于相互抵消。<br>也就是说当两个变量单独与结果的关系较弱，但是两个变量之间存在着正相关，可以相互促进对结果的影响。</p><h3 id="When-adding-variables-hurts"><a href="#When-adding-variables-hurts" class="headerlink" title="When adding variables hurts"></a>When adding variables hurts</h3><p>为什么在上面的例子中不使用所有的变量呢？这是因为使用所有的变量会存在以下问题：</p><ol><li>多重共线性</li><li>post-treatment bias</li><li>过拟合<br>多重共线性会导致与结果没有多少关联性的变量也会得到很大的关联性。<br>下面我们看一个例子，我们知道人的身高与其腿长存在关系，我们按照下述方式生成体长和腿长的数据：</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N &lt;- 100 <span class="comment"># number of individuals</span></span><br><span class="line">height &lt;- rnorm(N,<span class="number">10</span>,<span class="number">2</span>) <span class="comment"># sim total height of each</span></span><br><span class="line">leg_prop &lt;- runif(N,<span class="number">0.4</span>,<span class="number">0.5</span>) <span class="comment"># leg as proportion of height</span></span><br><span class="line">leg_left &lt;- leg_prop*height + <span class="comment"># sim left leg as proportion + error</span></span><br><span class="line">  rnorm( N , <span class="number">0</span> , <span class="number">0.02</span> )</span><br><span class="line">leg_right &lt;- leg_prop*height + <span class="comment"># sim right leg as proportion + error</span></span><br><span class="line">  rnorm( N , <span class="number">0</span> , <span class="number">0.02</span> )</span><br><span class="line"><span class="comment"># combine into data frame</span></span><br><span class="line">d &lt;- data.frame(height,leg_left,leg_right)</span><br></pre></td></tr></table></figure><p>在拟合模型之前我们预测体长与腿长的系数应该大约为体长的均值除以腿长比例的均值$10/4.5=2.2$，但是结果却为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m5.8 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    height ~ dnorm( mu , sigma ) ,</span><br><span class="line">    mu &lt;- a + bl*leg_left + br*leg_right ,</span><br><span class="line">    a ~ dnorm( <span class="number">10</span> , <span class="number">100</span> ) ,</span><br><span class="line">    bl ~ dnorm( <span class="number">2</span> , <span class="number">10</span> ) ,</span><br><span class="line">    br ~ dnorm( <span class="number">2</span> , <span class="number">10</span> ) ,</span><br><span class="line">    sigma ~ dunif( <span class="number">0</span> , <span class="number">10</span> )</span><br><span class="line">  ) , </span><br><span class="line">  data=d )</span><br><span class="line">precis(m5.8)</span><br><span class="line"></span><br><span class="line">      mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a     <span class="number">1.16</span> <span class="number">0.32</span>  <span class="number">0.64</span>  <span class="number">1.67</span></span><br><span class="line">bl    <span class="number">0.02</span> <span class="number">2.23</span> -<span class="number">3.55</span>  <span class="number">3.58</span></span><br><span class="line">br    <span class="number">1.96</span> <span class="number">2.21</span> -<span class="number">1.58</span>  <span class="number">5.50</span></span><br><span class="line">sigma <span class="number">0.61</span> <span class="number">0.04</span>  <span class="number">0.54</span>  <span class="number">0.68</span></span><br></pre></td></tr></table></figure><p>与我们的预测相差很大。<br>这是因为左右腿的长度具有明显的共线性，我们可以将其看作同一个变量，即：</p><script type="math/tex; mode=display">\begin{aligned}&y_{i} \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\&\mu_{i}=\alpha+\left(\beta_{1}+\beta_{2}\right) x_{i}\end{aligned}</script><p>这样的话，我们估计出来的$\beta_1+\beta_2$应该是准确的，而$\beta_1,\beta_2$之中的一个大会导致另一个小。</p><p>Post-treatment bias：因为包含其他预测变量而对后验估计产生影响。下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># number of plants</span></span><br><span class="line">N &lt;- 100</span><br><span class="line"><span class="comment"># simulate initial heights </span></span><br><span class="line">h0 &lt;- rnorm(N,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># assign treatments and simulate fungus and growth </span></span><br><span class="line">treatment &lt;- <span class="built_in">rep</span>( <span class="number">0</span>:<span class="number">1</span> , each=N/<span class="number">2</span> )</span><br><span class="line">fungus &lt;- rbinom( N , size=<span class="number">1</span> , prob=<span class="number">0.5</span> - treatment*<span class="number">0.4</span> )</span><br><span class="line">h1 &lt;- h0 + rnorm(N, <span class="number">5</span> - <span class="number">3</span>*fungus)</span><br><span class="line"><span class="comment"># compose a clean data frame</span></span><br><span class="line">d &lt;- data.frame( h0=h0 , h1=h1 , treatment=treatment , fungus=fungus )</span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">~~~R</span><br><span class="line">m5.13 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    h1 ~ dnorm(mu,sigma),</span><br><span class="line">    mu &lt;- a + bh*h0 + bt*treatment + bf*fungus,</span><br><span class="line">    a ~ dnorm(<span class="number">0</span>,<span class="number">100</span>),</span><br><span class="line">    <span class="built_in">c</span>(bh,bt,bf) ~ dnorm(<span class="number">0</span>,<span class="number">10</span>), </span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">  ),</span><br><span class="line">  data=d )</span><br><span class="line">precis(m5.13)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a      <span class="number">4.85</span> <span class="number">0.50</span>  <span class="number">4.06</span>  <span class="number">5.65</span></span><br><span class="line">bh     <span class="number">1.01</span> <span class="number">0.05</span>  <span class="number">0.93</span>  <span class="number">1.08</span></span><br><span class="line">bt     <span class="number">0.05</span> <span class="number">0.21</span> -<span class="number">0.29</span>  <span class="number">0.38</span></span><br><span class="line">bf    -<span class="number">2.57</span> <span class="number">0.22</span> -<span class="number">2.92</span> -<span class="number">2.22</span></span><br><span class="line">sigma  <span class="number">0.91</span> <span class="number">0.06</span>  <span class="number">0.80</span>  <span class="number">1.01</span></span><br></pre></td></tr></table></figure><p>我们知道我们的照料(treatment)对植物的照料很重要，但是结果显示其影响很小，这是因为真菌(fungus)是照料的结果，添加post-treatment(fungus)会掩盖treatment的结果，这是因为知道了真菌再知不知道treatment对结果已经不重要了。</p><h3 id="Categorical-variables"><a href="#Categorical-variables" class="headerlink" title="Categorical variables"></a>Categorical variables</h3><p>二分类变量例子：男女身高：</p><script type="math/tex; mode=display">\begin{aligned}h_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta_{m} m_{i} \\\alpha & \sim \operatorname{Normal}(178,100) \\\beta_{m} & \sim \operatorname{Normal}(0,10) \\\sigma & \sim \operatorname{Uniform}(0,50)\end{aligned}</script><p>$m_i=1$表示男性，$m_i=0$表示女性。<br>多分类变量：对于多分类变量，我们可以这样对其进行编码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data(milk) </span><br><span class="line">d &lt;- milk</span><br><span class="line">unique(d$clade)</span><br><span class="line">d$clade.NWM &lt;- ifelse( d$clade==<span class="string">&quot;New World Monkey&quot;</span> , <span class="number">1</span> , <span class="number">0</span> )</span><br><span class="line">d$clade.OWM &lt;- ifelse( d$clade==<span class="string">&quot;Old World Monkey&quot;</span> , <span class="number">1</span> , <span class="number">0</span> )</span><br><span class="line">d$clade.S &lt;- ifelse( d$clade==<span class="string">&quot;Strepsirrhine&quot;</span> , <span class="number">1</span> , <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>构建模型为：</p><script type="math/tex; mode=display">\begin{aligned}k_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta_{\mathrm{NWM}} \mathrm{NWM}_{i}+\beta_{\mathrm{OWM}} \mathrm{OWM}_{i}+\beta_{\mathrm{S}} \mathrm{S}_{i} \\\alpha & \sim \operatorname{Normal}(0.6,10) \\\beta_{\mathrm{NWM}} & \sim \operatorname{Normal}(0,1) \\\beta_{\mathrm{OWM}} & \sim \operatorname{Normal}(0,1) \\\beta_{\mathrm{S}} & \sim \operatorname{Normal}(0,1) \\\sigma & \sim \operatorname{Uniform}(0,10)\end{aligned}</script><p>还有另一种构建方法，即采用索引的方法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对不同类别采用不同的索引</span></span><br><span class="line">( d$clade_id &lt;- coerce_index(d$clade) )</span><br><span class="line"></span><br><span class="line">m5.16_alt &lt;- map(</span><br><span class="line">alist(</span><br><span class="line">kcal.per.g ~ dnorm( mu , sigma ) ,</span><br><span class="line">mu &lt;- a[clade_id] ,</span><br><span class="line">a[clade_id] ~ dnorm( <span class="number">0.6</span> , <span class="number">10</span> ) , </span><br><span class="line">sigma ~ dunif( <span class="number">0</span> , <span class="number">10</span> )</span><br><span class="line">) , </span><br><span class="line">data=d )</span><br><span class="line">precis( m5.16_alt , depth=<span class="number">2</span> )</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Multivariate-Linear-Models&quot;&gt;&lt;a href=&quot;#Multivariate-Linear-Models&quot; class=&quot;headerlink&quot; title=&quot;Multivariate Linear Models&quot;&gt;&lt;/a&gt;Multivariate Linear Models&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/HFC666/image/master/img/MLN1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="书籍阅读" scheme="https://www.hfcouc.work/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="概率编程" scheme="https://www.hfcouc.work/tags/%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B/"/>
    
    <category term="贝叶斯统计" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1/"/>
    
    <category term="Statistical Rethinking" scheme="https://www.hfcouc.work/tags/Statistical-Rethinking/"/>
    
  </entry>
  
  <entry>
    <title>Statistical Rethinking:Chapter4</title>
    <link href="https://www.hfcouc.work/2022/07/14/rt4/"/>
    <id>https://www.hfcouc.work/2022/07/14/rt4/</id>
    <published>2022-07-14T03:28:53.000Z</published>
    <updated>2022-07-16T09:39:33.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Linear-Models"><a href="#Linear-Models" class="headerlink" title="Linear Models"></a>Linear Models</h2><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM1.png" alt=""></p><span id="more"></span><p>托勒密的地心说在一段时间内曾经占据天文学的统治地位。托勒密用轨道内的轨道即本轮(epicycles)来描述行星复杂的活动，如下图所示。虽然这个模型现在看来是错的，但是却具有很高的预测准确度。<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM2.jpg" alt=""><br>线性回归(Linear Regression)为应用统计的地心模型。与地心说一样，线性回归可以有效地描述各种各样的自然现象。但是如果我们用线性回归描述线性内部的原理结果，我们将很容易犯错误。即虽然可能会得到很好的预测，但是其内部的机制不一定正确。</p><h3 id="Why-normal-distributions-are-normal"><a href="#Why-normal-distributions-are-normal" class="headerlink" title="Why normal distributions are normal"></a>Why normal distributions are normal</h3><h4 id="Normal-by-addition"><a href="#Normal-by-addition" class="headerlink" title="Normal by addition"></a>Normal by addition</h4><p>任何将来自同一分布的随机值相加的过程都会收敛到正态分布。这可以理解为产生此数据的源分布产生的数据为此数据的均值加上一个随机波动，随着数据数量的增多，随机波动逐渐互相抵消，均值处数据最多，得到正态分布。</p><h4 id="Normal-by-multiplication"><a href="#Normal-by-multiplication" class="headerlink" title="Normal by multiplication"></a>Normal by multiplication</h4><p>下面是另一种方法来得到高斯分布。假设每年的增长率位于$1.0\sim 1.1$，经过$12$年，总增长率为：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">prod</span>(<span class="number">1</span> + runif(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0.1</span>))</span><br></pre></td></tr></table></figure><br>那么总增长率的分布为什么？我们采$10000$个样绘制其概率分布：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">growth &lt;- replicate(<span class="number">10000</span>, <span class="built_in">prod</span>(<span class="number">1</span>+runif(<span class="number">12</span>,<span class="number">0</span>,<span class="number">0.1</span>)))</span><br><span class="line">dens(growth, norm.comp=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><br>得到的结果如下：<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM3.jpeg" alt=""><br>可以看到近似正态分布。我们之前说过正态分布可以通过将随机波动相加得到，但是我们这里是相乘，为什么也会得到正态分布呢？<br>这是因为我们每次相乘的生长率很小，可以近似于加法，如：</p><script type="math/tex; mode=display">1.1\times1.1=1.21=(1+0.1)(1+0.1)=1+0.2+0.01\approx 1.2</script><h4 id="Normal-by-log-multiplication"><a href="#Normal-by-log-multiplication" class="headerlink" title="Normal by log-multiplication"></a>Normal by log-multiplication</h4><p>相乘大的增长率不会产生高斯分布，但是它们的对数会产生高斯分布：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.big &lt;- replicate(<span class="number">10000</span>, <span class="built_in">log</span>(<span class="built_in">prod</span>(<span class="number">1</span>+runif(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0.5</span>))))</span><br><span class="line">dens(log.big, norm.comp=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM4.jpeg" alt=""></p><h4 id="Using-Gaussian-distributions"><a href="#Using-Gaussian-distributions" class="headerlink" title="Using Gaussian distributions"></a>Using Gaussian distributions</h4><p>使用高斯分布主要有两个原因：一个是因为其在自然界中分布广泛，另一个原因是[[EXP]]，根据指数分布的性质，高斯分布作为指数分布的特例，具有最大熵(包含最少信息)。</p><h3 id="A-language-for-describing-models"><a href="#A-language-for-describing-models" class="headerlink" title="A language for describing models"></a>A language for describing models</h3><p>统计模型一般采用下述方法表示：</p><script type="math/tex; mode=display">\begin{aligned}\text { outcome }_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\beta \times \operatorname{predictor}{ }_{i} \\\beta & \sim \operatorname{Normal}(0,10) \\\sigma & \sim \operatorname{HalfCauchy}(0,1)\end{aligned}</script><h3 id="A-Gaussian-model-of-height"><a href="#A-Gaussian-model-of-height" class="headerlink" title="A Gaussian model of height"></a>A Gaussian model of height</h3><h4 id="The-data"><a href="#The-data" class="headerlink" title="The data"></a>The data</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data(<span class="string">&quot;Howell1&quot;</span>)</span><br><span class="line">d &lt;- Howell1</span><br><span class="line">d2 &lt;- d[d$age &gt;= <span class="number">18</span>,]</span><br></pre></td></tr></table></figure><h4 id="The-model"><a href="#The-model" class="headerlink" title="The model"></a>The model</h4><p>假设我们的模型为：</p><script type="math/tex; mode=display">\begin{aligned}h_i &\sim \text{Normal}(\mu,\sigma)\\\mu&\sim \text{Normal}(178, 20)\\\sigma&\sim \text{Uniform}(0,50)\end{aligned}</script><h4 id="Grid-approximation-of-the-posterior-distribution"><a href="#Grid-approximation-of-the-posterior-distribution" class="headerlink" title="Grid approximation of the posterior distribution"></a>Grid approximation of the posterior distribution</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mu.list &lt;- seq(from=<span class="number">140</span>, to=<span class="number">160</span>, length.out=<span class="number">200</span>)</span><br><span class="line">sigma.list &lt;- seq(from=<span class="number">4</span>, to=<span class="number">9</span>, length.out=<span class="number">200</span>)</span><br><span class="line">post &lt;- expand.grid(mu=mu.list, sigma=sigma.list)</span><br><span class="line">post$LL &lt;- sapply(<span class="number">1</span>:nrow(post), <span class="keyword">function</span>(i) <span class="built_in">sum</span>(</span><br><span class="line">  dnorm(d2$height, mean = post$mu[i], sd=post$sigma[i], <span class="built_in">log</span>=<span class="literal">TRUE</span>)</span><br><span class="line">))</span><br><span class="line">post$prod &lt;- post$LL + dnorm(post$mu, <span class="number">178</span>, <span class="number">20</span>, <span class="literal">TRUE</span>) + dunif(post$sigma, <span class="number">0</span>, <span class="number">50</span>, <span class="literal">TRUE</span>)</span><br><span class="line">post$prob &lt;- <span class="built_in">exp</span>(post$<span class="built_in">prod</span> - <span class="built_in">max</span>(post$<span class="built_in">prod</span>))</span><br></pre></td></tr></table></figure><p>你可以对结果进行绘制：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contour_xyz(post$mu, post$sigma, post$prob)</span><br></pre></td></tr></table></figure></p><h4 id="Sampling-from-the-posterior"><a href="#Sampling-from-the-posterior" class="headerlink" title="Sampling from the posterior"></a>Sampling from the posterior</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sample.rows &lt;- sample(<span class="number">1</span>:nrow(post), size = <span class="number">1e4</span>, replace = <span class="literal">TRUE</span>, prob = post$prob)</span><br><span class="line">sample.mu &lt;- post$mu[sample.rows]</span><br><span class="line">sample.sigma &lt;- post$sigma[sample.rows]</span><br></pre></td></tr></table></figure><p>绘制结果<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(sample.mu, sample.sigma, cex=<span class="number">0.5</span>, pch=<span class="number">16</span>, col=col.alpha(rangi2,<span class="number">0.1</span>))</span><br></pre></td></tr></table></figure></p><h4 id="Fitting-the-model-with-map"><a href="#Fitting-the-model-with-map" class="headerlink" title="Fitting the model with map"></a>Fitting the model with <code>map</code></h4><p>下面我们利用二次逼近来对后验分布进行估计：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flist &lt;- alist(</span><br><span class="line">  height ~ dnorm(mu, sigma),</span><br><span class="line">  mu ~ dnorm(<span class="number">178</span>, <span class="number">20</span>),</span><br><span class="line">  sigma ~ dunif(<span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line">)</span><br><span class="line">m4.1 &lt;- map(flist, data = d2)</span><br><span class="line">precis(m4.1)</span><br><span class="line"></span><br><span class="line">        mean   sd   <span class="number">5.5</span>%  94.5%</span><br><span class="line">mu    <span class="number">154.61</span> <span class="number">0.41</span> <span class="number">153.95</span> <span class="number">155.27</span></span><br><span class="line">sigma   <span class="number">7.73</span> <span class="number">0.29</span>   <span class="number">7.27</span>   <span class="number">8.20</span></span><br></pre></td></tr></table></figure><br><code>map</code>通过像爬坡一样的方式来估计后验，它需要从一个初始位置开始。我们可以指定初始位置，一个好的初始位置位于最大后验概率(MAP)处：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start &lt;- <span class="built_in">list</span>(mu=mean(d2$height), sigma = sd(d2$height) )</span><br></pre></td></tr></table></figure><br>注意这里是<code>list</code>而不是<code>alist</code>，它们两者的区别是<code>list</code>会计算你放到其内部的代码，而<code>alist</code>不会。</p><h4 id="Sampling-from-a-map-fit"><a href="#Sampling-from-a-map-fit" class="headerlink" title="Sampling from a map fit"></a>Sampling from a <code>map</code> fit</h4><p>二次逼近不止计算了每个参数的方差，还计算了它们之间的协方差，即协方差矩阵。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vcov(m4.1)</span><br><span class="line"></span><br><span class="line">               mu       sigma</span><br><span class="line">mu    <span class="number">0.169740079</span> <span class="number">0.000217271</span></span><br><span class="line">sigma <span class="number">0.000217271</span> <span class="number">0.084906413</span></span><br></pre></td></tr></table></figure><br>我们可以用<code>extract.samples</code>函数进行抽样，其实质为对多元高斯进行抽样：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post &lt;- extract.samples(m4.1, n=<span class="number">1e4</span>)</span><br></pre></td></tr></table></figure><br>$\sigma$的分布可能不是正态分布，所以我们的二次逼近可能存在问题，但是我们可以假设$\sigma$的对数为正态分布，那么变为：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m4.1_logsigma &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    height ~ dnorm(mu, <span class="built_in">exp</span>(log_sigma)),</span><br><span class="line">    mu ~ dnorm(<span class="number">178</span>, <span class="number">20</span>),</span><br><span class="line">    log_sigma ~ dnorm(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">), data =d2)</span><br><span class="line"></span><br><span class="line">post &lt;- extract.samples(m4.1_logsigma)</span><br><span class="line">sigma &lt;- <span class="built_in">exp</span>(post$log_sigma)</span><br></pre></td></tr></table></figure></p><h3 id="Adding-a-predictor"><a href="#Adding-a-predictor" class="headerlink" title="Adding a predictor"></a>Adding a predictor</h3><h4 id="The-linear-model-strategy"><a href="#The-linear-model-strategy" class="headerlink" title="The linear model strategy"></a>The linear model strategy</h4><p>我们的模型为：</p><script type="math/tex; mode=display">\begin{aligned}h_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta x_{i} \\\alpha & \sim \operatorname{Normal}(178,100) \\\beta & \sim \operatorname{Normal}(0,10) \\\sigma & \sim \operatorname{Uniform}(0,50)\end{aligned}</script><h4 id="Fitting-the-model"><a href="#Fitting-the-model" class="headerlink" title="Fitting the model"></a>Fitting the model</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m4.3 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    height ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + b*weight,</span><br><span class="line">    a ~ dnorm(<span class="number">156</span>, <span class="number">100</span>),</span><br><span class="line">    b ~ dnorm(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>,<span class="number">50</span>)</span><br><span class="line">  ),</span><br><span class="line">  data=d2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>得到的结果如下：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">precis(m4.3)</span><br><span class="line"></span><br><span class="line">        mean   sd   <span class="number">5.5</span>%  94.5%</span><br><span class="line">a     <span class="number">113.89</span> <span class="number">1.91</span> <span class="number">110.85</span> <span class="number">116.94</span></span><br><span class="line">b       <span class="number">0.90</span> <span class="number">0.04</span>   <span class="number">0.84</span>   <span class="number">0.97</span></span><br><span class="line">sigma   <span class="number">5.07</span> <span class="number">0.19</span>   <span class="number">4.77</span>   <span class="number">5.38</span></span><br></pre></td></tr></table></figure><br>我们可以查看各个参数之间的相关系数：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                  a             b         sigma</span><br><span class="line">a      <span class="number">1.0000000000</span> -<span class="number">0.9898830268</span>  <span class="number">0.0006161621</span></span><br><span class="line">b     -<span class="number">0.9898830268</span>  <span class="number">1.0000000000</span> -<span class="number">0.0005736179</span></span><br><span class="line">sigma  <span class="number">0.0006161621</span> -<span class="number">0.0005736179</span>  <span class="number">1.0000000000</span></span><br></pre></td></tr></table></figure><br>可以看出$a$与$b$几乎成负相关，这并不是我们想要的，我们可以采用下面的方法：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">d2$weight.c &lt;- d2$weight - mean(d2$weight)</span><br><span class="line"></span><br><span class="line">m4.4 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    height ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + b*weight.c,</span><br><span class="line">    a ~ dnorm(<span class="number">178</span>, <span class="number">100</span>),</span><br><span class="line">    b ~ dnorm(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line">  ),</span><br><span class="line">  data = d2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">precis(m4.4)</span><br><span class="line">        mean   sd   <span class="number">5.5</span>%  94.5%</span><br><span class="line">a     <span class="number">154.60</span> <span class="number">0.27</span> <span class="number">154.17</span> <span class="number">155.03</span></span><br><span class="line">b       <span class="number">0.90</span> <span class="number">0.04</span>   <span class="number">0.84</span>   <span class="number">0.97</span></span><br><span class="line">sigma   <span class="number">5.07</span> <span class="number">0.19</span>   <span class="number">4.77</span>   <span class="number">5.38</span></span><br><span class="line"></span><br><span class="line">cov2cor(vcov(m4.4))</span><br><span class="line">                  a             b         sigma</span><br><span class="line">a      <span class="number">1.000000e+00</span> -<span class="number">1.630888e-11</span>  <span class="number">2.556226e-07</span></span><br><span class="line">b     -<span class="number">1.630888e-11</span>  <span class="number">1.000000e+00</span> -<span class="number">6.380061e-05</span></span><br><span class="line">sigma  <span class="number">2.556226e-07</span> -<span class="number">6.380061e-05</span>  <span class="number">1.000000e+00</span></span><br></pre></td></tr></table></figure><br>可以看到$a$和$b$的相关系数接近于零，这是因为$a$表示当体重为$0$时的身高，而变换后的体重均值为$0$，因为线性回归经过体重的均值、身高的均值这个点，而体重的均值为$0$，所以$a$就表示在体重为体重均值时身高的值，即身高的均值，所以与$b$无关。</p><p>我们也可以绘制后验分布得到的结果：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot(height~weight, data=d2)</span><br><span class="line">abline(a=coef(m4.3)[<span class="string">&quot;a&quot;</span>], b=coef(m4.3)[<span class="string">&quot;b&quot;</span>])</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM5.jpeg" alt=""><br>上图我们只是绘制了一条直线，对应于后验的均值。为了表达不确定性，我们可以对后验分布进行抽样。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post &lt;- extract.samples(m4.3, n=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plot(d2$weight, d2$height, xlim=<span class="built_in">range</span>(d2$weight), ylim=<span class="built_in">range</span>(d2$height), col=rangi2, xlab=<span class="string">&quot;weight&quot;</span>, ylab=<span class="string">&quot;height&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">20</span>) &#123;</span><br><span class="line">  abline(a=post$a[i], b=post$b[i], col=col.alpha(<span class="string">&quot;black&quot;</span>, <span class="number">0.3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM6.jpeg" alt=""><br>对于每个确定的<code>weight</code>，由于$a$和$b$都为高斯分布，所以生成的$\mu_i = a + b w_i$也服从高斯分布。我们可以使用link函数，link函数默认从后验分布中抽取$1000$个样本，对每个固定的weight根据这$1000$个样本计算其$\mu$的值。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mu &lt;- link(m4.3)</span><br><span class="line">str(mu)</span><br><span class="line"></span><br><span class="line"> num [<span class="number">1</span>:<span class="number">1000</span>, <span class="number">1</span>:<span class="number">352</span>] <span class="number">158</span> <span class="number">157</span> <span class="number">157</span> <span class="number">157</span> <span class="number">157</span> ...</span><br></pre></td></tr></table></figure><p>生成的<code>mu</code>为一个矩阵，行表示从后验分布中抽取的样本，列表示数据的数目。<br>这样我们就可以绘制在某个确定weight值上$\mu$的分布：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weight.seq &lt;- seq(from=<span class="number">25</span>, to=<span class="number">70</span>, by=<span class="number">1</span>)</span><br><span class="line">mu &lt;- link(m4.3, data = data.frame(weight=weight.seq))</span><br><span class="line">plot(height~weight, d2, type=<span class="string">&quot;n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">100</span>) &#123;</span><br><span class="line">  points(weight.seq, mu[i,], pch=<span class="number">16</span>, col=col.alpha(rangi2, <span class="number">0.1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM7.jpeg" alt=""><br>这样我们也可以计算关于$\mu$的分布的信息了：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mu.mean &lt;- apply(mu, <span class="number">2</span>, mean)</span><br><span class="line">mu.HPDI &lt;- apply(mu, <span class="number">2</span>, HPDI, prob=<span class="number">0.89</span>)</span><br><span class="line"></span><br><span class="line">plot( height ~ weight , data=d2 , col=col.alpha(rangi2,<span class="number">0.5</span>) )</span><br><span class="line">lines( weight.seq , mu.mean )</span><br><span class="line">shade( mu.HPDI , weight.seq )</span><br></pre></td></tr></table></figure><br>之前我们只是对平均高度$\mu$进行采样，现在我们生成真实的高度height。这意味着我们也将$\sigma$的不确定性结合在一起。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sim.height &lt;- sim(m4.3, data = <span class="built_in">list</span>(weight=weight.seq))</span><br><span class="line">str(sim.height)</span><br><span class="line">height.PI &lt;- apply( sim.height , <span class="number">2</span> , PI , prob=<span class="number">0.89</span> )</span><br></pre></td></tr></table></figure><br>我们也可以绘制图：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plot(height~weight, d2, col=col.alpha(rangi2, <span class="number">0.5</span>))</span><br><span class="line">lines(weight.seq, mu.mean)</span><br><span class="line">shade(mu.HPDI, weight.seq,col=col.alpha(rangi2, <span class="number">0.5</span>))</span><br><span class="line">shade(height.PI, weight.seq,col=col.alpha(rangi2, <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure></p><blockquote><p>不知到为什么shade函数失效</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linear-Models&quot;&gt;&lt;a href=&quot;#Linear-Models&quot; class=&quot;headerlink&quot; title=&quot;Linear Models&quot;&gt;&lt;/a&gt;Linear Models&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/HFC666/image/master/img/LM1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="书籍阅读" scheme="https://www.hfcouc.work/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="概率编程" scheme="https://www.hfcouc.work/tags/%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B/"/>
    
    <category term="贝叶斯统计" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1/"/>
    
    <category term="Statistical Rethinking" scheme="https://www.hfcouc.work/tags/Statistical-Rethinking/"/>
    
  </entry>
  
  <entry>
    <title>A tutorial on Bayesian nonparametric models</title>
    <link href="https://www.hfcouc.work/2022/07/12/BN/"/>
    <id>https://www.hfcouc.work/2022/07/12/BN/</id>
    <published>2022-07-12T09:31:16.000Z</published>
    <updated>2022-07-12T09:54:16.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="A-Tutorial-on-Bayesian-Nonparametric-Models"><a href="#A-Tutorial-on-Bayesian-Nonparametric-Models" class="headerlink" title="A Tutorial on Bayesian Nonparametric Models"></a>A Tutorial on Bayesian Nonparametric Models</h2><p align="center">    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170401%2F66c0602968c0463c805dcd5ab16a87dc_th.jpeg&refer=http%3A%2F%2Fimg.mp.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660210656&t=6f0b4c7c45167ff59154a4b5ee75eb30" style="zoom: 100%;" /></p><blockquote><p>文章地址：<a href="https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X">https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X</a></p></blockquote><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>统计模型的一个核心问题就是模型选择，怎样选择模型复杂度，如在聚类问题中选择聚类的数目等。贝叶斯无参模型通过让数据确定模型复杂度来跳过模型选择的步骤。比如说在传统的机器学习中如聚类中，我们需要事先确定聚类的数目，而贝叶斯无参模型会估计聚类的数目并允许未来的数据来自之前没有的类。</p><p>一般我们进行贝叶斯推断时是对参数的后验分布进行推断，无参贝叶斯与其他贝叶斯模型显著的不同在于其隐藏结构是随着数据增长的。它的复杂度，如聚类的数目，是后验分布的一部分。这些参数无需实现给定，而是作为分析数据的一部分来确定。</p><p>在本文中我们主要介绍两种模型，混合模型(mixture models)和隐语义模型(latent factor models)。贝叶斯无参混合模型，也被称为中国餐馆过程混合(或者狄利克雷过程混合)，从数据中推断聚类的个数并且随着数据的增长允许聚类数增长。</p><p>隐语义模型将观察到的数据分解为潜在因素的线性组合。关于因子分布的不同假设会产生如因子分析、主成分分析、独立成分分析等等。印度自助餐过程隐语义模型通过数据推断因子的数量并且允许因子的数量随着新数据的加入而增加。</p><h3 id="Mixture-models-and-clustering"><a href="#Mixture-models-and-clustering" class="headerlink" title="Mixture models and clustering"></a>Mixture models and clustering</h3><p>在一个混合模型中，每一个观测数据都假设属于一个类。</p><h4 id="Finite-mixture-modeling"><a href="#Finite-mixture-modeling" class="headerlink" title="Finite mixture modeling"></a>Finite mixture modeling</h4><p>有限混合模型假设有$K$个类，每个类与参数$\theta_k$有关。每一个观测$y_n$都假设是首先通过$P(c_n)$来选择一个类$c_n$之后通过与参数$\theta_{c_n}$相对应的分布中产生观测，每一个参数对应一个分布$F(y_n\mid \theta_{c_n})$。</p><p>贝叶斯混合模型引入了混合分布$P(c)$的先验和聚类参数的先验$\theta\sim G_0$。</p><p>这个生成过程定义了关于观测、聚类分配(数据属于哪个类)和聚类参数的联合分布：</p><script type="math/tex; mode=display">P(\mathrm{y,c},\theta) = \prod_{k=1}^K G_0(\theta_k)\prod_{n=1}^NF(Y_n\mid\theta_{c_n})P(c_n)</script><p>其中观测为$\mathrm{y} = \{y_1,\cdots,y_N\}$，聚类分配为$\mathrm{c}=\{c_1,\cdots,c_N\}$，聚类参数为$\theta=\{\theta_1,\cdots,\theta_K\}$。</p><blockquote><p>这里$N$个样本相乘是因为样本之间是独立同分布的，而$K$个$G_0(\theta_k)$相乘是因为每个$\theta_k$也是独立的。</p></blockquote><p>给定数据集，我们经常对聚类分配感兴趣，我们可以用贝叶斯公式计算它们：</p><script type="math/tex; mode=display">P(\mathrm{c}\mid\mathrm{y}) = \frac{P(\mathrm{y}\mid \mathrm{c})P(\mathrm{c})}{\sum_{\mathrm{c}}P(\mathrm{y}\mid\mathrm{c})P(\mathrm{c})}</script><p>其中似然函数可以通过对$\theta$积分得到：</p><script type="math/tex; mode=display">P(\mathrm{y\mid c}) = \int_{\theta}\left[\prod_{n=1}^NF(\mathrm{y}\mid\theta_{c_n})\prod_{k=1}^KG_0(\theta_k)\right]d\theta</script><p>后验分布是很难处理的，因为计算分母需要将每种分配方式进行求和。</p><h4 id="The-Chinese-restaurant-process"><a href="#The-Chinese-restaurant-process" class="headerlink" title="The Chinese restaurant process"></a>The Chinese restaurant process</h4><p>见我的一篇博客(<a href="https://hfcouc.work/2022/07/06/BNP/)。">https://hfcouc.work/2022/07/06/BNP/)。</a></p><h3 id="Latent-factor-models-and-dimensionality-reduction"><a href="#Latent-factor-models-and-dimensionality-reduction" class="headerlink" title="Latent factor models and dimensionality reduction"></a>Latent factor models and dimensionality reduction</h3><p>混合模型假设每个数据都来自$K$个类中的一个。隐语义模型削弱了这一假设：每个观测受到$K$个分量的不同的影响。</p><p>隐语义模型可以用来降维当分量的数目小于数据维度时。每个观察都与一个分量激活向量（潜在因子）相关联，该向量描述了每个分量对其贡献的程度，并且这个向量可以看作是观察本身的低维表示。</p><p>非常著名的降维模型有因子分析(FA)，主成分分析(PCA)和独立成分分析(ICA)等，所有的都假设因子的数量$K$已经确定了。无参贝叶斯模型允许分量的数量随着数据的增长而增多。</p><p>在经典的降维模型中，我们的观测数据一般为$N$个$M$维向量，$\mathrm{Y=\{y_1,\cdots,y_N\}}$。因此$\mathrm{Y}$每行表示一个数据。数据假设是从有噪声的隐语义的加权组合产生的：</p><script type="math/tex; mode=display">\mathrm{y_n = Gx_n+\epsilon_n}</script><p>其中$\mathrm{G}$为$M\times K$的矩阵表示，表示隐语义$k$怎么影响观测维度$m$，$x_n$为一个$K$维向量表示每个隐语义的影响，其中$\epsilon_n$维独立高斯噪声向量。我们可以将其拓展为稀疏模型通过将$\mathrm{G}$进行分解，$\mathrm{G}_{mk}=z_{mk}w_{mk}$，其中$z_{mk}$是一个二元掩码(mask)变量指示因子$k$是否影响维度$m$，而$w_{ik}$为连续权重变量。这个有时被称为<code>spike and slab</code>模型因为$x_{mk}$的期望为一个在隐语义空间上的<code>slab</code>$P(w_{mk})$和在零的位置$P(z_{mk}=0)$的<code>spike</code>。</p><p>我们使用贝叶斯的方法推理隐语义、掩码变量和权重。我们在它们上面定义先验并利用贝叶斯公式计算后验$P(\mathrm{G,Z,W\mid Y})$。</p><p>利用无参贝叶斯模型，我们令数据自动确定隐语义的数目$K$。$Z$为一个二元矩阵，有有限多的行和无限多的列。</p><p>与中国餐馆过程类似，$\mathrm{Z}$上的无限容量的分布也被赋予了一个有关烹饪的隐喻，被称为印度自助餐过程。一个顾客(维度)进入一个具有无限菜品的自主餐馆。顾客$m$选择菜品$k$的概率正比于他被之前顾客选择的次数$h_k$。当顾客考虑了所有之前采样过的菜肴($h_k&gt;0$)的菜肴时，他会额外采样之前从未采样过的$\operatorname{Poisson}(\alpha/N)$菜肴。当所有$M$个顾客都选完菜后，形成的二元矩阵$\mathrm{Z}$从IBP(Indian buffet process)中采样得到。</p><p>与中国餐馆过程不同的是，中国餐馆过程每个观测只能选择一个隐语义，而印度自助餐过程每个观测的每个维度可以选择无数多个隐语义。如下图：</p><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/IBP.jpg" alt=""></p><blockquote><p>印度餐馆过程：IBP的生成过程，其中有序号的菱形代表顾客，与与它们相关的观测连接。大圆形表示菜品，与与它们相关的参数$\phi$相连。每个顾客选择多个菜品，并且每个顾客的观测为选择的菜品的参数的线性组合。</p></blockquote><p>现在回到我们的后验分布，我们想要对我们的隐语义矩阵进行推理：</p><script type="math/tex; mode=display">P(\mathrm{X,W,Z}\mid \mathrm{Y})\propto P(\mathrm{Y\mid X,W,Z})P(\mathrm{X})P(\mathrm{W})P(\mathrm{Z})</script><p>精确的推理是很困难的因为归一化参数需要对所有可能的二元矩阵进行积分。</p><h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><p>在BNP建模中最基本的计算问题是计算后验概率。下面我们只简单介绍几种计算方法。</p><ul><li>MCMC</li><li>变分贝叶斯推断：见我的一篇博客(<a href="https://hfcouc.work/2022/07/10/VBI/">https://hfcouc.work/2022/07/10/VBI/</a>)</li></ul><h3 id="Limitations-and-extensions"><a href="#Limitations-and-extensions" class="headerlink" title="Limitations and extensions"></a>Limitations and extensions</h3><p>我们前面介绍到的两种BNP只是最简单的两种，它们存在着很多限制，为了解决这些限制有很多上述模型的拓展。</p><h4 id="Hierarchical-structure"><a href="#Hierarchical-structure" class="headerlink" title="Hierarchical structure"></a>Hierarchical structure</h4><p>第一个限制是关于分组数据的：我们如何捕捉一个群体中的共性和特性呢？比如说同一种动物既有共性也有自己的特性。解决这个问题的标准贝叶斯方法是基于层次模型，在这个模型中，个体由于来自同一群体的分布而被耦合在一起。在非参数的设定下发展出的模型为分层狄利克雷过程。</p><h4 id="Time-series-models"><a href="#Time-series-models" class="headerlink" title="Time series models"></a>Time series models</h4><p>第二个限制是关于序列数据的：我们怎样才能捕捉到序列观察结果之间的依赖关系？关于这方面非常著名的是隐马尔可夫模型。无限隐马尔科夫模型提出了相同的序列结构，但采用了无限多的潜在类，无限隐马尔可夫模型为分层狄利克雷过程的一个特殊情况。<br>作为<code>HMM</code>（隐状态为离散的）的替代品，线性动态系统（也被称为自回归移动平均模型）假定隐状态是连续的，并根据线性高斯马尔可夫过程随时间演变。在一个切换的线性动态系统中，系统可以有许多动态模式；这使得边际转移分布可以是非线性的。有学者探索了切换线性动态系统的非参数变体，其中动态模式的数量是利用HDP先验从数据中推断出来的。</p><h4 id="Spatial-models"><a href="#Spatial-models" class="headerlink" title="Spatial models"></a>Spatial models</h4><p>很多数据集上的依赖是在空间上的。如某种疾病在某个地方出现，在它附近的地方也可能出现。在BNP模型中捕获这种依赖关系的一种方法是使DP的基分布依赖于一个位置变量。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;A-Tutorial-on-Bayesian-Nonparametric-Models&quot;&gt;&lt;a href=&quot;#A-Tutorial-on-Bayesian-Nonparametric-Models&quot; class=&quot;headerlink&quot; title=&quot;A Tutorial on Bayesian Nonparametric Models&quot;&gt;&lt;/a&gt;A Tutorial on Bayesian Nonparametric Models&lt;/h2&gt;&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170401%2F66c0602968c0463c805dcd5ab16a87dc_th.jpeg&amp;refer=http%3A%2F%2Fimg.mp.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1660210656&amp;t=6f0b4c7c45167ff59154a4b5ee75eb30&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章地址：&lt;a href=&quot;https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X&quot;&gt;https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://www.hfcouc.work/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="贝叶斯" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>变分贝叶斯推断</title>
    <link href="https://www.hfcouc.work/2022/07/10/VBI/"/>
    <id>https://www.hfcouc.work/2022/07/10/VBI/</id>
    <published>2022-07-10T12:03:59.000Z</published>
    <updated>2022-07-10T12:14:43.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Variational-Bayesian-inference"><a href="#Variational-Bayesian-inference" class="headerlink" title="Variational Bayesian inference"></a>Variational Bayesian inference</h2><p align="center">    <img src="https://img0.baidu.com/it/u=2387178916,3720682298&fm=253&fmt=auto?w=1280&h=720" style="zoom: 100%;" /></p><blockquote><p>参考文献</p><ol><li><a href="https://github.com/roboticcam/machine-learning-notes/blob/master/files/variational.pdf">徐亦达老师变分推断课件</a></li><li><a href="https://link.springer.com/article/10.1007/s10462-011-9236-8">A tutorial on variational Bayesian inference</a></li><li><a href="https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8">白板推导指数族分布</a></li><li><a href="https://www.bilibili.com/video/BV1DW41167vr?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8">白板推导变分推断</a></li></ol></blockquote><span id="more"></span><h3 id="Log-likelihood-and-Evidence-Lower-Bound-ELOB"><a href="#Log-likelihood-and-Evidence-Lower-Bound-ELOB" class="headerlink" title="Log-likelihood and Evidence Lower Bound(ELOB)"></a>Log-likelihood and Evidence Lower Bound(ELOB)</h3><p>下列表达式总是成立：</p><script type="math/tex; mode=display">\ln(p(X)) = \ln(p(X,Z)) - \ln(P(Z\mid X))</script><p>所以下式也成立：</p><script type="math/tex; mode=display">\ln(P(X)) = \left[\ln(p(X,Z))-\ln(q(Z))\right] - \left[\ln(p(Z\mid X))-\ln(q(Z))\right]</script><p>所以现在我们有</p><script type="math/tex; mode=display">\ln(p(X)) = \ln\left(\frac{p(X,Z)}{q(Z)}\right) - \ln\left(\frac{p(Z\mid X)}{q(Z)}\right)</script><p>两边同时取期望：</p><script type="math/tex; mode=display">\begin{aligned}\ln (p(X)) &=\int q(Z) \ln \left(\frac{p(X, Z)}{q(Z)}\right) \mathrm{d} Z-\int q(Z) \ln \left(\frac{p(Z \mid X)}{q(Z)}\right) \mathrm{d} Z \\&=\underbrace{\int q(Z) \ln (p(X, Z)) \mathrm{d} Z-\int q(Z) \ln (q(Z)) \mathrm{d} Z}_{\mathcal{L}(q)}+\underbrace{\left(-\int q(Z) \ln \left(\frac{p(Z \mid X)}{q(Z)}\right) \mathrm{d} Z\right)}_{\mathbb{K} \mathbb{L}(q \| p)} \\&=\mathcal{L}(q)+\mathbb{K} \mathbb{L}(q \| p)\end{aligned}</script><p>KL散度一般用于度量两个概率分布函数之间的距离，其定义如下：</p><script type="math/tex; mode=display">\mathbb{KL}[p(X)\mid q(X)] = \sum_{x\in X}\left[p(x)\log\frac{p(x)}{q(x)}\right] = \mathbb{E}_{x\sim p(x)}\left[\log\frac{p(x)}{q(x)}\right]</script><p>我们要做的就是找到与后验分布$p(Z\mid X)$最接近的简单分布$p(Z)$。</p><h3 id="Alternative-Evidence-Lower-Bound-ELOB"><a href="#Alternative-Evidence-Lower-Bound-ELOB" class="headerlink" title="Alternative Evidence Lower Bound(ELOB)"></a>Alternative Evidence Lower Bound(ELOB)</h3><p>我们看另一种推导方法：</p><script type="math/tex; mode=display">\begin{aligned}\ln (p(X)) &=\log \int_{Z} p(X, Z) \mathrm{d} z \\&=\log \int_{Z} p(X, Z) \frac{q(Z)}{q(Z)} \mathrm{d} z \\&=\log \left(\mathbb{E}_{q}\left[\frac{p(X, Z)}{q(Z)}\right]\right) \\& \geq \mathbb{E}_{q}\left[\log \left(\frac{p(X, Z)}{q(Z)}\right)\right] \text { using Jensen's inequality } \\&=\mathbb{E}_{q}[\log (p(X, Z))]-\mathbb{E}_{q}[\log (q(Z))] \\& \triangleq \mathcal{L}(q)\end{aligned}</script><h3 id="Maximize-Evidence-Lower-Bound-ELOB"><a href="#Maximize-Evidence-Lower-Bound-ELOB" class="headerlink" title="Maximize Evidence Lower Bound(ELOB)"></a>Maximize Evidence Lower Bound(ELOB)</h3><p>我们给每个部分一个名字：</p><script type="math/tex; mode=display">\begin{array}{ll}\text {Evidence Lower Bound (ELOB):} & \mathcal{L}(q)=\int q(Z) \ln (p(X, Z)) \mathrm{d} Z-\int q(Z) \ln (q(Z)) \mathrm{d} Z \\\mathrm{KL} \text { divergence: } & \mathbb{K} \mathbb{L}(q \| p)=-\int q(Z) \ln \left(\frac{p(Z \mid X)}{q(Z)}\right) d Z\end{array}</script><ul><li>注意$p(X)$对于$q(Z)$的选择是固定的。我们想要去选择一个$q(Z)$函数最小化KL散度，因此$q(Z)$变得离$p(Z\mid X)$越来越近。很容易验证，当$q(Z)=p(Z\mid X)$时，KL散度为$0$。</li><li>我们知道$\ln p(X) = \mathcal{L}(q)+\mathbb{KL}(q| p)$。最小化$\mathbb{KL}(q| p)$等同于最大化$\mathcal{L}(q)$。</li></ul><p>我们可以选择$q(Z)$使得</p><script type="math/tex; mode=display">q(Z) = \prod_{i=1}^Mq_i(Z_i)</script><p>其中$M$为$Z$的维度，也就是说$q(Z)$的各个维度是独立的，这被称为<strong>平均场变分贝叶斯</strong>。</p><blockquote><p>注意$q(Z)$对联合概率密度函数$p(Z\mid X)$是一个很好地近似，但是边缘分布$q(Z_i)$对$p(Z_i\mid x)$的近似不一定好。</p></blockquote><p>将其带入到$\mathcal{L}(q)$中：</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}(q) &=\int q(Z) \ln (p(X, Z)) \mathrm{d} Z-\int q(Z) \ln (q(Z)) \mathrm{d} Z \\&=\underbrace{\int \prod_{i=1}^{M} q_{i}\left(Z_{i}\right) \ln (p(X, Z)) \mathrm{d} Z}_{\text {part (1) }}-\underbrace{\int \prod_{i=1}^{M} q_{i}\left(Z_{i}\right) \sum_{i=1}^{M} \ln \left(q_{i}\left(Z_{i}\right)\right) \mathrm{d} Z}_{\text {part (2) }}\end{aligned}</script><p>我们先看Part1，假设我们只对$Z_i$感兴趣，将其拿出来，变为：</p><script type="math/tex; mode=display">(\operatorname{Part} 1)=\int_{Z_{j}} q_{j}\left(Z_{j}\right)\left(\int_{Z_{i \neq j}} \ldots \int \prod_{i \neq j}^{M} q_{i}\left(Z_{i}\right) \ln (p(X, Z)) \prod_{i \neq j}^{M} d Z_{i}\right) d Z_{j}</script><p>或者将其写为更紧凑的形式：</p><script type="math/tex; mode=display">(\operatorname{Part} 1)=\int_{Z_{j}} q_{j}\left(Z_{j}\right)\left(\int_{Z_{i \neq j}} \cdots \int \ln (p(X, Z)) \prod_{i \neq j}^{M} q_{i}\left(Z_{i}\right) d Z_{i}\right) d Z_{j}</script><p>或者，为了让其更具有意义，可以将其放进一个期望函数里：</p><script type="math/tex; mode=display">(\operatorname{Part} 1)=\int_{Z_{j}} q_{j}\left(Z_{j}\right)\left[\mathbb{E}_{i \neq j}[\ln (p(X, Z))]\right] d Z_{j}</script><p>现在再看Part2：</p><script type="math/tex; mode=display">(\text { Part 2) }=\int \prod_{i=1}^{M} q_{i}(Z_{i}) \sum_{i=1}^{M} \ln \left(q_{i}(Z_{i}\right)) d Z</script><p>将其化简：</p><script type="math/tex; mode=display">\begin{aligned}\operatorname{(Part2)} &= \int q(Z)\sum_{i=1}^M\ln(q_i(Z_i))dZ\\&=\sum_{i=1}^M\int_{Z}q(Z_1,\cdots,Z_M)\ln(q_i(Z_i))dZ\\&=\sum_{i=1}^M\int_{Z_i}q_i(Z_i)\ln(q_i(Z_i))dZ_i\end{aligned}</script><p>假设现在我们只对$q_j(Z_j)$感兴趣，则其余部分可以看作常数，因此上式可以进一步写为：</p><script type="math/tex; mode=display">(\text { Part } 2)=\int_{Z_{j}} q_{j}\left(Z_{j}\right) \ln \left(q_{j}\left(Z_{j}\right)\right) d Z_{j}+\text { const}</script><p>则$\mathcal{L}(q)$变为：</p><script type="math/tex; mode=display">\mathcal{L}(q)=\operatorname{Part}(1)-\operatorname{Part}(2)=\int_{Z_{j}} q_{j}\left(Z_{j}\right) \mathbb{E}_{i \neq j}[\ln (p(X, Z))] \mathrm{d} Z_{j}-\int_{Z_{j}} q_{j}\left(Z_{j}\right) \ln \left(q_{j}\left(Z_{j}\right)\right) \mathrm{d} Z_{j}+\operatorname{const}</script><p>我们定义：</p><script type="math/tex; mode=display">\ln(\tilde{p}_j(X,Z_j)) = \mathbb{E}_{i\neq j}[\ln(p(X,Z))]</script><p>或者定价的我们可以将ELOB写为：</p><script type="math/tex; mode=display">\mathcal{L}(q_j) = \int_{Z_j}q_j(Z_j)\ln\left[\frac{\tilde{p}_j(X,Z_j)}{q_j(Z_j)}\right]+\text{const}</script><p>这与</p><script type="math/tex; mode=display">-\mathbb{KL}\left(\exp(\mathbb{E}_{i\neq j}[\ln(p(X,Z))])\| q_i(Z_i)\right)</script><p>相等。</p><p><strong>所以我们可以最大化ELOB，或者$\mathcal{L}(q)$，通过最小化这个特殊的KL散度，也就是找到近似和最优$q^\star_i(Z_i)$，使得</strong></p><script type="math/tex; mode=display">\ln(q_i^\star(Z_i)) = \mathbb{E}_{i\neq j}[\ln(p(X,Z))]</script><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>令数据$\mathcal{D}=\{x_1,\cdots,x_n\}$，则</p><script type="math/tex; mode=display">\begin{gathered}p(\mathcal{D} \mid \mu, \tau)=\prod_{i=1}^{n}\left(\frac{\tau}{2 \pi}\right)^{\frac{1}{2}} \exp \left(\frac{-\tau}{2}\left(x_{i}-\mu\right)^{2}\right) \\=\left(\frac{\tau}{2 \pi}\right)^{\frac{n}{2}} \exp \left(\frac{-\tau}{2} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}\right) \\p(\mu \mid \tau)=\mathcal{N}\left(\mu_{0},\left(\lambda_{0} \tau\right)^{-1}\right) \propto \exp \left(\frac{-\lambda_{0} \tau}{2}\left(\mu-\mu_{0}\right)^{2}\right) \\p(\tau)=\operatorname{Gamma}\left(\tau \mid a_{0}, b_{0}\right) \propto \tau^{a_{0}-1} \exp ^{-b_{0} \tau}\end{gathered}</script><p>并且</p><script type="math/tex; mode=display">p(\mathcal{D},\mu,\tau) = p(\mathcal{D}\mid \mu,\tau)p(\mu\mid \tau)p(\tau)</script><p>则：</p><script type="math/tex; mode=display">p(\mu,\tau\mid d)\propto p(\mathcal{D}\mid \mu,\tau)p(\mu\mid \tau)p(\tau)=\mathcal{N}(\mu_n,(\lambda \tau)^{-1})\text{Gamma}(\tau\mid a_n,b_n)</script><p>其中</p><script type="math/tex; mode=display">\begin{aligned}\mu_{n} &=\frac{\lambda_{0} \mu_{0}+n \bar{x}}{\lambda_{0}+n} \\\lambda_{n} &=\lambda_{0}+n \\a_{n} &=a_{0}+n / 2 \\b_{n} &=b_{0}+\frac{1}{2} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}+\frac{\lambda_{0} n\left(\bar{x}-\mu_{0}\right)^{2}}{2\left(\lambda_{0}+n\right)}\end{aligned}</script><p>可以看出是由解析解的，但是为了例子，我们再采用变分贝叶斯的方法，我们假设$q(\mu,\tau)$：</p><script type="math/tex; mode=display">q(\mu,\tau) = q_{\mu}(\mu)q_\tau(\tau)</script><p>则：</p><script type="math/tex; mode=display">\begin{aligned}\ln \left(q_{\mu}^{*}(\mu)\right) &=\mathbb{E}_{q_{\tau}}[\ln (p(\mu, \tau \mid \mathcal{D}))] \\&=\mathbb{E}_{q_{\tau} \tau}[\ln (p(\mathcal{D} \mid \mu, \tau))+\ln p(\mu \mid \tau)]+\text { const. } \quad \text { remove terms do NOT contain } \mu \\&=\mathbb{E}_{q_{\tau}}[\underbrace{-\frac{\tau}{2} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\underbrace{\frac{\lambda_{0} \tau}{2}\left(\mu-\mu_{0}\right)^{2}}_{\ln p(\mu \mid \gamma)}]}_{\ln (p(\mathcal{D} \mid \mu, \tau))}+\text { const. }\\&=-\frac{\mathbb{E}_{q_{\tau}}[\tau]}{2} \underbrace{\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right]}_{\text {terms contain } \mu \text { but does not contain } \tau}+\text { const. }\end{aligned}</script><p>将关于$\mu$的项展开：</p><script type="math/tex; mode=display">\begin{aligned}& \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}=n \mu^{2}-2 n \mu \bar{x}+\lambda_{0} \mu^{2}-2 \lambda_{0} \mu_{0} \mu+\text { const. } \\=&\left(n+\lambda_{0}\right) \mu^{2}-2 \mu\left(n \bar{x}+\lambda_{0} \mu_{0}\right)=\left(n+\lambda_{0}\right)\left(\mu^{2}-\frac{2 \mu\left(n \bar{x}+\lambda_{0} \mu_{0}\right)}{\left(n+\lambda_{0}\right)}\right) \\=&\left(n+\lambda_{0}\right)\left(\mu-\frac{\left(n \bar{x}+\lambda_{0} \mu_{0}\right)}{\left(n+\lambda_{0}\right)}\right)^{2}+\text { const. }\end{aligned}</script><p>因此我们有：</p><script type="math/tex; mode=display">\begin{aligned}\ln \left(q_{\mu}^{*}(\mu)\right) &=-\frac{\mathbb{E}_{q_{\tau}}[\tau]}{2}\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right]+\text { const. } \\&=-\frac{\mathbb{E}_{q_{\tau}}[\tau]\left(n+\lambda_{0}\right)}{2}\left(\mu-\frac{\left(n \bar{x}+\lambda_{0} \mu_{0}\right)}{\left(n+\lambda_{0}\right)}\right)^{2}+\text { const. } \\&=\mathcal{N}\left(\frac{n \bar{x}+\lambda_{0} \mu_{0}}{n+\lambda_{0}}, \mathbb{E}_{q_{\tau}}[\tau]\left(n+\lambda_{0}\right)\right)\end{aligned}</script><p>关于$\tau$，我们有</p><script type="math/tex; mode=display">\begin{aligned}\ln \left(q_{\tau}^{*}(\tau)\right) &=\mathbb{E}_{q_{\mu}}[\ln (p(\mu, \tau \mid \mathcal{D}))] \\&=\mathbb{E}_{q_{\mu}}[\ln (p(\mathcal{D} \mid \mu, \tau))+\ln p(\mu \mid \tau)+\ln p(\tau)]+\text { const. } \\&=\mathbb{E}_{q_{\mu}}[\underbrace{\frac{n}{2} \ln (\tau)-\frac{\tau}{2} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}}_{\ln (p(\mathcal{D} \mid \mu, \tau))} \underbrace{-\frac{\lambda_{0} \tau}{2}\left(\mu-\mu_{0}\right)^{2}}_{\ln p(\mu \mid \gamma)} \underbrace{+\left(a_{0}-1\right) \ln (\tau)-b_{0} \tau}_{\ln p(\tau)}]+\text { const. }\end{aligned}</script><p>将没有$\mu$的项拿出积分：</p><script type="math/tex; mode=display">\begin{aligned}&=\frac{n}{2} \ln (\tau)+\left(a_{0}-1\right) \ln (\tau)-b_{0} \tau-\frac{\tau}{2} \mathbb{E}_{q_{\mu}(\mu)}\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right]+\text { const. } \\&=(\underbrace{\frac{n}{2}+a_{0}}_{a_{n}}-1) \ln (\tau)-\tau(\underbrace{b_{0}+\frac{1}{2} \mathbb{E}_{q_{\mu}(\mu)}\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right]}_{b_{n}}+\text { const. }\end{aligned}</script><p>重写为：</p><script type="math/tex; mode=display">\begin{aligned}b_{n} &=b_{0}+\frac{1}{2} \mathbb{E}_{q_{\mu}}\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right] \\&=b_{0}+\frac{1}{2} \mathbb{E}_{q_{\mu}}\left[-2 \mu n \bar{x}+n \mu^{2}+\lambda_{0} \mu^{2}-2 \lambda_{0} \mu_{0} \mu\right]+\sum_{i=1}^{n}\left(x_{i}\right)^{2}+\lambda_{0} \mu_{0}^{2} \\&=b_{0}+\frac{1}{2}\left[\left(n+\lambda_{0}\right) \mathbb{E}_{q_{\mu}}\left[\mu^{2}\right]-2\left(n \bar{x}+\lambda_{0} \mu_{0}\right) \mathbb{E}_{q_{\mu}}[\mu]+\sum_{i=1}^{n}\left(x_{i}\right)^{2}+\lambda_{0} \mu_{0}^{2}\right]\end{aligned}</script><p>因为$q_{\mu}(\mu)$事先定义好了我们可以计算$\mathbb{E}_{q_\mu}[\mu]$和$\mathbb{E}_{q_\mu}[\mu^2]$。</p><h3 id="随机梯度变分推断"><a href="#随机梯度变分推断" class="headerlink" title="随机梯度变分推断"></a>随机梯度变分推断</h3><p>上面提到的基于平均场的变分推断实际上是坐标上升法，其存在一些问题：</p><ul><li>假设太强，对复杂模型也许假设不好甚至不成立。</li><li>即使假设是成立的，但是因为其递推式包含很多积分，也可能无法计算。</li></ul><p>下面我们采用随机梯度上升的方法来求解变分推断问题：</p><p>我们知道目标函数：</p><script type="math/tex; mode=display">\hat{q} = \arg\min _q\mathbb{KL}(q\| p) = \arg\max_q\mathcal{L}(q)</script><p>其中$q$是$z$的函数，设其参数为$\phi$，我们将其记为$q_{\phi}(z)$，那么我们的目标函数变为：</p><script type="math/tex; mode=display">\hat{q} = \arg\max_{\phi}\mathcal{L}(\phi)</script><p>其中</p><script type="math/tex; mode=display">\mathcal{L}(\phi) = \mathbb{E}_{q_\phi}[\log P]</script><p>因为是随机梯度下降，所以我们每次选取一个样本，假设选取的样本为$x_i$，那么目标函数变为：</p><script type="math/tex; mode=display">\mathcal{L}(\phi) = \mathbb{E}_{q_\phi}[\log P(x_i,z) - \log q_{\phi}(z)]</script><p>对其进行求导，得：</p><script type="math/tex; mode=display">\begin{aligned}\nabla_{\phi} \mathcal{L}(\phi) &=\nabla_{\phi} \mathbb{E}_{q_{\phi}}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] \\&=\nabla_{\phi} \int q_{\phi}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] d z \\&=\int \nabla_{\phi}\left(q_{\phi}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right]\right) d z \\&=\underbrace{\int \nabla_{\phi} q_{\phi} \cdot\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] d z}_{\text{Part1}}+\underbrace{\int q_{\phi} \cdot \nabla_{\phi}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] d z}_{\text{Part2}}\end{aligned}</script><p>我们首先看Part2：</p><script type="math/tex; mode=display">\begin{aligned}\text { Part2 } &=\int q_{\phi} \cdot \nabla_{\phi}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] d z \\&=\int q_{\phi} \cdot\left(-\nabla_{\phi} \log q_{\phi}\right) d z \\&=\int q_{\phi} \cdot\left(-\frac{1}{q_{\phi}} \nabla_{\phi} q_{\phi}\right) d z \\&=-\int \nabla_{\phi} q_{\phi} d z \\&=-\nabla_{\phi} \int q_{\phi} d z \\&=-\nabla_{\phi} 1 \\&=0\end{aligned}</script><p>所以</p><script type="math/tex; mode=display">\nabla_\phi\mathcal{L}(\phi) = \int\nabla_\phi q_\phi\cdot[\log P(x_i,z)-\log q_\phi]dz</script><p>如果能写成期望的形式，我们就可以采用蒙特卡洛的方法对其进行采样，因此进行一个小的变换：$\nabla_\phi q_\phi = \nabla(\log q_\phi)q_\phi$，得到</p><script type="math/tex; mode=display">\begin{aligned}\nabla_\phi\mathcal{L}(\phi) &= \int \nabla_\phi(\log q_\phi)\cdot q_\phi\cdot[\log P(x_i,z)-\log q_\phi]dz\\&= \mathbb{E}_{q_\phi}[\nabla_\phi(\log q_\phi)\cdot (\log P(x_i,z)-\log q_\phi)]\end{aligned}</script><p>这样就可以采用蒙特卡洛的方式进行采样后求解期望：</p><p>从$q_{\phi}(z)$中采样$z$，$z_l \sim q_{\phi}(z),l=1,2,\cdots,L$，因此：</p><script type="math/tex; mode=display">\nabla_\phi\mathcal{L}(\phi)\approx \frac{1}{L}\sum_{l=1}^L\nabla_\phi\log q_{\phi}(z_l)(\log P(x_i,z_l)-\log q_\phi(z_l))</script><p>但是存在一个问题，因为$q_{\phi}(z)$为概率密度函数，所以其值位于$[0,1]$，在$[0,1]$内对数函数的变化非常大，这就导致其方差较大，导致此方法很可能无法使用。</p><p>因此我们采用了重参数化技巧，假定$z = g_\phi(\epsilon,x_i),\epsilon\sim P(\epsilon)$，其中$g_\phi$为参数变换的函数，相当于$z$把随机性转移到了$\epsilon$上，根据随机变量变换的性质：</p><script type="math/tex; mode=display">|q_\phi(z)dz| = |P(\epsilon)d\epsilon|</script><blockquote><p>即：</p><script type="math/tex; mode=display">\frac{q_\phi(z)}{P(\epsilon)} = \left|\frac{dz}{d\epsilon}\right|</script></blockquote><p>将上述变换代入梯度，得：</p><script type="math/tex; mode=display">\begin{aligned}\nabla_{\phi} \mathcal{L}(\phi) &=\nabla_{\phi} \int\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] q_{\phi} d z \\&=\nabla_{\phi} \int\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] \cdot P(\epsilon) d \epsilon \\&=\nabla_{\phi} \mathbb{E}_{P(\epsilon)}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right]\end{aligned}</script><p>因为$P(\epsilon)$与$\phi$的梯度无关，因此可以将其放在期望内部：</p><script type="math/tex; mode=display">\begin{aligned}\nabla_{\phi} \mathcal{L}(\phi) &=E_{P(\epsilon)}\left[\nabla_{\phi}\left(\log P\left(x_i, z\right)-\log q_{\phi}\right)\right] \\&=E_{P(\epsilon)}\left[\nabla_{z}\left(\log P\left(x_i, z\right)-\log q_{\phi}(z)\right) \nabla_{\phi} z\right] \\&=E_{P(\epsilon)}\left[\nabla_{z}\left(\log P\left(x_i, z\right)-\log q_{\phi}(z)\right) \nabla_{\phi} g_{\phi}\left(\epsilon, x_i\right)\right]\end{aligned}</script><p>这样就可以再次采用蒙特卡洛的方法：</p><script type="math/tex; mode=display">\begin{aligned}&\epsilon_l \sim P(\epsilon), \quad l=1,2, \cdots, L \\&\nabla_{\phi} \mathcal{L}(\phi) \approx \frac{1}{L} \sum_{l=1}^{L}\left[\nabla_{z}\left(\log P\left(x_i, z\right)-\log q_{\phi}(z)\right) \nabla_{\phi} g_{\phi}\left(\epsilon_l, x_i\right)\right]\end{aligned}</script><h3 id="Variational-Bayes-with-message-passing"><a href="#Variational-Bayes-with-message-passing" class="headerlink" title="Variational Bayes with message passing"></a>Variational Bayes with message passing</h3><p>上述的手动推导的方式有些繁琐，但是现在的变分信息传递算法(variational message passing(VMP))可以自动对共轭指数分布族进行推导。对于非共轭指数网络，如果需要以牺牲精度为代价快速逼近，VMP 可能仍然有用。</p><p>对于指数族分布，其形式为：</p><script type="math/tex; mode=display">P(x\mid \eta) = h(x)\exp\left(\eta^T\phi(x)-A(\eta)\right)</script><p>其中$\eta$为参数，$\phi(x)$为充分统计量。</p><p>关于指数族分布的标准理论证明了指数分布的充分统计量的性质为：</p><script type="math/tex; mode=display">\langle \phi(x)\rangle = \nabla_{\eta}A(\eta)\mid_\eta</script><p>即充分统计量的期望为$A(\eta)$函数对$\eta$的导数。</p><p>我们用$\text{pa}(z_i)$表示$z_i$的父结点，$\text{ch}(z_i)$表示其子结点，$\text{cop}(z_i;\text{ch})$表示与$x_i$共同子结点为$\text{ch}$父结点的集合；$\text{cop}(z_i)$表示与$z_i$有共同子结点的父结点。我们的更新公式为：</p><script type="math/tex; mode=display">\ln q_i(z_i) = \langle\ln P(z_i,\text{mb}(z_i)),D\rangle_{q(\text{mb}(z_i))}</script><p>其中$\langle\rangle_{q(\text{mb}(z_i))}$相当于对$q(\text{mb}(z_i))$求期望，而$\text{mb}$表示马尔可夫毯。</p><blockquote><p>马尔可夫毯：在随机变量的全集$U$中，对于给定的变量$\mathrm{X}\in \mathrm{U}$和变量集$\mathrm{MB}\subset \mathrm{U}$，若有：</p><script type="math/tex; mode=display">\mathrm{X}\perp \{\mathrm{U-MB-\{X\}}\mid\mathrm{MB}\}</script><p>则称能满足上述条件的最小变量集$\mathrm{MB}$为$\mathrm{X}$的马尔可夫毯。</p></blockquote><p>则可以写为：</p><script type="math/tex; mode=display">=\langle\ln P(\text{pa}(z_i))+\ln P(\text{cop}(z_i))+\ln P(z_i\mid\text{pa}(z_i))+\ln P(\text{ch}(z_i)\mid z_i,\text{cop}(z_i))\rangle_{q(\text{mb}(z_i))}</script><p>去除和$z_i$无关的常数项：</p><script type="math/tex; mode=display">=\langle \ln P(z_i\mid \text{pa}(z_i))\rangle_{q(\text{pa}(z_i))} +\langle\ln P(\text{ch}(z_i)\mid z_i,\text{cop}(z_i))\rangle_{q(\text{ch}(z_i),\text{cop}(z_i))}</script><p>将子结点拆开得：</p><script type="math/tex; mode=display">=\langle \ln P(z_i\mid \text{pa}(z_i))\rangle_{q(\text{pa}(z_i))} +\sum_{\text{ch}\in\text{ch}(z_i)}\langle\ln P(\text{ch}\mid z_i,\text{cop}(z_i))\rangle_{q(\text{ch},\text{cop}(z_i))}</script><p>我们将会将这两部分分开考虑</p><h4 id="Messages-from-parents"><a href="#Messages-from-parents" class="headerlink" title="Messages from parents"></a>Messages from parents</h4><p>共轭指数节点$z_i$由自然参数向量$\phi_i$参数化。通过这些节点的定义：</p><script type="math/tex; mode=display">\begin{aligned}\langle\ln P(z_i\mid \text{pa}(z_i))_{q(\text{pa}(z_i))} &= \langle \phi_i\mu(z_i) + f_i(z_i)+g_i(\phi_i)\rangle_{q(\text{pa}(z_i))}\\&=\langle\phi_i\rangle_{q(\text{pa}(z_i))}\mu_i(z_i)+f_i(z_i)+\langle g(\phi_i)\rangle_{q(\text{pa}(z_i))}\end{aligned}</script><p>由于$\phi$和$g$是父节点充分统计量的多线性函数（通过构造），并且使用平均场假设，我们可以简单地采用它们的公式（定义为以父节点的单个值为条件）并将期望替换为充分统计，根据需要得到整个表达式的期望值。因此$z_i$的父结点只需要将它们的充分统计期望作为信息传递给$z_i$。</p><h4 id="Messages-to-parents"><a href="#Messages-to-parents" class="headerlink" title="Messages to parents"></a>Messages to parents</h4><p>指数族的一个关键性质是我们可以通过将其自然参数相加来得到相似分布的乘积：</p><script type="math/tex; mode=display">\begin{aligned}&\exp\left[\phi_1\mu(z_i)+f(z_i)+g(\phi_1)\right]\cdot\exp\left[\phi_2\mu(z_i)+f(z_i)+g(\phi_2)\right]\\&= \exp\left[(\phi_1+\phi_2)\mu(z_i)+f(z_i)+g(\phi_1+\phi_2)\right]\end{aligned}</script><p>第二个性质是关于共轭，$\phi$和$g$在父结点的充分统计量中也是多线性的。因此我们总是可以通过找到函数$\phi_{ij},f_j,g_{ij}$来重新组合公式是其像是一个父结点$z_j\in\text{pa}(z_i)$的函数：</p><script type="math/tex; mode=display">\left\langle\ln P\left(z_{i} \mid \text{pa}\left(z_{i}\right)\right)\right\rangle_{q\left(\text{pa}\left(z_{i}\right)\right)}=\left\langle\phi_{i j} u_{j}\left(z_{j}\right)+f_{i j}\left(z_{j}\right)+g_{i j}\left(\phi_{i j}\right)\right\rangle_{q\left(\text{pa}\left(z_{i}\right)\right)}</script><p>和以前一样，我们可以通过使用多线性属性来处理期望，以将所有期望推到充分统计量附近。因此，从父结点的角度来看，这是根据其子结点和共同父结点的充分统计期望来写的。因此，我们可以传递一个似然信息，包括：</p><script type="math/tex; mode=display">\phi_{ij}\left(\langle\mu(z_i)\rangle,\{\langle\mu(\text{cop})\rangle\}_{\text{cop}\in\text{cop}(z_j;z_i)}\right)</script><p>然后，父结点可以通过第一个属性将这些简单地添加到其先前的参数中。</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/VBI1.jpg" alt=""></p><p>则：</p><script type="math/tex; mode=display">\ln P(\mu\mid m,\beta) = \begin{bmatrix}m\beta&-\beta/2\end{bmatrix}\cdot \begin{bmatrix}\mu\\\mu^2\end{bmatrix} - \frac{1}{2}(-\ln \beta + \beta m^2+\ln2\pi)</script><p>其中$\phi(x) = \begin{bmatrix}\mu\\\mu^2\end{bmatrix}, \eta^T = \begin{bmatrix}m\beta&amp;-\beta/2\end{bmatrix},A(\eta) = \frac{1}{2}(-\ln \beta + \beta m^2+\ln2\pi)$。</p><p>所以很容易得到充分统计量的期望为：</p><script type="math/tex; mode=display">\left\langle \begin{bmatrix}\mu\\\mu^2\end{bmatrix}\right\rangle = \nabla A(\eta) = \begin{bmatrix}\mu\\\mu^2+\beta^{-1}\end{bmatrix}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Variational-Bayesian-inference&quot;&gt;&lt;a href=&quot;#Variational-Bayesian-inference&quot; class=&quot;headerlink&quot; title=&quot;Variational Bayesian inference&quot;&gt;&lt;/a&gt;Variational Bayesian inference&lt;/h2&gt;&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://img0.baidu.com/it/u=2387178916,3720682298&amp;fm=253&amp;fmt=auto?w=1280&amp;h=720&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/roboticcam/machine-learning-notes/blob/master/files/variational.pdf&quot;&gt;徐亦达老师变分推断课件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.springer.com/article/10.1007/s10462-011-9236-8&quot;&gt;A tutorial on variational Bayesian inference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;白板推导指数族分布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1DW41167vr?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;白板推导变分推断&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://www.hfcouc.work/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="贝叶斯" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>指数分布族</title>
    <link href="https://www.hfcouc.work/2022/07/10/EXP/"/>
    <id>https://www.hfcouc.work/2022/07/10/EXP/</id>
    <published>2022-07-10T12:03:45.000Z</published>
    <updated>2022-07-10T12:08:25.180Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Exponential-Family-Distribution"><a href="#Exponential-Family-Distribution" class="headerlink" title="Exponential Family Distribution"></a>Exponential Family Distribution</h2><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/EX1.png" alt=""></p><blockquote><p>课程地址：<a href="https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8">https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8</a></p></blockquote><span id="more"></span><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>指数分布族是可以写为如下形式的分布：</p><script type="math/tex; mode=display">P(x\mid \eta) = h(x)\exp\left(\eta^T\phi(x)-A(\eta)\right)</script><p>其中$\eta$为参数向量，$x\in \mathbb{R}^p$，$A(\eta)$为对数配分函数(log partition function)。</p><p>下面我们解释一下<strong>配分函数</strong>，配分函数可以理解为<strong>归一化因子</strong>，例如我们在无向图模型中经常用到的：</p><script type="math/tex; mode=display">P(X\mid \theta) = \frac{1}{Z}\hat{P}(X\mid \theta)</script><p>其中$\hat{P}(X\mid \theta)$是我们构造出来的分布，但是概率分布必须满足和为$1$，所以我们在前面添加归一化因子使得：</p><script type="math/tex; mode=display">Z = \int_x \hat{P}(x\mid \theta)dx</script><p>可以看出$Z$与$X$无关，那为什么$A(\eta)$称为对数配分函数呢？这是因为：</p><script type="math/tex; mode=display">\begin{aligned}P(x\mid \eta) &= h(x)\exp\left(\eta^T\phi(x)-A(\eta)\right)\\&= \frac{1}{\exp(A(\eta))}h(x)\exp(\eta^T\phi(x))\end{aligned}</script><p>所以$Z = \exp(A(\eta))\Rightarrow A(\eta)=\ln Z$，所以其被称为对数配分函数。</p><p>其中$\phi(x)$为<strong>充分统计量</strong>。充分统计量指的是能够包含样本中所有信息的统计量。</p><p>如对于数据$x_1,\cdots,x_N$，我们假设其服从于高斯分布，那么其充分统计量就为：</p><script type="math/tex; mode=display">\phi(x) = \begin{bmatrix}\sum_{i=1}^Nx_i\\\sum_{i=1}^Nx_i^2\end{bmatrix}</script><p>因为有了这两个统计量我们就可以求出其<strong>均值</strong>和<strong>方差</strong>。</p><p>在贝叶斯推断中我们常常遇到这样的问题：</p><script type="math/tex; mode=display">P(Z\mid X) = \frac{P(X\mid Z)P(Z)}{\int_ZP(X\mid Z)P(Z)dZ}</script><p>有时候积分很难算出，即使积分算出了，$P(Z\mid X)$的形式可能很复杂，我们无法求解其期望和方差，这时候我们可以采用采样的方法(MCMC)或者通过变分推断来寻找接近$P(Z\mid X)$的概率分布$Q(X)$。</p><p>但是指数族分布可以采用共轭的性质。</p><p>指数族分布与广义线性模型，广义线性模型的重要组成部分为：</p><ol><li>线性组合，如$w^Tx$</li><li>link function：为激活函数的逆函数</li><li>指数族分布：$y\mid x\sim$指数族分布</li></ol><p>概率图模型中非常重要的一组模型为无向图RBF，与指数族分布具有非常重要的关系。</p><p>另外当分布为指数族分布时，变分推断可见极大地简化。</p><h3 id="高斯分布的指数族形式"><a href="#高斯分布的指数族形式" class="headerlink" title="高斯分布的指数族形式"></a>高斯分布的指数族形式</h3><p>高斯分布的形式为：</p><script type="math/tex; mode=display">\begin{aligned}P(x\mid\theta) &= \frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{1}{2\sigma^2}(x-\mu)^2\right)\quad \theta = (\mu,\sigma^2)\\&=\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{1}{2\sigma^2}(x^2-2\mu x+\mu^2)\right)\\&=\exp\left(\log(2\pi\sigma^2)^{-\frac{1}{2}}\right)\exp\left(-\frac{1}{2\sigma^2}\begin{pmatrix}-2\mu&1\end{pmatrix}\begin{pmatrix}x\\x^2\end{pmatrix}-\frac{\mu^2}{2\sigma^2}\right)\\&=\exp\left(\underbrace{\begin{pmatrix}\frac{\mu}{\sigma^2}&-\frac{1}{2\sigma^2}\end{pmatrix}}_{\eta^T}\cdot\underbrace{\begin{pmatrix}x\\x^2\end{pmatrix}}_{\phi(x)}-\underbrace{\left(\frac{\mu^2}{2\sigma^2}+\frac{1}{2}\log2\pi\sigma^2\right)}_{A(\eta)}\right)\end{aligned}</script><p>其中我们令$\eta_1=\frac{\mu}{\sigma^2},\eta_2=-\frac{1}{2\sigma^2}$。则$\sigma^2=-\frac{1}{2\eta_2},\mu=-\frac{\eta_1}{2\eta_2}$。代入$A(\eta)$，得：</p><script type="math/tex; mode=display">A(\eta) = -\frac{\eta_1^2}{4\eta_2}+\frac{1}{2}\log\left(-\frac{\pi}{\eta_2}\right)</script><h3 id="对数配分函数与充分统计量的关系"><a href="#对数配分函数与充分统计量的关系" class="headerlink" title="对数配分函数与充分统计量的关系"></a>对数配分函数与充分统计量的关系</h3><p>我们之前提到过：</p><script type="math/tex; mode=display">\exp(A(\eta)) = \int_x h(x)\exp(\eta^T\phi(x))dx</script><p>两边同时对$\eta$求导，得：</p><script type="math/tex; mode=display">\begin{aligned}\exp(A(\eta))\cdot A^\prime(\eta) &= \frac{\partial}{\partial \eta}(\int h(x)\exp(\eta^T\phi(x))dx)\\&= \int_xh(x)\exp(\eta^T\phi(x))\phi(x)dx\end{aligned}</script><p>两边同除以$A^\prime(\eta)$，得</p><script type="math/tex; mode=display">\begin{aligned}A^\prime(\eta) &= \frac{\int_xh(x)\exp(\eta^T\phi(x))\phi(x)dx}{\exp(A(\eta))}\\&=\int_x \underbrace{h(x)\exp(\eta^T\phi(x)-A(\eta))}_{P(x\mid\eta)}\phi(x)dx\\&= \mathbb{E}_{P(x\mid\eta)}[\phi(x)]\end{aligned}</script><p>所以$A^\prime(\eta) = \mathbb{E}_{P(x\mid \eta)}[\phi(x)]$。</p><p>同样地，我们也可以研究一下二阶导，对式子</p><script type="math/tex; mode=display">A^\prime(\eta) =\int_x \underbrace{h(x)\exp(\eta^T\phi(x)-A(\eta))}_{P(x\mid\eta)}\phi(x)dx</script><p>两边同时求导得：</p><script type="math/tex; mode=display">\begin{aligned}A^{\prime\prime}(\eta) &= \int_x \underbrace{h(x)\exp(\eta^T\phi(x)-A(\eta))}_{P(x\mid\eta)}(\phi(x)-A^{\prime}(\eta))\phi(x)dx\\&= \int_xP(x\mid\eta)(\phi(x)-\mathbb{E}_{P(x\mid\eta)}[\phi(x)])\phi(x)dx\\&= \int_x P(x\mid \eta)\phi(x)^2dx - \mathbb{E}_{P(x\mid\eta)}[\phi(x)])\int_xP(x\mid \eta)\phi(x)dx\\&= \mathbb{E}_{P(x\mid\eta)}[\phi(x)^2] - \left(\mathbb{E}_{P(x\mid \eta)}[\phi(x)]\right)^2\\&=\operatorname{Var}[\phi(x)]\end{aligned}</script><h3 id="极大似然估计与充分统计量"><a href="#极大似然估计与充分统计量" class="headerlink" title="极大似然估计与充分统计量"></a>极大似然估计与充分统计量</h3><p>假设我们的数据为：$D=\{x_1,x_2,\cdots,x_N\}$，所以我们有：</p><script type="math/tex; mode=display">\begin{aligned}\eta_{\text{mle}} &= \arg\max\log P(D\mid \eta)\\&=\arg\max \log\prod_{i=1}^N P(x_i\mid \eta)\\&=\arg\max \sum_{i=1}^N\log P(x_i\mid \eta)\\&=\arg\max\sum_{i=1}^N\log\left[h(x_i)\exp(\eta^T\phi(x_i)-A(\eta))\right]\\&= \arg\max\sum_{i=1}^N\left[\log h(x_i)+\eta^T\phi(x_i)-A(\eta)\right]\\&= \arg\max\sum_{i=1}^N(\eta^T\phi(x_i)-A(\eta))\end{aligned}</script><p>我们对其求导，得：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial}{\partial \eta}\left(\sum_{i=1}^N\eta^T\phi(x_i)-A(\eta)\right)&=\sum_{i=1}^N\frac{\partial}{\partial \eta}(\eta^T\phi(x_i)-A(\eta))\\&=\sum_{i=1}^N\phi(x_i)-A^{\prime}(\eta)\\&=\sum_{i=1}^N\phi(x_i)-NA^{\prime}(\eta)\end{aligned}</script><p>令导数等于$0$，得</p><script type="math/tex; mode=display">A^{\prime}(\eta_{\text{mle}}) = \frac{1}{N}\sum_{i=1}^N\phi(x_i)</script><p>这样我们就可以求出$\eta_{\text{mle}}$，可以看出$\eta_{\text{mle}}$仅与$\phi(x)$有关，即确定了$\phi(x)$即确定了$\eta_{\text{mle}}$，即确定了分布，更加验证了$\phi(x)$充分统计量的结论。</p><h3 id="最大熵角度"><a href="#最大熵角度" class="headerlink" title="最大熵角度"></a>最大熵角度</h3><p>假设一个事件发生的概率为$p$，其信息量为$-\log p$。熵的概念就是信息量关于分布本身的期望：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}_{p(x)}[-\log p] &= -\int_x p(x)\log p(x)dx\\&= -\sum_x p(x)\log p(x)\end{aligned}</script><p>最大熵的思想通俗来说就是等可能的，当我们对一个事件一无所知时，我们一般假设其是等可能的。下面看一个例子：</p><p>我们用$H[P]$来表示熵：</p><script type="math/tex; mode=display">H[p] = -\sum_x p(x)\log p(x)</script><p>我们假设$x$是离散的，$x$可以取值的个数为$K$，概率分别对应于$p_1,\cdots,p_K$，并且$\sum_{i=1}^K p_i=1$。所以其熵为：</p><script type="math/tex; mode=display">H[p] = -\sum_{i=1}^K p_i\log (p_i)</script><p>我们令其最大，即变为了优化问题：</p><script type="math/tex; mode=display">\begin{aligned}&\min \sum_{i=1}^K p_i\log p_i\\&\text{s.t. }\sum_{i=1}^K p_i=1\end{aligned}</script><p>我们可以直接用拉格朗日乘子法进行求解，定义：</p><script type="math/tex; mode=display">\mathcal{L}(p,\lambda) = \sum_{i=1}^K p_i\log(p_i)+\lambda(1-\sum_{i=1}^Kp_i)</script><p>对$p_i$求导，得：</p><script type="math/tex; mode=display">\frac{\partial \mathcal{L}(p,\lambda)}{\partial p_i} = \log(p_i)+p_i\cdot\frac{1}{p_i}-\lambda</script><p>所以：</p><script type="math/tex; mode=display">p_i = \exp(\lambda-1)</script><p>对于每个$p_i$都是如此，所以$p_1=p_2=\cdots=p_K=\frac{1}{K}$，所以其为等可能的。</p><p>最大熵原理：在满足既定事实的前提下，具有最大熵的分布即为我们想要的分布。在机器学习中，我们的既定事实即为数据，假设我们的数据为$D=\{x_1,\cdots,x_N\}$。</p><p>在这里我们引入经验分布的概念，其是对已知样本的描述，其定义为：</p><script type="math/tex; mode=display">\hat{p}(X=x) = \frac{\text{count}(x)}{N}</script><p>因为分布$\hat{p}$我们已经求出来了，所以对于$x$的任意函数$f(x)$向量，我们也能求其期望：</p><script type="math/tex; mode=display">\mathbb{E}_{\hat{p}}[f(x)] = \Delta(\text{已知})</script><p>这个就是我们的<strong>已知约束</strong>。</p><p>下面我们求满足上述约束的最大熵的分布，这就变成了优化问题：</p><script type="math/tex; mode=display">\begin{aligned}&\min \sum_x p(x)\log p(x)\\&\text{s.t. } \sum_x p(x)=1\\&\quad\quad \mathbb{E}_{\hat{p}} [f(x) ]= \mathbb{E}_p[f(x)] = \Delta\end{aligned}</script><p>定义拉格朗日乘子：</p><script type="math/tex; mode=display">\mathcal{L}(p,\lambda_0,\lambda) = \sum_x p(x)\log p(x) + \lambda_0(1-\sum_x p(x))+\lambda^T(\Delta-\mathbb{E}_p[f(x)])</script><p>对$p(x)$求导得：</p><script type="math/tex; mode=display">\frac{\mathcal{L}}{\partial p(x)} =(\log p(x)+1)-\lambda_0-\lambda^T f(x)</script><p>令其等于$0$，得</p><script type="math/tex; mode=display">\log p(x) = \lambda^T f(x) + \lambda_0-1</script><p>所以</p><script type="math/tex; mode=display">p(x) = \exp\left(\lambda^T f(x) - (1-\lambda_0)\right)</script><p>为指数族分布。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Exponential-Family-Distribution&quot;&gt;&lt;a href=&quot;#Exponential-Family-Distribution&quot; class=&quot;headerlink&quot; title=&quot;Exponential Family Distribution&quot;&gt;&lt;/a&gt;Exponential Family Distribution&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/HFC666/image/master/img/EX1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="概率论" scheme="https://www.hfcouc.work/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
</feed>
