[{"title":"ESLII","url":"/2021/07/28/ESLII/","content":"\n\n\n{% pdf https://hfcouc.work/pdfs/ESLII.pdf %}\n\n","tags":["统计学习精要"]},{"title":"统计学习精要笔记 day01","url":"/2021/07/17/统计学习精要笔记-day01/","content":"\n#! https://zhuanlan.zhihu.com/p/390681755\n\n## 监督学习导论\n\n### 两种简单的预测方法：最小二乘法和最近邻法\n\n#### 线性模型和最小二乘法\n\n我们将截距$\\beta_0$加入到系数$\\beta$中，我们得到：\n$$\nY = \\beta X\n$$\n那我们模型的误差平方和为：\n$$\n\\operatorname{RSS}(\\beta) = (y-X\\beta)^T(y-X\\beta)\n$$\n我们的目的是让误差平方和最小，所以我们对其求导，在导数为$0$的点即取到最小值：\n$$\nX^T(y-X\\beta) = 0\n$$\n如果$X^TX$是可逆的，那么我们就可以得到：\n$$\n\\hat{\\beta} = (X^TX)^{-1}X^Ty\n$$\n\n#### 最近邻法\n\n最近邻法从训练集中挑选离输入空间$x$中最近的值$y$来作为预测值，即\n$$\n\\hat{Y}(x) = \\frac{1}{k}\\sum_{x_i \\in N_k(x)}y_i\n$$\n$k$近邻算法的有效参数个数为$N/k$，一般会大于最小二乘法的参数个数$p$，并且随着$k$的增大而减小。但为什么有效参数个数是$N/k$呢？因为假设用离样本点最近的$k$个点来决定分类，如果相邻点是不重叠的，那么最多可以分为$N/k$个区域，KNN算法对这$N/k$个区域每个都独立地估计一个响应值，共需要估计$N/k$个独立的值。\n\n### 统计决策理论\n\n假设$X\\in \\mathbb{R}^p$为随机输入向量，$Y\\in \\mathbb{R}$为输出随机变量，他们的联合概率密度函数为$\\operatorname{Pr}(X,Y)$。我们使用平方均值误差作为损失函数，则$L(Y, f(X)) = (Y-f(X))^2$。这就给了我们一个衡量$f$好坏的一个标准：\n$$\n\\begin{aligned}\n\\operatorname{EPE}(f) &= E(Y-f(X))^2\\\\\n&= \\int\\int[(y-f(x))^2]\\operatorname{Pr}(x, y)dxdy\n\\end{aligned} \n$$\n称为期望(平方)预测误差。通过用条件概率改写公式，我们可以将公式写为\n$$\n\\begin{aligned}\n\\operatorname{EPE}(f) &= E(Y-f(X))^2\\\\\n&= \\int\\int[(y-f(x))^2]\\operatorname{Pr}(x, y)dxdy\\\\\n&= \\int\\int[(y-f(x))^2|x]\\operatorname{Pr}(y|x)\\operatorname{Pr}(x)dydx\\\\\n&= \\int E_{Y|X}([Y-f(X)]^2|X)\\operatorname{Pr}(x)dx\\\\\n&= E_XE_{Y|X}([Y-f(X)]^2|X)\n\\end{aligned}\n$$\n对于某一点，我们的估计值为：\n$$\nf(x) = \\arg\\min_cE_{Y|X}([Y-c]^2|X=x)\n$$\n因为在上式中$x$已经知道，因此我们可以将式子简化为:\n$$\n\\begin{aligned}\nE_{Y|X}([Y-c]^2|X=x) &= \\int [(y-c)^2|x]\\operatorname{Pr}(y|x)dy\\\\\n&= \\int[(y-c)^2]\\operatorname{Pr}(y)dy\n\\end{aligned}\n$$\n对上式进行求导:\n$$\n\\int (y-c) \\operatorname{Pr}(y)dy = 0\n$$\n所以结果为:\n$$\nf(x) = E(Y|X=x)\n$$\n得到的条件期望函数，也被成为回归函数。因此当用平方均值误差函数作为损失函数时，$Y$的最有估计为$X=x$是的条件期望。\n最近邻试图使用训练数据直接实现该方法。我们直接用最接近$x$的$k$个点的$y$的均值来近似$y$：\n$$\n\\hat{f}(x) = \\operatorname{Ave}(y_i|x_i\\in N_k(x))\n$$\n在联合概率分布函数$\\operatorname{Pr}(X,Y)$的限制比较小时，可以证明当$N, k\\rightarrow \\infty$ 并且 $k/N\\rightarrow 0$时，$\\hat{f}(x)\\rightarrow E(Y|X=x)$。但是我们的数据通常没有那么多，并且随着数据数量和维数的增多，算法收敛的速度会越来越慢。\n但是为什么线性回归能在此模式下工作呢？因为对于线性模型我们可以通过导数的知识来求解：\n$$\n\\beta = [E(XX^T)]^{-1}E(XY)\n$$\n还有一些比较复杂的模型比如相加模型：\n$$\nf(X) = \\sum_{j=1}^pf_j(X_j)\n$$\n它保持了线性模型的相加性，同时$f_j$也是任意的。我们可以利用K近邻的方法同时对每个$f_j$进行单参数的估计。\n我们之前使用的损失函数都是$L_2$损失函数，如果我们使用$L_1:E|Y-f(X)|$作为损失函数呢？这种情况下的估计值为：\n$$\n\\hat{f}(x) = \\operatorname{median}(Y|X=x)\n$$\n那为什么是中位数呢，由于不能直接求导，我们考虑两种情况，当$y>c$时导数为$1$，当$y<c$时导数为$-1$，所以当$c$为中位数是大于小于的数一样多，最后相加为$0$。\n如果我们的响应变量是一个分类变量$G$怎么办。方法与上文相似。我们的损失函数可以是一个$K\\times K$的矩阵$L$，$L(k,l)$是$k$被分为$l$的代价。但是大多数情况下我们还是采用$0-1$损失函数。期望预测误差为：\n$$\n\\operatorname{EPE} = E[L(G,\\hat{G}(x))]\n$$\n同样的，$\\operatorname{EPE}$可以写为\n\n$$\n\\operatorname{EPE} = E_X\\sum_{k=1}^K[\\mathcal{G}_k, \\hat{G}(X)]\\operatorname{Pr}(\\mathcal{G}_k|X)\n$$\n同样的在某一个点的损失为\n\n$$\n\\hat{G}(x) = \\arg\\min_{g\\in \\mathcal{G}}\\sum_{k=1}^KL(\\mathcal{G}_k, g)\\operatorname{Pr}(\\mathcal{G}_k|X=x)\n$$\n\n我们采用$0-1$函数作为损失函数：\n$$\n\\hat{G}(x) = \\arg\\min_{g\\in\\mathcal{G}}[1-\\operatorname{Pr}(g|X=x)]\n$$\n\n或者简化为\n$$\n\\hat{G}(X) = \\mathcal{G}_k \\text{如果} \\operatorname{Pr}(\\mathcal{G}_k|X=x)= \\max_{g\\in \\mathcal{G}}\\operatorname{Pr}(g|X=x)\n$$\n这个就称为贝叶斯分类器。","tags":["统计学习"]},{"title":"Dijkstra算法","url":"/2021/07/15/Dijkstra算法/","content":"\n### 轨迹规划\n\n轨迹规划 = 路径规划 + 轨迹优化\n\n\n\n如下问题：机器人需要穿过障碍物到达终点：\n\n<img src=\"https://raw.githubusercontent.com/HFC666/image/master/img/1.png\" style=\"zoom:50%;\" />\n\n一般我们首先会进行路径规划，路径规划得到的一般是折线\n\n<img src=\"https://raw.githubusercontent.com/HFC666/image/master/img/20210714184949.png\" style=\"zoom:67%;\" />\n\n这样机器人在经过每个转折点时就必须改变行进方向\n\n\n\n**轨迹优化就是在路径规划的基础上将折现优化成带时间参数的轨迹：**\n\n<img src=\"https://raw.githubusercontent.com/HFC666/image/master/img/20210714185403.png\" style=\"zoom:67%;\" />\n\n### Dijkstra算法\n\n一种寻找最短路径的算法\n\n![](https://raw.githubusercontent.com/HFC666/image/master/img/20210714191837.png)，连线上的数字表示从一个节点到另一个节点的代价（距离)。\n\n现在我们要寻找从$v_1$到$v_6$的最短路径。\n\n我们的结果如下图：\n\n![](https://raw.githubusercontent.com/HFC666/image/master/img/20210714191831.png)，为$v_1\\rightarrow v_4\\rightarrow v_7 \\rightarrow v_6$。\n\n那么Dijkstra算法的基本思想是什么呢？\n\n**从起点开始逐步扩展，每一步为一个节点找到最短路径**\n\n> While True:\n>\n> 1. 从未访问的节点选择距离最小的节点收录（贪心思想）\n> 2. 收录节点后遍历该节点的邻接节点，更新距离\n\n为什么被收录的节点已经找到距离起点最短的路径？\n\n我们可以使用反证法进行证明：\n\n假设$g(1\\rightarrow2\\rightarrow4) < g(1\\rightarrow4)$，那么我们就能够推出$g(1\\rightarrow2)<g(1\\rightarrow 4)$，这说明被收录的应该是$2$而不是$4$，而条件里收录的是$4$，矛盾。\n\n伪代码如下\n\n![](https://raw.githubusercontent.com/HFC666/image/master/img/20210714191907.png)\n\n#### 栅格地图\n\n![](https://raw.githubusercontent.com/HFC666/image/master/img/20210714192224.png)\n\n如图所示，红色的是机器人，灰色的是障碍物，在研究中我们经常将机器人看作**质点**，而将障碍物进行膨胀处理，这就是我们经常说的**构型空间(Configuration Space)**。\n\n之后我们将对地图进行栅格化：\n\n![](https://raw.githubusercontent.com/HFC666/image/master/img/20210714192444.png)\n\n那么我们如何将栅格地图转换为**有权图**呢？\n\n一个方法就是将栅格地图的每一个节点看作有权图的节点，机器人的运动范围看作有权图的连线。\n\n![](https://raw.githubusercontent.com/HFC666/image/master/img/20210714192524.png)\n\n#### 代码\n\n~~~python\nimport matplotlib.pyplot as plt\nimport math\n\nshow_animation = True\n\n\nclass Dijkstra:\n\n    def __init__(self, ox, oy, resolution, robot_radius):\n        \"\"\"\n        Initialize map for planning\n\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"\n\n        self.min_x = None\n        self.min_y = None\n        self.max_x = None\n        self.max_y = None\n        self.x_width = None\n        self.y_width = None\n        self.obstacle_map = None\n\n        self.resolution = resolution\n        self.robot_radius = robot_radius\n        self.calc_obstacle_map(ox, oy)\n        self.motion = self.get_motion_model()\n\n    class Node:\n        def __init__(self, x, y, cost, parent_index):\n            self.x = x  # index of grid\n            self.y = y  # index of grid\n            self.cost = cost  # g(n)\n            self.parent_index = parent_index  # index of previous Node\n\n        def __str__(self):\n            return str(self.x) + \",\" + str(self.y) + \",\" + str(\n                self.cost) + \",\" + str(self.parent_index)\n\n    def planning(self, sx, sy, gx, gy):\n        \"\"\"\n        dijkstra path search\n\n        input:\n            s_x: start x position [m]\n            s_y: start y position [m]\n            gx: goal x position [m]\n            gx: goal x position [m]\n\n        output:\n            rx: x position list of the final path\n            ry: y position list of the final path\n        \"\"\"\n\n        start_node = self.Node(self.calc_xy_index(sx, self.min_x),\n                               self.calc_xy_index(sy, self.min_y), 0.0,\n                               -1)  # round((position - minp) / self.resolution)\n        goal_node = self.Node(self.calc_xy_index(gx, self.min_x),\n                              self.calc_xy_index(gy, self.min_y), 0.0, -1)\n\n        open_set, closed_set = dict(), dict()  # key - value: hash表\n        open_set[self.calc_index(start_node)] = start_node\n\n        while 1:\n            c_id = min(open_set, key=lambda o: open_set[o].cost)  # 取cost最小的节点\n            current = open_set[c_id]\n\n            # show graph\n            if show_animation:  # pragma: no cover\n                plt.plot(self.calc_position(current.x, self.min_x),\n                         self.calc_position(current.y, self.min_y), \"xc\")\n                # for stopping simulation with the esc key.\n                plt.gcf().canvas.mpl_connect(\n                    'key_release_event',\n                    lambda event: [exit(0) if event.key == 'escape' else None])\n                if len(closed_set.keys()) % 10 == 0:\n                    plt.pause(0.001)\n\n            # 判断是否是终点\n            if current.x == goal_node.x and current.y == goal_node.y:\n                print(\"Find goal\")\n                goal_node.parent_index = current.parent_index\n                goal_node.cost = current.cost\n                break\n\n            # Remove the item from the open set\n            del open_set[c_id]\n\n            # Add it to the closed set\n            closed_set[c_id] = current\n\n            # expand search grid based on motion model\n            for move_x, move_y, move_cost in self.motion:\n                node = self.Node(current.x + move_x,\n                                 current.y + move_y,\n                                 current.cost + move_cost, c_id)\n                n_id = self.calc_index(node)\n\n                if n_id in closed_set:\n                    continue\n\n                if not self.verify_node(node):\n                    continue\n\n                if n_id not in open_set:\n                    open_set[n_id] = node  # Discover a new node\n                else:\n                    if open_set[n_id].cost >= node.cost:\n                        # This path is the best until now. record it!\n                        open_set[n_id] = node\n\n        rx, ry = self.calc_final_path(goal_node, closed_set)\n\n        return rx, ry\n\n    def calc_final_path(self, goal_node, closed_set):\n        # generate final course\n        rx, ry = [self.calc_position(goal_node.x, self.min_x)], [\n            self.calc_position(goal_node.y, self.min_y)]\n        parent_index = goal_node.parent_index\n        while parent_index != -1:\n            n = closed_set[parent_index]\n            rx.append(self.calc_position(n.x, self.min_x))\n            ry.append(self.calc_position(n.y, self.min_y))\n            parent_index = n.parent_index\n\n        return rx, ry\n\n    def calc_position(self, index, minp):\n        pos = index * self.resolution + minp\n        return pos\n\n    def calc_xy_index(self, position, minp):\n        return round((position - minp) / self.resolution)\n\n    def calc_index(self, node):\n        return node.y * self.x_width + node.x\n\n    def verify_node(self, node):\n        px = self.calc_position(node.x, self.min_x)\n        py = self.calc_position(node.y, self.min_y)\n\n        if px < self.min_x:\n            return False\n        if py < self.min_y:\n            return False\n        if px >= self.max_x:\n            return False\n        if py >= self.max_y:\n            return False\n\n        if self.obstacle_map[node.x][node.y]:\n            return False\n\n        return True\n\n    def calc_obstacle_map(self, ox, oy):\n        ''' 第1步：构建栅格地图 '''\n        self.min_x = round(min(ox))\n        self.min_y = round(min(oy))\n        self.max_x = round(max(ox))\n        self.max_y = round(max(oy))\n        print(\"min_x:\", self.min_x)\n        print(\"min_y:\", self.min_y)\n        print(\"max_x:\", self.max_x)\n        print(\"max_y:\", self.max_y)\n\n        self.x_width = round((self.max_x - self.min_x) / self.resolution)\n        self.y_width = round((self.max_y - self.min_y) / self.resolution)\n        print(\"x_width:\", self.x_width)\n        print(\"y_width:\", self.y_width)\n\n        # obstacle map generation\n        # 初始化地图\n        self.obstacle_map = [[False for _ in range(self.y_width)]\n                             for _ in range(self.x_width)]\n        # 设置障碍物\n        for ix in range(self.x_width):\n            x = self.calc_position(ix, self.min_x)\n            for iy in range(self.y_width):\n                y = self.calc_position(iy, self.min_y)\n                for iox, ioy in zip(ox, oy):\n                    d = math.hypot(iox - x, ioy - y)\n                    if d <= self.robot_radius:\n                        self.obstacle_map[ix][iy] = True\n                        break\n\n    @staticmethod\n    def get_motion_model():\n        # dx, dy, cost\n        motion = [[1, 0, 1],\n                  [0, 1, 1],\n                  [-1, 0, 1],\n                  [0, -1, 1],\n                  [-1, -1, math.sqrt(2)],\n                  [-1, 1, math.sqrt(2)],\n                  [1, -1, math.sqrt(2)],\n                  [1, 1, math.sqrt(2)]]\n\n        return motion\n\n\ndef main():\n    # start and goal position\n    sx = -5.0  # [m]\n    sy = -5.0  # [m]\n    gx = 50.0  # [m]\n    gy = 50.0  # [m]\n    grid_size = 2.0  # [m]\n    robot_radius = 1.0  # [m]\n\n    # set obstacle positions\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)\n        oy.append(-10.0)\n    for i in range(-10, 60):\n        ox.append(60.0)\n        oy.append(i)\n    for i in range(-10, 61):\n        ox.append(i)\n        oy.append(60.0)\n    for i in range(-10, 61):\n        ox.append(-10.0)\n        oy.append(i)\n    for i in range(-10, 40):\n        ox.append(20.0)\n        oy.append(i)\n    for i in range(0, 40):\n        ox.append(40.0)\n        oy.append(60.0 - i)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(ox, oy, \".k\")\n        plt.plot(sx, sy, \"og\")\n        plt.plot(gx, gy, \"xb\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n\n    dijkstra = Dijkstra(ox, oy, grid_size, robot_radius)\n    rx, ry = dijkstra.planning(sx, sy, gx, gy)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(rx, ry, \"-r\")\n        plt.pause(0.01)\n        plt.show()\n\n\nif __name__ == '__main__':\n    main()\n~~~\n\n{% raw %}\n\n<iframe src=\"//player.bilibili.com/player.html?aid=928506879&bvid=BV1yT4y1T7Eb&cid=292534601&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n{% endraw %}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["机器人"]},{"title":"文献阅读笔记1","url":"/2021/07/15/文献阅读笔记1/","content":"\n## 基于高分二号卫星的牡蛎养殖区域识别\n\n\n\n本研究基于复杂近岸水域养殖网箱的光谱和地理空间特征，提出了一种利用0.8m空间分辨率的高分二号(GF-2)卫星图像提取养殖区域的新方法。\n\n\n\n通过高分二号图像反演得到旋沙浓度将水体分为清水、中浊度和高浊度三种。\n\n针对这三类水体，分别制定了不同的提取规则：\n\n1. 一是对清水设定归一化差分水体指数阈值\n2. 二是对中度浑浊水体建立比值指数($R=\\text{Green}/\\text{NIR}$)\n3. 三是对混浊水体建立特定分类规则的特征分析。\n\n\n\n实验前，对GF-2卫星图像进行了图像裁剪、正射校正、辐射定标和大气校正等预处理。为了后续的实验分析，还进行了图像融合。\n\n![](https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/4609443/8994817/9174629/zhang5-3016823-large.gif)\n\n\n\n## 实验步骤\n\n### SSC反演与浑浊度分类\n\n反演算法的公式如下：\n$$\n\\operatorname{SSC} = 1.4856\\times(\\operatorname{B3}/\\operatorname{B2})-1.1129\n$$\n在公式中，B2和B3分别是红波段和绿波段的反射率。\n\n根据反演的SSC将海水分为$3$类：清水(SSC为$0\\sim0.33g/L$)、中浊水(SSC为$0.33\\sim0.46g/L$)和浊水(SSC$>0.46g/L$)。\n\n### 水产养殖区提取规则\n\n清水：在清水中，每个笼子的边界和纹理清晰可见。利用近红外波段和绿色波段吸收和反射特性的差异，采用归一化水体指数(NDWI)提取养殖网箱。反复调整NDWI提取阈值，最终确定为$0.221$。\n\n\n\n中浊度水：在中浊度水域，浮筏的能见度受SSC的影响很大。只能辨认出几条条纹和模糊的笼子轮廓，看不到水体和笼子之间的清晰边缘。因此，为了提高水产养殖区提取的准确性，采用了具有光谱比的特征指数。根据中等浊度水中网箱的光谱特征（下图）和前人研究中构建的比值指数，选择绿色波段和近红外波段来建立比值指数:\n$$\nR = \\operatorname{B2}/\\operatorname{B4}\n$$\n在该公式中，$R$是比值指数，B2和B4分别是绿色波段($500nm\\sim560nm$)和近红外波段($780\\sim2526$)的反射率。确定$R$的阈值为$1.541$。\n\n![](https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/4609443/8994817/9174629/zhang7-3016823-large.gif)\n\n\n\n高浊度水：在高浊度水中，在GF-2卫星图像上几乎看不到养殖区。浑浊水与养殖区的差异很小，不可能用NDWI或比值指数($R$)从水中提取网箱。因此，建立了基于形状、纹理和光谱信息的规则，如下表\n\n![](https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/4609443/8994817/9174629/zhang.t2-3016823-large.gif)\n\n### 分割\n\n本研究利用`Envi`的特征提取(`FX`)模块进行多尺度分割。\n\n通常，分割和合并级别的选择与目标特征的规模相关，目标特征的规模决定了对象的最大允许异质性。实验开始时，设定了中等水平(即$50$分)作为参考。由于养殖区的提取比水体的提取更为复杂，因此在$50-100$的范围内确定了最佳的规模水平。合并级别略大于相应的比例级别。尺度水平和合并水平通过二分法进行测试，最高可达$100$。最后，比例级别设置为$65$，合并级别设置为$70$，纹理内核大小默认为$3$。\n\n### 养殖区提取\n\n此外，还利用ArcGIS软件中的创建随机点工具对提取结果进行了客观的定量评估。\n","tags":["paper"]},{"title":"只争朝夕，不负韶华","url":"/2021/07/13/index/","content":"\n{% meting \"33378114\" \"netease\" \"song\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %}\n\n<img src=\"https://cdn.jsdelivr.net/gh/HFC666/image@master/20210713/3.178msyh9rg68.png\" style=\"zoom:80%;\" />\n\n\n\n> 现状是没那么容易改变的\n> 即便是足够努力\n> 也很难在短时间内看出效果\n> 所以有时你认为的无法改变\n> 也可能只是暂时没看出效果而己\n> 而不是不够努力\n\n<img src=\"https://cdn.jsdelivr.net/gh/HFC666/image@master/20210713/4.36iwffkaky00.png\" style=\"zoom:80%;\" />\n\n\n\n> 不能再浑浑噩噩\n> 如果不把眼皮用力抬起看个真切\n> 或许就会错过人生中按下快门的良机\n\n\n\n**即使是一个人，也需要好好吃饭，这是治愈自己的一种方式**\n\n\n\n“不被时间和社会所束缚，幸福的填饱肚子，短时间内变得随心所欲，变得自由，不被打扰；毫不费神的吃东西的这种孤高行为，是现代人，都平等的拥有的最高治愈。”\n\n{% raw %}\n\n<div>\n<iframe src=\"//player.bilibili.com/player.html?\taid=73923411&bvid=BV1AE411a7Nw&cid=126453908&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n\n{% endraw %}\n\n\n\n\n\n\n\n"}]