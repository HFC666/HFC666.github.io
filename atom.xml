<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>独自赏晴雨</title>
  
  
  <link href="https://www.hfcouc.work/atom.xml" rel="self"/>
  
  <link href="https://www.hfcouc.work/"/>
  <updated>2022-07-25T22:35:52.631Z</updated>
  <id>https://www.hfcouc.work/</id>
  
  <author>
    <name>Han Fangcheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论课程第二周</title>
    <link href="https://www.hfcouc.work/2022/07/26/alo2/"/>
    <id>https://www.hfcouc.work/2022/07/26/alo2/</id>
    <published>2022-07-25T22:31:19.000Z</published>
    <updated>2022-07-25T22:35:52.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p align="center">    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp2.itc.cn%2Fimages01%2F20200915%2Fcd3178c68249454aa8e8206ed7626cb6.jpeg&refer=http%3A%2F%2Fp2.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661380513&t=cc08b97050020b95b97750370a407272" style="zoom: 100%;" /></p><blockquote><p>课程链接：<a href="https://ocw.mit.edu/6-006S20">https://ocw.mit.edu/6-006S20</a></p></blockquote><span id="more"></span><h2 id="Sets-and-Sorting"><a href="#Sets-and-Sorting" class="headerlink" title="Sets and Sorting"></a>Sets and Sorting</h2><h3 id="Set-interface"><a href="#Set-interface" class="headerlink" title="Set interface"></a>Set interface</h3><ul><li>包含具有唯一键的元素</li><li>一般我们令键为元素本身，但是也可能存储更多的信息</li><li>支持的操作<ul><li>Container<ul><li><code>build(X)</code>：给定可迭代的$X$，用$X$中的元素构建序列</li><li><code>len()</code>：返回排列好的元素的个数</li></ul></li><li>Dynamic：<ul><li><code>insert(x)</code>：将$x$添加到集合(如果<code>x.key</code>已经存在则替换即可)</li><li><code>delete(k)</code>：删除并返回键为<code>k</code>的元素</li></ul></li><li>Order<ul><li><code>iter_ord()</code>：以键的顺序返回排列好的元素</li><li><code>find_min()</code>：找到键最小的元素</li><li><code>find_max()</code>：找到键最大的元素</li><li><code>find_next(k)</code>：找到键比<code>k</code>大的最小的键对应的元素</li><li><code>find_prev(k)</code>：找到键比<code>k</code>小的最大的键对应的元素</li></ul></li></ul></li><li>特殊的接口：字典</li><li>将元素以任意的顺序排列可以实现一个集合(不是很高效)</li><li>将元素以键升序来排列<ul><li>更快找到<code>min/max</code></li><li>更快通过二分法找到元素$\mathcal{O}(\log n)$<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/set1.jpg" alt=""></li></ul></li></ul><blockquote><p>构建的复杂度为$n\log n$是因为我们在构建的过程中需要排序，对一个元素排序的复杂度为$\log n$，$n$个为$n\log n$。寻找元素即采用二分法，时间复杂度为$\log n$，插入删除元素既涉及寻找元素有涉及元素插入或删除后的移位，复杂为$\log n+n=n$，找到下一个和上一个元素的复杂度与找到某个元素相同，为$\log n$。</p></blockquote><p>那么下面我们关心的就是如何进行排序了：<br>排序</p><ul><li>输入：具有$n$个元素/键的数组(array)$A$</li><li>输出：对$A$进行排序后得到的数组$B$</li><li>排序为destructive的如果它重写$A$，既并没有创建新的数组，$B$只是$A$的排序版本</li><li>排序为in place的如果它利用$\mathcal{O}(1)$额外的空间(如创建循环时的临时变量)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorted_Array_Set</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A = Array_Seq()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.A)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_order</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, X</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A.build(X)</span><br><span class="line"></span><br><span class="line">        self._sort()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_sort</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_binary_search</span>(<span class="params">self, k, i, j</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        m = (i + j) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        x = self.A.get_at(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key &gt; k: <span class="keyword">return</span> self._binary_search(k ,i ,m-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key &lt; k: <span class="keyword">return</span> self._binary_search(k, m+<span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_min</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; <span class="number">0</span>: <span class="keyword">return</span> self.A.get_at(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; <span class="number">0</span>: <span class="keyword">return</span> self.A.get_at(<span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) ==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key == k: <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key &gt; k:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(self): <span class="keyword">return</span> self.A.get_at(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_prev</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = self.A.get_at(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x.key &lt; k:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(self): <span class="keyword">return</span> self.A.get_at(i-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            self.A.insert_first(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            i = self._binary_search(x.key, <span class="number">0</span>, <span class="built_in">len</span>(self.A)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            k = self.A.get_at(i).key</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k == x.key:</span><br><span class="line"></span><br><span class="line">                self.A.set_at(i, x)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k &gt; x.key: self.A.insert_at(i, x)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>: self.A.insert_at(i+<span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        i = self._binary_search(k, <span class="number">0</span>, <span class="built_in">len</span>(self.A) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> self.A.get_at(i).key == k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.A.delete_at(i)</span><br></pre></td></tr></table></figure><h3 id="Permutation-Sort"><a href="#Permutation-Sort" class="headerlink" title="Permutation Sort"></a>Permutation Sort</h3><ul><li>存在$A$的$n!$种排列，其中一个是排列好的顺序</li><li>对于每一个排列，查看其是否排列好的复杂度为$\Theta(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation_sort</span>(<span class="params">A</span>):</span></span><br><span class="line"><span class="keyword">for</span> B <span class="keyword">in</span> permutations(A):</span><br><span class="line"><span class="keyword">if</span> is_sorted(B):</span><br><span class="line"><span class="keyword">return</span> B</span><br></pre></td></tr></table></figure><p>时间复杂为$\Omega(n!\cdot n)$，为指数级的。</p><h3 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h3><ul><li>找到A[:i+1]中最大的数并将其放到A[i]中</li><li>递归地对A[:i]进行排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">A, i=<span class="literal">None</span></span>)   # <span class="title">T</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="title">i</span> <span class="title">is</span> <span class="title">None</span>:</span> i = <span class="built_in">len</span>(A) - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>:                    <span class="comment"># O(1)</span></span><br><span class="line">j = prefix_max(A, i)  <span class="comment"># S(i)</span></span><br><span class="line">A[i], A[j] = A[j], A[i]</span><br><span class="line">selection_sort(A, i-<span class="number">1</span>)   <span class="comment"># T(i-1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prefix_max</span>(<span class="params">A, i</span>):</span>            <span class="comment"># S(i)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>:                    <span class="comment"># O(1)</span></span><br><span class="line">j = prefix_max(A, i-<span class="number">1</span>)   <span class="comment"># S(i-1)</span></span><br><span class="line"><span class="keyword">if</span> A[i] &lt; A[j]:          <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">return</span> j             <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">return</span> i                     <span class="comment"># O(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们来分析一下<code>prefix_max</code>函数：</p><ul><li>Base case：对于$i=0$，数组有一个元素，所以最大的索引为$i$</li><li>归纳：假设对于$i$是正确的，最大的要么是A[:i]中的要么是A[i]，返回最大的索引</li><li>$S(1)=\Theta(1), S(n) = S(n-1)+\Theta(1)$<ul><li>替换：$S(n)=\Theta(n), cn=\Theta(1)+c(n-1)\Rightarrow 1 = \Theta(1)$<br>再分析一下<code>selection_sort</code>函数：</li></ul></li><li>Base case：对于$i=0$，数组含有一个元素，因此是排列好的</li><li>归纳：假设对于$i$是正确的，排列好的输出的最后一个元素为数组的最大的元素，并且算法将其放在那里；则A[:i]是排列好的</li><li>$T(1)=\Theta(1), T(n) = T(n-1)+\Theta(n)$<ul><li>替换：$T(n)=\Theta(n^2),cn^2=\Theta(n)+c(n-1)^2\Rightarrow c(2n-1)=\Theta(n)$</li></ul></li></ul><blockquote><p>步骤为先把全部$n$个元素的最大值挑出来放在最后面，之后将剩余的$n-1$个元素的最大值挑出来放在$n-1$位置，递归下去</p></blockquote><h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><ul><li>递归地排列A[:i]</li><li>排列A[:i+1]假设A[:i]已经通过重复地交换排列好了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">A, i = <span class="literal">None</span></span>):</span>       <span class="comment"># T(i)</span></span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">is</span> <span class="literal">None</span>: i = <span class="built_in">len</span>(A) - <span class="number">1</span>       <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span>:                          <span class="comment"># O(1)</span></span><br><span class="line">insertion_sort(A, i-<span class="number">1</span>)         <span class="comment"># T(i-1)</span></span><br><span class="line">insert_last(A, i)              <span class="comment"># S(i)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_last</span>(<span class="params">A, i</span>):</span>                 <span class="comment"># S(i)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &lt; A[i-<span class="number">1</span>]:        <span class="comment"># O(1)</span></span><br><span class="line">A[i], A[i-<span class="number">1</span>]  = A[i-<span class="number">1</span>], A[i]   <span class="comment"># O(1)</span></span><br><span class="line">insert_last(A, i-<span class="number">1</span>)            <span class="comment"># S(i-1)</span></span><br></pre></td></tr></table></figure><p>先分析一下<code>insert_last</code>函数：</p><ul><li>Base case：对于$i=0$，数组只有一个元素所以是排列好的</li><li>归纳：假设对于$i$是正确的，如果A[i] &gt;= A[i-1]，数组是排列好的；否则交换后两个元素</li><li>$S(1) = \Theta(1), S(n)=S(n-1)+\Theta(1)\Rightarrow S(n)=\Theta(n)$<br>之后分析一下<code>insertion_sort</code>函数：</li><li>Base case：对于$i=0$，数组只有一个元素因此是排列好的</li><li>归纳：假设对于$i$时正确，算法通过归纳排列A[:i]，之后<code>insert_last</code>正确地排列剩余的部分</li><li>$T(1)=\Theta(1), T(n) = T(n-1)+\Theta(n)\Rightarrow T(n) = \Theta(n^2)$</li></ul><blockquote><p>总的思路就是先排列好前$i$个数据，之后通过逐次比较将下一个元素插入正确的位置来排列第$i+1$个元素。</p></blockquote><p>选择排序和插入排序都是<code>in place</code>排序，意味着它们需要至多常数复杂度的额外空间。而插入排序是稳定的，即再处理具有相同值的排序时相同值的原有顺序不变，而选择排序是不稳定的。如在排列$[2,1,1^\prime]$，插入排序的结果为$[1,1^\prime,2]$，而选择排序的结果为$[1^\prime,1,2]$。</p><h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><ul><li>递归地排列前一半和后一半</li><li>将排列好的两半混合成一个排列好的列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">A, a = <span class="number">0</span>, b = <span class="literal">None</span></span>):</span>                  <span class="comment"># T(b - a = n)</span></span><br><span class="line"><span class="keyword">if</span>  b <span class="keyword">in</span> <span class="literal">None</span>: b = <span class="built_in">len</span>(A)                        <span class="comment"># O(1)</span></span><br><span class="line"> <span class="keyword">if</span> <span class="number">1</span> &lt; b - a :                                   <span class="comment"># O(1)</span></span><br><span class="line">c = (a + b + <span class="number">1</span>) // <span class="number">2</span>                         <span class="comment"># O(1)</span></span><br><span class="line">merge_sort(A, a, c)                          <span class="comment"># T(n/2)</span></span><br><span class="line">merge_sort(A, c, b)                          <span class="comment"># T(n/2)</span></span><br><span class="line">L, R = A[a:c], A[c:b]                        <span class="comment"># O(n)</span></span><br><span class="line">merge(L, R, A, <span class="built_in">len</span>(L), <span class="built_in">len</span>(R), a, b)         <span class="comment"># S(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">L, R, A, i, j, a, b</span>):</span>                            <span class="comment"># S(b - a = n)</span></span><br><span class="line"><span class="keyword">if</span> a &lt; b:                                              <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">if</span> (j &lt;= <span class="number">0</span>) <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] &gt; R[j - <span class="number">1</span>]):    <span class="comment"># O(1)</span></span><br><span class="line">A[b - <span class="number">1</span>] = L[i - <span class="number">1</span>]                            <span class="comment"># O(1)</span></span><br><span class="line">i = i - <span class="number">1</span>                                      <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">else</span>:                                              <span class="comment"># O(1)</span></span><br><span class="line">A[b - <span class="number">1</span>] = R[j - <span class="number">1</span>]                            <span class="comment"># O(1)</span></span><br><span class="line">j = j - <span class="number">1</span>                                      <span class="comment"># O(1)</span></span><br><span class="line">merge(L, R, A, i, j, a, b-<span class="number">1</span>)                       <span class="comment"># S(n-1)</span></span><br></pre></td></tr></table></figure><p>首先先分析一下merge函数：</p><ul><li>Base case：对于$n=0$，数组为空，因此排序正确</li><li>归纳：假设对于$i$是正确的，元素A[r]必须是L和R中最大的元素，并且因为它们是排列好的，取最大的元素递归地进行排序</li><li>$S(0) = \Theta(1),S(n)=S(n-1)+\Theta(1)\Rightarrow S(n)=\Theta(n)$<br>下面是<code>merge_sort</code>函数：</li><li>Base case：对于$n=1$，数组含有一个元素因此是排列好的</li><li>归纳：假设对于$k&lt;n$是正确的，算法通过归纳排列两个一半，之后将其混合成一个排列好的数组</li><li>$T(1) = \Theta(1), T(n)=2T(n/2)+\Theta(n)$</li><li>替换：假设$T(n)=\Theta(n\log n), cn\log n = \Theta(n) + 2c(n/2)\log(n/2)\Rightarrow cn\log(2) = \Theta(n)$<br>归并排序使用线性的额外空间，因此不是<code>in place</code>算法。</li></ul><h3 id="Recurrences"><a href="#Recurrences" class="headerlink" title="Recurrences"></a>Recurrences</h3><p>有三种方法来解决Recurrences(递归)问题：</p><ul><li>替换：猜测一个结果来替换证明递归成立</li><li>Recursion Tree：绘制树来表示递归将节点处的计算数求和</li><li>Master定理：一个解决大多数递归问题的通用公式。</li></ul><h4 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h4><p>给定下列形式的递归关系式：$T(n) = aT(n/b)+f(n)$并且$T(1)=\Theta(1)$，分支因子$a\ge1$，问题规模缩减因子$b&gt;1$并且渐进非负函数$f(n)$，Master Theorem通过比较$f(n)$和递归树底部的叶子数量$a^{\log_b^n}=n^{\log_b a}$来给出答案。当$f(n)$渐进增长速度大于$n^{\log_ba}$，在每一层做的工作呈几何下降因此根节点占主要地位；否则当$f(n)$增长缓慢，在每一个节点的工作量成几何增加因此每一层的工作占主导。<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/set2.jpg" alt=""></p><script type="math/tex; mode=display">\begin{array}{c|l|l}\text { case } & \text { solution } & \text { conditions } \\\hline 1 & T(n)=\Theta\left(n^{\log _{b} a}\right) & f(n)=O\left(n^{\log _{b} a-\varepsilon}\right) \text { for some constant } \varepsilon>0 \\\hline 2 & T(n)=\Theta\left(n^{\log _{b} a} \log ^{k+1} n\right) & f(n)=\Theta\left(n^{\log _{b} a} \log ^{k} n\right) \text { for some constant } k \geq 0 \\\hline 3 & T(n)=\Theta(f(n)) & f(n)=\Omega\left(n^{\log _{b} a+\varepsilon}\right) \text { for some constant } \varepsilon>0 \\& & \text { and } a f(n / b)<c f(n) \text { for some constant } 0<c<1\end{array}</script><p>Master Theorem当$f(n)$为多项式时可以简化，也就是递归的形式为$T(n)=aT(n/b)+\Theta(n^c),c\ge0$。</p><script type="math/tex; mode=display">\begin{array}{c|l|l|l}\text { case } & \text { solution } & \text { conditions } & \text { intuition } \\\hline 1 & T(n)=\Theta\left(n^{\log _{b} a}\right) & c<\log _{b} a & \text { Work done at leaves dominates } \\\hline 2 & T(n)=\Theta\left(n^{c} \log n\right) & c=\log _{b} a & \text { Work balanced across the tree } \\\hline 3 & T(n)=\Theta\left(n^{c}\right) & c>\log _{b} a & \text { Work done at root dominates }\end{array}</script><p>练习：<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/set3.jpg" alt=""></p><h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><p>Comparison Model：</p><ul><li>在这个模型中，假设算法只能通过比较来区分元素</li><li>Comparable items：只支持元素对之间比较的黑盒</li><li>比较为$&lt;,\le,&gt;,\ge,=,\neq$，输出是二元的：正确或错误</li><li>目标：存储$n$个可比较的元素，支持<code>find(k)</code>操作</li><li>运行时间以比较的表现为下界，因此数比较的次数</li></ul><p>Decision Tree：</p><ul><li>任何算法都可以被看作是一个决策树</li><li>内部的一个节点可以被看作一个二元比较，分支为True或False</li><li>对于一个比较算法，决策树是二元的</li><li>一个叶子表示算法终止，产生算法的输出</li><li>一个根节点到叶子节点的路径表示在某些输入上算法的执行</li><li>对每一个算法输出至少有一个节点，因此需要至少$\ge n+1$叶子节点(包含不存在)</li></ul><p>Comparison Search Lower Bonud</p><ul><li>比较查询算法(comparison search algorithm)最差情况下的运行时间是什么？</li><li>运行时间$\ge$比较$\ge$任何从根节点到叶子节点路径最大的长度$\ge$树的长度</li><li>任何节点数$\ge n$的二元树的最小高度是多少？</li><li>长度$\ge [\log (n+1)]-1=\Omega(\log n)$，因此任何比较排序的运行时间为$\Omega(\log n)$。</li><li>排序数组可以达到这个界限。</li><li>更一般地，叶子数为$\Theta(n)$和最大分支因子为$b$的树的长度为$\Omega(\log_b n)$。</li><li>为了更快，我们需要一个允许super-constant $w(1)$分支因子的操作，不过要怎么办？</li></ul><p>Direct Access Array</p><ul><li>利用Word-RAM $\mathcal{O}(1)$时间复杂度获取索引，线性的分支因子。</li><li>给定元素唯一整数键$k\in \{0,\cdots,u-1\}$，将其存储在一个数组中，索引为$k$</li><li>如果键可以存储在一个机器字节中，即$u\le 2^w$，最差$\mathcal{O}(1)$获取元素</li><li>但是空间$\mathcal{O}(u)$，当$n\ll u$时会很糟糕</li><li>例如如果键位十个字母的名字，如果一个比特一个名字，需要$26^{10}\approx 17.6$ TB空间</li><li>如何使用更少的空间呢？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectAccessArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, u</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A = [<span class="literal">None</span>] * u</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.A[k]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A[x.key] = x</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">        self.A[k] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_next</span>(<span class="params">self, k</span>):</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(self.A)):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.A[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> self.A[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.A)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.A[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> self.A[i]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_max</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.A)):</span><br><span class="line"></span><br><span class="line">            x = self.A[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">                self.A[i] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>Hashing</p><ul><li>如果$n\ll u$，将键映射到小范围$m=\Theta(n)$并且使用小的direct access array</li><li>哈希函数：$h(k):\{0,\cdots, u-1\rightarrow \{0,\cdots,m-1\}$(也被称为哈希映射)</li><li>Direct access array 称为哈希表，$h(k)$被称为键$k$的哈希</li><li>如果$m\ll u$，根据鸠巢原理，没有哈希函数是单射的</li><li>总是存在键$a\neq b$使得$h(a)=h(b)$：冲突了(Collision)</li><li>不能将不同的元素存储在相同的索引处，所以存储在哪呢？要么：<ul><li>存储在数组中的其他位置(open addressing)：分析比较复杂，但是普遍和实用</li><li>存储在支持动态集合接口的其他数据结构中(chaining)</li></ul></li></ul><p>Chaining</p><ul><li>将冲突存储在另一个数据结构中(a chain)</li><li>如果键大致均匀地分布在索引上，链的大小为$n/m=n/\Omega(n)=\mathcal{O}(1)$</li><li>如果链的大小为$\mathcal{O}(1)$，则所有的操作需要$\mathcal{O}(1)$时间！</li><li>如果不是，许多元素映射到同一个位置，即$h(k)=\text{constant}$，链大小为$\Theta(n)$</li><li>需要好的哈希函数，但是什么是好的哈希函数呢？</li></ul><p>Hash Functions</p><ul><li>Division(bad)：$h(k) = (k \text{ mod }m)$<ul><li>当键是均匀分布的话很好</li><li>$m$对于存储的键应该避免对称</li><li>大于$2,10$的幂的大素数可以</li><li>Python实用加有一个混合的Division的一个版本</li><li>如果$u\gg n$，每一个哈希函数将有相同的产生$\mathcal{n}$长度链的输入</li><li>不要用固定的哈希函数。随机抽选一些(但是要小心)</li></ul></li><li>Universal(good, theoretically)：$h_{ab}(k)=(((ak+b)\text{ mod }p)\text{ mod }m)$<ul><li>哈希族$\mathcal{H}(p,m) = \{h_{ab}\mid a,b\in \{0,\cdots,p-1\} \text{ and }a\neq 0\}$</li><li>通过一个固定的素数$p&gt;u$进行参数化，其中$a,b$选自$\{0,1,\cdots,p-1\}$</li><li>$\mathcal{H}$为Universal family：$\Pr_{h\in\mathcal{H}}\{h(k_i)=h(k_j)\}\le 1/m\quad \forall k_i\neq k_j\in \{0,\cdots,u-1\}$</li><li>为什么universality是有用的呢？它暗示了短的链的长度(期望)</li><li>$X_{ij}$指示随机变量在$h\in\mathcal{H}: X_{ij}=1\text{ if }h(k_i)=h(k_j),X_{ij}=0\text{ otherwise}$</li><li>在索引$h(k_i)$处的链的长度为随机变量$X_i=\sim_j X_{ij}$</li><li>在索引$h(k_i)$处链的期望长度：</li></ul></li></ul><script type="math/tex; mode=display">\begin{aligned}\underset{h \in \mathcal{H}}{\mathbb{E}}\left\{X_{i}\right\}=\underset{h \in \mathcal{H}}{\mathbb{E}}\left\{\sum_{j} X_{i j}\right\}=\sum_{j} \underset{h \in \mathcal{H}}{\mathbb{E}}\left\{X_{i j}\right\} &=1+\sum_{j \neq i} \underset{h \in \mathcal{H}}{\mathbb{E}}\left\{X_{i j}\right\} \\&=1+\sum_{j \neq i}(1) \operatorname{Pr}_{h \in \mathcal{H}}\left\{h\left(k_{i}\right)=h\left(k_{j}\right)\right\}+(0) \underset{h \in \mathcal{H}}{\operatorname{Pr}}\left\{h\left(k_{i}\right) \neq h\left(k_{j}\right)\right\} \\& \leq 1+\sum_{j \neq i} 1 / m=1+(n-1) / m\end{aligned}</script><ul><li>因为$m = \Omega(n)$，所以上面得到的结果为$1+(n-1)/m=\mathcal{O}(1)$，所以期望为$\mathcal{O}(1)$</li></ul><p>Dynamic</p><ul><li>如果$n/m$远大于$1$，用随机选择的新的哈希函数重新构建新的大小$m$</li><li>与动态数组的分析方法一致，cost可以在很多动态操作上分摊(amortized)</li><li>因此一个哈希表可以以期望$\mathcal{O}(1)$的分摊时间来实现动态集合操作</li></ul><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/set4.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp2.itc.cn%2Fimages01%2F20200915%2Fcd3178c68249454aa8e8206ed7626cb6.jpeg&amp;refer=http%3A%2F%2Fp2.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1661380513&amp;t=cc08b97050020b95b97750370a407272&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;课程链接：&lt;a href=&quot;https://ocw.mit.edu/6-006S20&quot;&gt;https://ocw.mit.edu/6-006S20&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="编程" scheme="https://www.hfcouc.work/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法导论课程第一周</title>
    <link href="https://www.hfcouc.work/2022/07/19/alo1/"/>
    <id>https://www.hfcouc.work/2022/07/19/alo1/</id>
    <published>2022-07-19T06:53:32.000Z</published>
    <updated>2022-07-25T22:34:21.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p align="center">    <img src="https://img2.baidu.com/it/u=3208607819,4065748703&fm=253&fmt=auto&app=138&f=PNG?w=670&h=500" style="zoom: 100%;" /></p><blockquote><p>课程链接：<a href="https://ocw.mit.edu/6-006S20">https://ocw.mit.edu/6-006S20</a></p></blockquote><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本课程的目的是教你去解决计算问题，同时证明的解决方案是正确和搞笑的。<br>问题：</p><ul><li>从问题输入到正确输出的二元关系</li><li>提供正确输出必须满足的条件</li><li>非一般情况：<ul><li>例子：在这个房间里，有生日一样的同学吗</li></ul></li><li>一般情况：<ul><li>例子：给定任意$n$个学生，有没有生日相同的同学<br>算法</li></ul></li><li>将每个输入映射到单个(确定)输出的过程</li><li>算法解决了问题当对于每一个问题输入他都能返回正确的输出</li><li>例子：一个解决生日匹配的算法<ul><li>保存生日和姓名的记录(初始为空)</li><li>以一种顺序采访每一位同学<ul><li>如果生日存在在记录中，返回找到了匹配队</li><li>否则将生日和姓名添加到记录中</li></ul></li><li>返回空如果最后一个通过也没有匹配成功</li></ul></li></ul><p>正确性：</p><ul><li>程序/算法有固定的大小，所以如何证明其正确性</li><li>对于小的输入，可以分析例子</li><li>对于任意大的输入，算法必须是可以递归或循环的</li><li>必须使用归纳(induction)</li><li>例子：证明生日匹配算法的正确性<ul><li>在$k$上归纳：记录的同学的人数</li><li>假设(Hypothesis)：如果前$k$个存在匹配，在采访第$k+1$个学生之前返回匹配</li><li>Base case：$k=0$时，$k$没有包含匹配</li><li>假设归纳假设对于$k=k^\prime$成立，考虑$k^\prime+1$</li><li>如果前$k^\prime$个存在一个匹配，那么在归纳之前就已经返回了</li><li>如果前$k^\prime$没有匹配，因此如果前$k^\prime+1$个存在匹配，匹配包括$k^\prime+1$</li><li>算法直接检查学生$k^\prime+1$在是否在前$k^\prime$出现</li></ul></li></ul><p>效率(Efficiency)：</p><ul><li>一个算法产生一个正确输出有多快<ul><li>可以衡量时间，但是时间与机器的性能有关</li><li>可以衡量具有固定时间操作的个数</li><li>与输入大小有关系：越大说明需要更长时间</li><li>是高效的如果是输入大小的多项式函数</li><li>有些时候对于某个问题不存在高效的算法</li></ul></li><li>渐进符号：忽略常数项和低阶项<ul><li>上界$\mathcal{O}$，下界$\Omega$，严格界限$\Theta$</li><li>以下时间估计基于<code>1GHz</code>单核机器上每个周期的一次操作</li></ul></li></ul><script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|c|}\hline \text { input } & \text { constant } & \text { logarithmic } & \text { linear } & \text { log-linear } & \text { quadratic } & \text { polynomial } & \text { exponential } \\\hline n & \Theta(1) & \Theta(\log n) & \Theta(n) & \Theta(n \log n) & \Theta\left(n^{2}\right) & \Theta\left(n^{c}\right) & 2^{\Theta\left(n^{c}\right)} \\\hline 1000 & 1 & \approx 10 & 1000 & \approx 10,000 & 1,000,000 & 1000^{c} & 2^{1000} \approx 10^{301} \\\hline \text { Time } & 1 n s & 10 n s & 1 \mu s & 10 \mu s & 1 m s & 10^{3 c-9} s & 10^{281} \text { millenia } \\\hline\end{array}</script><p>计算模型：</p><ul><li>说明可以在$\mathcal{O}(1)$时间内在机器上执行哪些操作</li><li>这类模型被称为<code>Word-RAM</code></li><li>Machine word：$w$位的一个块($w$为一个$w$-bit Word-RAM的字长)</li><li>Memory：可以寻址的字长序列</li><li>处理器支持很多常数时间的操作，在$\mathcal{O}(1)$字数<ul><li>正数算数：$+,-,<em>,//,\%</em>$</li><li>逻辑运算：<code>`&amp;&amp;，||，!，==，&lt;,&gt;,&lt;=,=&gt;</code></li><li>比特算数：<code>&amp;,|,&lt;&lt;,&gt;&gt;</code></li><li>给定word$a$，可以在读取地址$a$的字，写数据到地址$a$</li></ul></li><li>内存地址必须可以访问在内存中的任何位置<ul><li>需要$w\ge$表示最大内存地址的位数</li><li>$32$位的最大为$4$GB内存，$64$位的最大为$16$EB</li></ul></li></ul><p>数据结构</p><ul><li>数据结构是存储无限值数据的一种方式，并支持一系列操作</li><li>一系列操作的集合被称为接口(interface)<ul><li>序列</li><li>集合</li></ul></li><li>数据结构可能使用不同的方法实现相同的接口</li><li>例子：静态列表：固定长度，静态序列接口<ul><li>StaticArray(n)：分配大小为$n$的静态数组以$\Theta(n)$的时间</li><li>StaticArray.get_at(i)：返回索引为$i$的数据以$\Theta(1)$的时间</li><li>StaticArray.set_at(i,x)：将索引为$i$的位置写入数据$x$以$\Theta(1)$的时间</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">birthday_match</span>(<span class="params">students</span>):</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Find a pair of students with the same birthday</span></span><br><span class="line"><span class="string">Input: tuple of student(name, bday) tuples</span></span><br><span class="line"><span class="string">Output: tuple of student names or None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">n = <span class="built_in">len</span>(students)         <span class="comment">#O(1)</span></span><br><span class="line">record = StaticArray(n)   <span class="comment"># O(n)</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):        <span class="comment"># n</span></span><br><span class="line">(name1, bay1) = students[k] <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):    <span class="comment"># k</span></span><br><span class="line">(name2, bday2) = record.get_at(i)   <span class="comment">#O(1)</span></span><br><span class="line"><span class="keyword">if</span> bday1 == bday2:       <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">return</span> (name1, name2)</span><br><span class="line">record.set_at(k ,(name1, bday1))    <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>时间复杂度为：</p><script type="math/tex; mode=display">O(n) + \sum_{k=0}^{n-1}(O(1)+k\cdot O(1)) = O(n^2)</script><p>为$n$的多项式函数，所以该算法是高效的。</p><h3 id="Asymptotic-Notation"><a href="#Asymptotic-Notation" class="headerlink" title="Asymptotic Notation"></a>Asymptotic Notation</h3><p>下面我们详细地说明一下渐进符号：<br>$O(f(n))$表示定义域为自然数满足下列性质的函数的集合：<br>$O$符号：非负函数$g(n)$属于$O(f(n))$当且仅当存在正实数$c$和正整数$n_0$使得对于所有的$n\ge n_0$都有$g(n)\le c\cdot f(n)$。<br>$\Omega$符号：非负函数$g(n)$属于$\Omega(f(n))$当且仅当存在正实数$c$和正整数$n_0$使得对于所有的$n\ge n_0$都有$c\cdot f(n)\le g(n)$。<br>$\Theta$符号：非复函数$g(n)$属于$\Theta(f(n))$当且仅当$g(n)\in O(f(n))\cap \Omega(f(n))$。</p><h2 id="DATA-STRUCTURES-AND-DYNAMIC-ARRAYS"><a href="#DATA-STRUCTURES-AND-DYNAMIC-ARRAYS" class="headerlink" title="DATA STRUCTURES AND DYNAMIC ARRAYS"></a>DATA STRUCTURES AND DYNAMIC ARRAYS</h2><p>首先我们先区分一下接口(Interface(API/ADT))和数据结构(Data Structure)。<br>接口相当于是规范，他告诉我们可以存储什么样的数据，而数据结构会给你一个实际的表示(representation)来告诉你如何去存储数据。接口告诉我们支持什么样的操作，数据结构给我们实现这些操作的算法。你可以把结构理解为问题，而数据结构则是解决方案。</p><p>我们将会讨论两类重要的接口：</p><ul><li>集合(set)</li><li>序列(sequence)<br>我们也将会讨论两个主要的数据结构的工具：</li><li>数组(arrays)</li><li>基于指针的(pointer based)</li></ul><h3 id="Static-sequence-interface"><a href="#Static-sequence-interface" class="headerlink" title="Static sequence interface"></a>Static sequence interface</h3><p>static sequence interface：存储序列$x_0,x_1,\cdots,x_{n-1}$，并且支持以下操作：</p><ul><li>build(X)：对$X$中的元素创建一个新的数据结构</li><li>len(X)：返回$X$的长度$n$</li><li>iter_seq()：以序列的顺序输出$x_0,x_1,\cdots,x_{n-1}$</li><li>get_at(i)：或者$X$中索引为$i$的$x_i$</li><li>set_at(i,X)：将$x_i$设置为$x$<br>解决这一问题的数据结构我们称为static array：数组中的数据在内存中的存储是连续的。这就意味着当我们访问数组中的某个索引的元素就等价于访问内存中数据的初始位置加上元素在数组中内存的索引的位置。同时我们假设对数组数据访问花费的时间是常数（这要求机器的字节数(现在一般为$64$位，可以一次读取$2^{64}$字节的数据)$w\ge \log n$）。也就意味着我们在<code>get_at</code>、<code>len</code>和<code>set_at</code>操作花费的时间是$\mathcal{O}(1)$，而在<code>build</code>和<code>iter_seq</code>操作花费时间为$\mathcal{O}(n)$。<br>我们是如何创建静态数组的呢？有很多的内存分配模型(Memory allocation model)：在这里我们假设分配一个长度为$n$的数组耗费的时间为$\mathcal{O}(n)$，这样还可以得到我们消耗的空间为$\mathcal{O}(\text{time})$。</li></ul><h3 id="Dynamic-sequence-interface"><a href="#Dynamic-sequence-interface" class="headerlink" title="Dynamic sequence interface"></a>Dynamic sequence interface</h3><p>他是静态数组加上下面几个操作：</p><ul><li>insert_at(i,x)：在索引$i$处插入$x$，后面的以此后移</li><li>deleta_at(i)：删除索引处$i$的数据，后面的依次前移</li><li>insert_first(x)：将x插入第一个位置</li><li>delete_first(x)：删除并返回第一个元素</li><li>insert_last(x)：将x添加到最后一个位置</li><li>delete_last(x)：删除并返回最后一个元素</li></ul><p>链表指的是前一个对象除了存储自己的数值外，还存储下一个对象的地址。静态数组指的是长度不会改变的数组。下面我们比较一下两者。<br>当我们在数组的第一个位置插入或删除元素时，静态列表需要所有的元素都向后或向前移动，耗费的时间复杂度为$\mathcal{O}(n)$，而由于静态数组的长度是不能变换的，所以在末尾添加元素需要我们将原有的数组重新复制一遍，耗费的时间复杂度为$\mathcal{O}(n)$；而链表在第一个位置插入元素只需要将头指针指向要插入的元素，将要插入的元素储存的地址指向原来的第一个元素的地址，删除第一个元素的话只需要将头指针指向第二个元素的地址，时间复杂度为$\mathcal{O}(1)$，但是当需要访问数据时，我们需要这个寻址，耗费的时间复杂度为$\mathcal{O}(n)$。<br>可以看出静态数组在非动态操作(查询元素等)的时间复杂度要比链表低，而链表的动态操作(插入、删除元素)的时间复杂度比较低，现在我们将两者擅长的操作结合在一起，即得到动态数组。</p><h3 id="Dynamic-arrays"><a href="#Dynamic-arrays" class="headerlink" title="Dynamic arrays"></a>Dynamic arrays</h3><p>动态数组在Python中即为列表(list)。<br>动态数组放松了数组大小必须为$n$的约束，我们令数组的大小为$\Theta(n)\ge n$。<br>动态数组的头包含了数组的首地址、存储的数据的数量和数组的大小，当我们在数组最后插入元素时，如果数组的大小还够，直接在后面插入即可，但是如果此时数组的大小正好等于数组中元素的大小，我们需要重新分配一个数组，其大小为原来的$2$倍或者其他，也可以为原来的大小$+5$，但是当我们这样做时，我们需要每$5$次都重新分配一次内存，但是相比较于静态数组每一次都要重新分配一下内存还是好的。<br>假设我们有一个空的动态列表，我们每一次往里面加入元素，第一次加入一个我们将去大小扩充为$1$，第二次加入元素，我们将其大小扩充为$2$，第三次加入元素我们将其扩充为$4$，第四次加入不扩充，第五次加入元素扩充为$8$，这样以此类推，那么对于长度的$n$的数组我们花费的时间复杂度为：</p><script type="math/tex; mode=display">\sum_{i=1}^{\log_2 n}2^i = \mathcal{O}(n)</script><p>可以看出其时间复杂度为线性的。我们将这种现象称为Amortization：如果任何$K$个操作耗费的时间复杂度$\le K\cdot T(n)$，那么每个操作的时间复杂度为$T(n)$。所以每次在最后面插入一个元素的时间复杂度为$\mathcal{O}(1)$。</p><p>所以我们最终的结果为：<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/alo1.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://img2.baidu.com/it/u=3208607819,4065748703&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=670&amp;h=500&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;课程链接：&lt;a href=&quot;https://ocw.mit.edu/6-006S20&quot;&gt;https://ocw.mit.edu/6-006S20&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="编程" scheme="https://www.hfcouc.work/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>B站课程Mathematica剩余部分</title>
    <link href="https://www.hfcouc.work/2022/07/18/math2/"/>
    <id>https://www.hfcouc.work/2022/07/18/math2/</id>
    <published>2022-07-18T06:58:49.000Z</published>
    <updated>2022-07-19T06:59:28.798Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p align="center">    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F13376661231%2F641&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660719664&t=7a06182fcd2599240cf9b86397be591b" style="zoom: 100%;" /></p><blockquote><p> B站课程链接：<a href="https://www.bilibili.com/video/BV1av411N7Xi?spm_id_from=333.999.0.0&amp;vd_source=6177c61c946280bb88c727585de76bc8">https://www.bilibili.com/video/BV1av411N7Xi?spm_id_from=333.999.0.0&amp;vd_source=6177c61c946280bb88c727585de76bc8</a></p></blockquote><span id="more"></span><h2 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h2><h3 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h3><p><code>Mathematica</code>的第二原理：计算即重写。所谓重写，即将匹配成功的模式改为其他形式。Mathematica就是由一大堆重写规则组成的。</p><p>重写规则的一般形式是：</p><p><code>(模式)    (重写符号)    (重写结果)</code></p><p>其中重写符号有四种：<code>-&gt;、:&gt;、=、:=</code>，分别叫做规则、延迟规则、赋值、延迟赋值。重写结果则是一个表达式，它可以依赖重写符号左边被命名的子模式。</p><p>规则与延迟规则是一种较为安全的重写机制，因为只有在你应用它们的时候它们才起作用。而赋值和延迟赋值则是添加到系统内部的一种重写规则，一旦添加进去就立刻起作用，并永远存在，除非你手动移除它们(<code>=.、Clear、Remove</code>)。</p><p>最常见的规则出现在<code>Solve</code>类函数的返回值中：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = Solve[x^<span class="number">3</span> - <span class="number">3</span> x + <span class="number">2</span> == <span class="number">0</span>, x]</span><br><span class="line">&#123;&#123;x -&gt; -<span class="number">2</span>&#125;, &#123;x -&gt; <span class="number">1</span>&#125;, &#123;x -&gt; <span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>Solve</code>的结果是不唯一的，<code>Mathematica</code>并不知道我们打算用哪一个，所以只好将它们存储为规则，我们可以从中挑选出我们想要的，然后将它应用在其他地方。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Expand</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">^</span><span class="number">4</span> <span class="operator">+</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="number">1</span> <span class="operator">/.</span> <span class="variable">result</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>我们也可以不挑选，这样得到一个由不同规则到来的结果构成的表。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expand[x^<span class="number">4</span> + x^<span class="number">2</span> + <span class="number">1</span> /. result]</span><br><span class="line">&#123;<span class="number">21</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>注意在上述操作时，<code>x</code>并未发生改变。</p><p>规则比赋值灵活，因为赋值是定义全局变量。全局变量一旦重命名就很容易造成程序错误。这是<code>Mathematica</code>中最常见的一类错误。为了避免这种错误才有了这种模块化的机制。</p><p>规则的左边可以是模式：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rule</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">g</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">rule</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">25</span> <span class="operator">+</span> <span class="variable">g</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>得到的结果与我们的期望一致，但是</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">rule = (f[x_] -&gt; x^<span class="number">2</span>);</span><br><span class="line">f[<span class="number">5</span>] + g[<span class="number">2</span>] /. rule</span><br><span class="line">&gt; <span class="number">1</span> + g[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>就会出现问题，这是因为规则直接将全局变量带入了，变成了：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rule</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是如果使用延迟规则：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">rule = f[x_] :&gt; x^<span class="number">2</span>;</span><br><span class="line">f[<span class="number">5</span>] + g[<span class="number">2</span>] /. rule</span><br><span class="line">&gt; <span class="number">25</span> + g[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>规则和延迟规则(以及赋值和延迟赋值)的区别在于：规则指向的表达式会被<code>Mathematica</code>立刻取值，以后应用这条规则时将直接引用这个值；而延迟规则指向的表达式会被<code>Mathematica</code>认为是一个程序的入口，之后每次应用这条规则时，<code>Mathematica</code>都会重新计算一边这个表达式。</p><p>当规则不止一条时，我们把所有规则组成一个表，然后应用它。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">(</span><span class="variable">a</span><span class="operator">^</span><span class="variable">b</span><span class="punctuation">)</span><span class="operator">^</span><span class="variable">c</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="punctuation">(</span><span class="type">x_</span><span class="operator">^</span><span class="type">y_</span><span class="punctuation">)</span><span class="operator">^</span><span class="type">z_</span> <span class="operator">:&gt;</span> <span class="variable">x</span><span class="operator">^</span><span class="punctuation">(</span><span class="variable">y</span> <span class="variable">z</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">a</span> <span class="operator">-&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="variable">b</span> <span class="operator">-&gt;</span> <span class="number">3</span><span class="operator">,</span> <span class="variable">c</span> <span class="operator">-&gt;</span> <span class="number">4</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">a</span><span class="operator">^</span><span class="punctuation">(</span><span class="variable">b</span> <span class="variable">c</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>我们发现只应用了第一个规则，其他规则都没用。这是因为匹配到规则表中的某个规则后，这个规则将会被应用一次，他之后的规则将被忽略。如果向反复匹配、应用，直到找不出可进一步化简的模式，可以用<code>//.</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rule</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="built_in">Log</span><span class="punctuation">[</span><span class="type">x_</span> <span class="type">y_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">rule</span></span><br><span class="line"><span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">rule</span> <span class="operator">/.</span> <span class="variable">rule</span></span><br><span class="line"><span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span> <span class="operator">//.</span> <span class="variable">rule</span></span><br><span class="line"><span class="built_in">FixedPoint</span><span class="punctuation">[</span><span class="type">#</span> <span class="operator">/.</span> <span class="variable">rule</span> <span class="operator">&amp;,</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">b</span> <span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">c</span> <span class="variable">d</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">c</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">d</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">c</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="built_in">Log</span><span class="punctuation">[</span><span class="variable">d</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><code>FixedPoint</code>函数将一个函数应用到某个对象，直到这个对象不变为止，<code>.//</code>就是这样实现的。</p><p>运算符<code>/.</code>和<code>//.</code>的全名分别是ReplaceAll和ReplaceRepeated，它们的一个共同特点是它们会对它们左边表达式的每个子表达式进行匹配和替换。有些时候我们希望控制这种搜索的深度，这时候就需要用Replace这个函数。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Replace</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">^</span><span class="number">2</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">-&gt;</span> <span class="variable">a</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Replace</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">^</span><span class="number">2</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">-&gt;</span> <span class="variable">a</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Replace</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">^</span><span class="number">2</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">-&gt;</span> <span class="variable">a</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">a</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">a</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Replace只返回第一个匹配成功的重写结果，有时候我们希望考察所有可能的重写结果，这时候可以用ReplaceList这个函数。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Replace</span><span class="punctuation">[</span><span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">+</span> <span class="type">y_</span> <span class="operator">:&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">ReplaceList</span><span class="punctuation">[</span><span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">+</span> <span class="type">y_</span> <span class="operator">:&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="operator">,</span> <span class="variable">a</span> <span class="operator">+</span> <span class="variable">c</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="operator">,</span> <span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span> <span class="operator">+</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line"> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span> <span class="operator">+</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>例：打印乘法表</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">times</span><span class="punctuation">[</span><span class="type">x_</span><span class="operator">,</span> <span class="type">y_</span><span class="punctuation">]</span> <span class="operator">:=</span> </span><br><span class="line">  <span class="built_in">ToString</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="operator">&lt;&gt;</span> <span class="string">&quot;x&quot;</span> <span class="operator">&lt;&gt;</span> <span class="built_in">ToString</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span> <span class="operator">&lt;&gt;</span> <span class="string">&quot;=&quot;</span> <span class="operator">&lt;&gt;</span> <span class="built_in">ToString</span><span class="punctuation">[</span><span class="variable">x</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="string">&quot;1x1=1&quot;</span><span class="operator">,</span> <span class="string">&quot;1x2=2&quot;</span><span class="operator">,</span> <span class="string">&quot;1x3=3&quot;</span><span class="operator">,</span> <span class="string">&quot;1x4=4&quot;</span><span class="operator">,</span> <span class="string">&quot;1x5=5&quot;</span><span class="operator">,</span> <span class="string">&quot;1x6=6&quot;</span><span class="operator">,</span> <span class="string">&quot;1x7=7&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;1x8=8&quot;</span><span class="operator">,</span> <span class="string">&quot;1x9=9&quot;</span><span class="operator">,</span> <span class="string">&quot;2x2=4&quot;</span><span class="operator">,</span> <span class="string">&quot;2x3=6&quot;</span><span class="operator">,</span> <span class="string">&quot;2x4=8&quot;</span><span class="operator">,</span> <span class="string">&quot;2x5=10&quot;</span><span class="operator">,</span> <span class="string">&quot;2x6=12&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;2x7=14&quot;</span><span class="operator">,</span> <span class="string">&quot;2x8=16&quot;</span><span class="operator">,</span> <span class="string">&quot;2x9=18&quot;</span><span class="operator">,</span> <span class="string">&quot;3x3=9&quot;</span><span class="operator">,</span> <span class="string">&quot;3x4=12&quot;</span><span class="operator">,</span> <span class="string">&quot;3x5=15&quot;</span><span class="operator">,</span> <span class="string">&quot;3x6=18&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;3x7=21&quot;</span><span class="operator">,</span> <span class="string">&quot;3x8=24&quot;</span><span class="operator">,</span> <span class="string">&quot;3x9=27&quot;</span><span class="operator">,</span> <span class="string">&quot;4x4=16&quot;</span><span class="operator">,</span> <span class="string">&quot;4x5=20&quot;</span><span class="operator">,</span> <span class="string">&quot;4x6=24&quot;</span><span class="operator">,</span> <span class="string">&quot;4x7=28&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;4x8=32&quot;</span><span class="operator">,</span> <span class="string">&quot;4x9=36&quot;</span><span class="operator">,</span> <span class="string">&quot;5x5=25&quot;</span><span class="operator">,</span> <span class="string">&quot;5x6=30&quot;</span><span class="operator">,</span> <span class="string">&quot;5x7=35&quot;</span><span class="operator">,</span> <span class="string">&quot;5x8=40&quot;</span><span class="operator">,</span> <span class="string">&quot;5x9=45&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;6x6=36&quot;</span><span class="operator">,</span> <span class="string">&quot;6x7=42&quot;</span><span class="operator">,</span> <span class="string">&quot;6x8=48&quot;</span><span class="operator">,</span> <span class="string">&quot;6x9=54&quot;</span><span class="operator">,</span> <span class="string">&quot;7x7=49&quot;</span><span class="operator">,</span> <span class="string">&quot;7x8=56&quot;</span><span class="operator">,</span> <span class="string">&quot;7x9=63&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;8x8=64&quot;</span><span class="operator">,</span> <span class="string">&quot;8x9=72&quot;</span><span class="operator">,</span> <span class="string">&quot;9x9=81&quot;</span><span class="punctuation">&#125;</span><span class="variable">timesTable</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> </span><br><span class="line">  <span class="variable">times</span> <span class="operator">@@@</span> </span><br><span class="line">   <span class="built_in">Sort</span><span class="punctuation">[</span><span class="built_in">ReplaceList</span><span class="punctuation">[</span></span><br><span class="line">     <span class="built_in">Range</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span> <span class="operator">:&gt;</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> </span><br><span class="line">        <span class="type">y_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span> <span class="operator">:&gt;</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">timesTable</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="string">&quot;1x1=1&quot;</span><span class="operator">,</span> <span class="string">&quot;1x2=2&quot;</span><span class="operator">,</span> <span class="string">&quot;1x3=3&quot;</span><span class="operator">,</span> <span class="string">&quot;1x4=4&quot;</span><span class="operator">,</span> <span class="string">&quot;1x5=5&quot;</span><span class="operator">,</span> <span class="string">&quot;1x6=6&quot;</span><span class="operator">,</span> <span class="string">&quot;1x7=7&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;1x8=8&quot;</span><span class="operator">,</span> <span class="string">&quot;1x9=9&quot;</span><span class="operator">,</span> <span class="string">&quot;2x2=4&quot;</span><span class="operator">,</span> <span class="string">&quot;2x3=6&quot;</span><span class="operator">,</span> <span class="string">&quot;2x4=8&quot;</span><span class="operator">,</span> <span class="string">&quot;2x5=10&quot;</span><span class="operator">,</span> <span class="string">&quot;2x6=12&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;2x7=14&quot;</span><span class="operator">,</span> <span class="string">&quot;2x8=16&quot;</span><span class="operator">,</span> <span class="string">&quot;2x9=18&quot;</span><span class="operator">,</span> <span class="string">&quot;3x3=9&quot;</span><span class="operator">,</span> <span class="string">&quot;3x4=12&quot;</span><span class="operator">,</span> <span class="string">&quot;3x5=15&quot;</span><span class="operator">,</span> <span class="string">&quot;3x6=18&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;3x7=21&quot;</span><span class="operator">,</span> <span class="string">&quot;3x8=24&quot;</span><span class="operator">,</span> <span class="string">&quot;3x9=27&quot;</span><span class="operator">,</span> <span class="string">&quot;4x4=16&quot;</span><span class="operator">,</span> <span class="string">&quot;4x5=20&quot;</span><span class="operator">,</span> <span class="string">&quot;4x6=24&quot;</span><span class="operator">,</span> <span class="string">&quot;4x7=28&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;4x8=32&quot;</span><span class="operator">,</span> <span class="string">&quot;4x9=36&quot;</span><span class="operator">,</span> <span class="string">&quot;5x5=25&quot;</span><span class="operator">,</span> <span class="string">&quot;5x6=30&quot;</span><span class="operator">,</span> <span class="string">&quot;5x7=35&quot;</span><span class="operator">,</span> <span class="string">&quot;5x8=40&quot;</span><span class="operator">,</span> <span class="string">&quot;5x9=45&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;6x6=36&quot;</span><span class="operator">,</span> <span class="string">&quot;6x7=42&quot;</span><span class="operator">,</span> <span class="string">&quot;6x8=48&quot;</span><span class="operator">,</span> <span class="string">&quot;6x9=54&quot;</span><span class="operator">,</span> <span class="string">&quot;7x7=49&quot;</span><span class="operator">,</span> <span class="string">&quot;7x8=56&quot;</span><span class="operator">,</span> <span class="string">&quot;7x9=63&quot;</span><span class="operator">,</span> \</span><br><span class="line"><span class="string">&quot;8x8=64&quot;</span><span class="operator">,</span> <span class="string">&quot;8x9=72&quot;</span><span class="operator">,</span> <span class="string">&quot;9x9=81&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>之前我们提到过<code>@@</code>可以换头，而<code>@@@</code>可以换内部的头：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">head</span> <span class="operator">@@@</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">k</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">head</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">head</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">head</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>规则(Rule、Delayed)和替换(Replace、ReplaceAll、ReplaceRepeated、ReplaceList)是比较安全的重写机制，下面我们看不安全的重写、即赋值。</p><p>赋值与规则的一大不同是：赋值操作所定义的重写方法则总是从属于某个符号的，而规则是独立存在的。</p><p>为什么会如此？因为如果不将全局规则(赋值)分派给某个符号，而是作为独立规则存在，那么在做任何计算的时候，都要检查以下待计算的表达式中是否有能够匹配全局规则的子表达式存在，这是极大的浪费。如果全局规则从属于某个符号，那么只有在遇到这个符号的时候我们才需要去尝试匹配，这就比较有效率。</p><p>运算符<code>=.</code>每次清掉一条赋值，如果想要清空所有赋值，可以用<code>Clear</code>函数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">n</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=.</span> <span class="comment">(*只清除f[1]*)</span></span><br><span class="line"><span class="built_in">Clear</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">]</span> <span class="comment">(*清空所有f*)</span></span><br><span class="line"><span class="built_in">Clear</span><span class="punctuation">[</span><span class="string">&quot;Global`*&quot;</span><span class="punctuation">]</span><span class="comment">(*清空所有变量*)</span></span><br></pre></td></tr></table></figure><p>Clear的作用是清掉规则，之后的符号还存在于系统中，还占着内存。如果想完全移除这个变量，将它占用的内存释放掉，则应该用Remove。</p><p>赋值行为也可以以其他的形式出现：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">i</span><span class="operator">=</span><span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">x</span><span class="operator">=</span><span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">i</span><span class="operator">++</span></span><br><span class="line"><span class="variable">i</span><span class="operator">--</span></span><br><span class="line"><span class="operator">++</span><span class="variable">i</span></span><br><span class="line"><span class="operator">--</span><span class="variable">i</span></span><br><span class="line"><span class="variable">i</span> <span class="operator">+=</span> <span class="variable">di</span></span><br><span class="line"><span class="variable">i</span> <span class="operator">-=</span> <span class="variable">di</span></span><br><span class="line"><span class="variable">x</span> <span class="operator">*=</span> <span class="variable">c</span></span><br><span class="line"><span class="variable">x</span> <span class="operator">/=</span> <span class="variable">c</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span><span class="operator">+</span> <span class="variable">di</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">c</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>赋值还可以同时进行</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">x</span> <span class="operator">=</span> <span class="variable">y</span> <span class="operator">=</span> <span class="variable">value</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">&#125;</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="variable">value1</span><span class="operator">,</span> <span class="variable">value2</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">&#125;</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>有一些函数可以改变其参数的值：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">list</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">AppendTo</span><span class="punctuation">[</span><span class="variable">list</span> <span class="operator">,</span><span class="variable">d</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">PrependTo</span><span class="punctuation">[</span><span class="variable">list</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>再次强调一下，AppendTo和PrependTo这两个函数是比较慢的。对于比较长的表，尽量不要反复用它们。</p><p>当习惯于C语言编程的人编写Mathematica程序的时候，总是喜欢用表来存储数组。</p><p>事实上在Mathematica中，更好的做法是把数组视为从自然数到其他集合的函数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">a</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">a</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">n</span><span class="operator">/</span><span class="number">2</span> <span class="operator">/;</span> <span class="built_in">EvenQ</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Array</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="number">10</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">[</span><span class="number">7</span><span class="punctuation">]</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">]</span><span class="operator">,</span> <span class="number">5</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这样的好处是，函数对象不需要初始化，也不需要指定尺寸。</p><p>另外，函数的自变量可以是任何东西，所以可以实现一些更有趣的结构。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张三<span class="punctuation">[</span>身高<span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1.75</span> <span class="variable">m</span><span class="operator">;</span></span><br><span class="line">张三<span class="punctuation">[</span>体重<span class="punctuation">]</span> <span class="operator">=</span> <span class="number">70</span> <span class="variable">kg</span><span class="operator">;</span></span><br><span class="line">谁<span class="type">_</span><span class="punctuation">[</span><span class="variable">BMI</span><span class="punctuation">]</span> <span class="operator">^:=</span> 谁<span class="punctuation">[</span>体重<span class="punctuation">]</span> <span class="operator">/</span> 谁<span class="punctuation">[</span>身高<span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="operator">;</span></span><br><span class="line">张三<span class="punctuation">[</span><span class="variable">BMI</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">(</span><span class="number">22.8571</span> <span class="variable">kg</span><span class="punctuation">)</span><span class="operator">/</span><span class="variable">m</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这种写法实际上体现了一种面向对象编程的想法，下面是另一种更花哨的写法：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张三 <span class="operator">/:</span> 张三<span class="operator">.</span>身高 <span class="operator">=</span> <span class="number">1.75</span> <span class="variable">m</span><span class="operator">;</span></span><br><span class="line">张三 <span class="operator">/:</span> 张三<span class="operator">.</span>体重 <span class="operator">=</span> <span class="number">70</span> <span class="variable">kg</span><span class="operator">;</span></span><br><span class="line"><span class="variable">BMI</span> <span class="operator">/:</span> <span class="punctuation">(</span>谁<span class="type">_</span><span class="punctuation">)</span><span class="operator">.</span><span class="variable">BMI</span> <span class="operator">:=</span> <span class="punctuation">(</span>谁<span class="operator">.</span>体重<span class="punctuation">)</span><span class="operator">/</span><span class="punctuation">(</span>谁<span class="operator">.</span>身高<span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line">张三<span class="operator">.</span><span class="variable">BMI</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">(</span><span class="number">22.8571</span> <span class="variable">kg</span><span class="punctuation">)</span><span class="operator">/</span><span class="variable">m</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>新出现的两个运算符<code>^:=</code>和<code>/:</code>我们稍后再解释。</p><p>赋值和规则的另一个重大不同是：多次赋值产出的规则表是按照从特殊到一般的顺序来应用的，而且与它们出现的顺序无关；规则表则不同，应用顺序等于它们在表中的排列顺序。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">g</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">g</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这里<code>f[1]=1</code>和<code>g[n]=1</code>为特殊规则，故不管顺序如何，结果都是<code>&#123;1,3&#125;</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="variable">h</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="variable">h</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">h</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="variable">h</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="number">1</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而规则则与顺序有关。</p><p>如果要使用很长的规则表<code>&#123;p1-&gt;r1,p2-&gt;r2,......&#125;</code>，最好用<code>Mathematica</code>内部函数<code>Dispatch</code>压缩一下，这样可以提高替换的效率。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rules</span> <span class="operator">=</span> <span class="built_in">Table</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="built_in">RandomInteger</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="variable">i</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">dispatch</span> <span class="operator">=</span> <span class="built_in">Dispatch</span><span class="punctuation">[</span><span class="variable">rules</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="built_in">Table</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">rules</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="built_in">Table</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="variable">dispatch</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">2.125</span><span class="operator">,</span> <span class="built_in">Null</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">0.015625</span><span class="operator">,</span> <span class="built_in">Null</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Mathematica</code>中同时赋值、延迟赋值和全局规则等原理可以帮助我们实现一种非常优雅的机制。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">20</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">0.015625</span><span class="operator">,</span> <span class="number">10946</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span></span><br><span class="line"><span class="variable">g</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="number">20</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">0.</span><span class="operator">,</span> <span class="number">10946</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到比之前快了很多。在后一种实现中，因为多了一个同时赋值，所以之前计算过的值都被自动存储下来，这对于递归函数来说非常重要，因为可以减少大量的重复计算。</p><p>我们之前说过，赋值这个规则总是从属于某个符号的。一个重要的问题是，到底从属于哪个符号？</p><p>对于下面的语句</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">F</span><span class="punctuation">[</span><span class="variable">X1</span><span class="operator">,</span><span class="variable">X2</span><span class="operator">,...,</span><span class="variable">Xn</span><span class="punctuation">]</span><span class="operator">=</span><span class="variable">value</span></span><br></pre></td></tr></table></figure><p>Mathematica默认这样一条规则是从属于符号F。</p><p>但这未必是我们想要的，例如前面张三的BMI这个例子中，左边表达式的头”谁_”是一个模式，而不是固定的符号，这时候就无法分配这条规则。另一种情况是：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">log</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">log</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">log</span><span class="punctuation">[</span><span class="variable">x</span> <span class="variable">y</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>因为左边表达式的头为<code>Plus</code>，我们无法改变其规则。尽管我们可以通过解除保护的方法强行对函数Plus增加一条规则，但这不是正确的做法。因为这样做的后果是，系统每次进行加法运算都不得不检查待计算的表达式是否符合我们增加的这条规则，这是极大的资源浪费。</p><p>对于这两种情况，我们都需要一种机制，来指定规则所从属的对象。例如在第一个例子中，我们可以将这条规则指定给BMI这个符号，在第二个例子中，我们可以将规则给自定义函数log。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">log</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">log</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span> <span class="operator">^:=</span> <span class="variable">log</span><span class="punctuation">[</span><span class="variable">x</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="operator">?</span><span class="variable">log</span></span><br><span class="line"><span class="operator">&gt;</span>  <span class="variable">UpValue</span> <span class="variable">Definitions</span><span class="variable">log</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span><span class="operator">+</span><span class="variable">log</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span><span class="operator">^:=</span><span class="variable">log</span><span class="punctuation">[</span><span class="variable">x</span> <span class="variable">y</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>可以看到这条规则附属于log。</p><p>一般来说，运算符<code>^:=</code>会将这条规则指定给下层的所有不受保护的函数，此时赋值号右边的值叫做这些函数的<code>upvalue</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">^:=</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="built_in">Sin</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><p>此时规则挂在<code>f</code>下的函数<code>g</code>和<code>h</code>上。</p><p>如果我们想要更明确地指派规则，可以用：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">g</span> <span class="operator">/:</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="built_in">Sin</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><p>这样规则就只定义在<code>g</code>上。</p><p>但是需要注意的是，这种规则指派只能改动一层，如果再深一层就不被允许了。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">g</span><span class="operator">/:</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">h</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">:=</span> <span class="variable">x</span><span class="operator">+</span><span class="number">1</span><span class="operator">;</span><span class="comment">(*出错*)</span></span><br></pre></td></tr></table></figure><h2 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h2><h3 id="函数与泛函编程"><a href="#函数与泛函编程" class="headerlink" title="函数与泛函编程"></a>函数与泛函编程</h3><p>前缀、中缀和后缀：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span><span class="operator">@</span><span class="variable">x</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">x</span><span class="operator">~</span><span class="variable">f</span><span class="operator">~</span><span class="variable">y</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span><span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span><span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span><span class="operator">@</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span><span class="operator">@</span><span class="variable">g</span><span class="operator">@</span><span class="variable">x</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="variable">x</span> <span class="operator">//</span> <span class="variable">g</span> <span class="operator">//</span> <span class="variable">f</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h4 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h4><p><code>Orderless</code>：交换性</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetAttributes</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="built_in">Orderless</span><span class="punctuation">]</span><span class="operator">;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span> <span class="operator">==</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">True</span></span><br></pre></td></tr></table></figure><p><code>Flat</code>：结合性</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetAttributes</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="built_in">Flat</span><span class="punctuation">]</span><span class="operator">;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span> <span class="operator">==</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">True</span></span><br></pre></td></tr></table></figure><p><code>OneIdentity</code></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetAttributes</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="built_in">OneIdentity</span><span class="punctuation">]</span><span class="operator">;</span> <span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="operator">:</span> <span class="number">0</span><span class="operator">,</span> <span class="type">y_</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">True</span></span><br></pre></td></tr></table></figure><p><code>Listable</code></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetAttributes</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="built_in">Listable</span><span class="punctuation">]</span><span class="operator">;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>自定义筛选函数</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">S</span> <span class="operator">=</span> <span class="built_in">Normal</span><span class="operator">@</span><span class="built_in">Series</span><span class="punctuation">[</span><span class="built_in">Cos</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">/</span><span class="punctuation">(</span><span class="variable">x</span><span class="operator">^</span><span class="number">4</span> <span class="built_in">Tan</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span><span class="operator">/</span><span class="variable">x</span><span class="operator">^</span><span class="number">5</span> <span class="operator">-</span> <span class="number">5</span><span class="operator">/</span><span class="punctuation">(</span><span class="number">6</span> <span class="variable">x</span><span class="operator">^</span><span class="number">3</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="number">67</span><span class="operator">/</span><span class="punctuation">(</span><span class="number">360</span> <span class="variable">x</span><span class="punctuation">)</span> <span class="operator">-</span> <span class="punctuation">(</span><span class="number">19</span> <span class="variable">x</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">3024</span> <span class="operator">+</span> <span class="punctuation">(</span><span class="number">247</span> <span class="variable">x</span><span class="operator">^</span><span class="number">3</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">604800</span> <span class="operator">+</span> <span class="punctuation">(</span></span><br><span class="line"> <span class="number">89</span> <span class="variable">x</span><span class="operator">^</span><span class="number">5</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">4790016</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Plus</span> <span class="operator">@@</span> <span class="built_in">Cases</span><span class="punctuation">[</span><span class="variable">S</span><span class="operator">,</span> <span class="type">a_</span><span class="operator">.</span> <span class="variable">x</span><span class="operator">^</span><span class="type">d_</span> <span class="operator">/;</span> <span class="variable">d</span> <span class="operator">&lt;</span> <span class="number">0</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Select</span><span class="punctuation">[</span><span class="variable">S</span><span class="operator">,</span> <span class="punctuation">(</span><span class="type">#</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="type">a_</span><span class="operator">.</span> <span class="variable">x</span><span class="operator">^</span><span class="type">d_</span> <span class="operator">:&gt;</span> <span class="variable">d</span><span class="punctuation">&#125;</span><span class="punctuation">)</span> <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Select</span><span class="punctuation">[</span><span class="variable">S</span><span class="operator">,</span> <span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="type">#</span><span class="operator">,</span> <span class="type">a_</span><span class="operator">.</span> <span class="variable">x</span><span class="operator">^</span><span class="type">d_</span> <span class="operator">/;</span> <span class="variable">d</span> <span class="operator">&lt;</span> <span class="number">0</span><span class="punctuation">]</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h4 id="带下标的函数"><a href="#带下标的函数" class="headerlink" title="带下标的函数"></a>带下标的函数</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">p</span> <span class="operator">=</span> <span class="built_in">Plus</span> <span class="operator">@@</span> <span class="punctuation">(</span><span class="punctuation">(</span><span class="variable">g</span> <span class="operator">@@</span> <span class="type">#</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="built_in">Times</span> <span class="operator">@@</span> <span class="variable">u</span> <span class="operator">/@</span> <span class="type">#</span> <span class="operator">&amp;</span> <span class="operator">/@</span> <span class="variable">Partitions</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line"> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">3</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="variable">u</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">5</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="函数的函数"><a href="#函数的函数" class="headerlink" title="函数的函数"></a>函数的函数</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span> <span class="operator">=</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">+</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">y$</span><span class="operator">,</span> <span class="number">2</span> <span class="operator">+</span> <span class="variable">y$</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这里<code>y$</code>表示一个临时变量。</p><h4 id="泛函操作"><a href="#泛函操作" class="headerlink" title="泛函操作"></a>泛函操作</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">f</span> <span class="operator">/@</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>关于MapIndexed，不止可以得到映射后的值，还会得到索引。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MapIndexed</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">3</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">(*还可以指定深度*)</span></span><br><span class="line"><span class="built_in">MapIndexed</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">e</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line">   <span class="variable">f</span><span class="punctuation">[</span><span class="number">3</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">e</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="variable">e</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">L</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">d</span><span class="punctuation">&#125;</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">MapIndexed</span><span class="punctuation">[</span></span><br><span class="line"> <span class="built_in">Print</span><span class="punctuation">[</span><span class="string">&quot;The position of &quot;</span><span class="operator">,</span> <span class="type">#1</span><span class="operator">,</span> <span class="string">&quot; in the List &quot;</span><span class="operator">,</span> <span class="string">&quot; is &quot;</span><span class="operator">,</span> <span class="type">#2</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line">   <span class="string">&quot;.&quot;</span><span class="punctuation">]</span> <span class="operator">&amp;,</span> <span class="variable">L</span></span><br><span class="line"> <span class="punctuation">]</span></span><br><span class="line"> <span class="operator">&gt;</span> <span class="variable">The</span> <span class="variable">position</span> <span class="variable">of</span> <span class="variable">a</span> <span class="variable">in</span> <span class="variable">the</span> <span class="built_in">List</span>  <span class="variable">is</span> <span class="number">1.</span></span><br><span class="line"> <span class="operator">&gt;</span> <span class="variable">The</span> <span class="variable">position</span> <span class="variable">of</span> <span class="variable">b</span> <span class="variable">in</span> <span class="variable">the</span> <span class="built_in">List</span>  <span class="variable">is</span> <span class="number">2.</span></span><br><span class="line"> <span class="operator">&gt;</span> <span class="variable">The</span> <span class="variable">position</span> <span class="variable">of</span> <span class="variable">c</span> <span class="variable">in</span> <span class="variable">the</span> <span class="built_in">List</span>  <span class="variable">is</span> <span class="number">3.</span></span><br><span class="line"> <span class="operator">&gt;</span> <span class="variable">The</span> <span class="variable">position</span> <span class="variable">of</span> <span class="variable">d</span> <span class="variable">in</span> <span class="variable">the</span> <span class="built_in">List</span>  <span class="variable">is</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure><p>其中<code>#1</code>表示函数的第一个参数，<code>#2</code>表示第二个参数。</p><p><code>MapThread</code>函数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MapThread</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">p</span><span class="operator">,</span> <span class="variable">q</span><span class="operator">,</span> <span class="variable">r</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">(*注意每一个列表必须同样大小*)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">p</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="operator">,</span> <span class="variable">q</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="operator">,</span> <span class="variable">r</span><span class="operator">,</span> <span class="variable">z</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们也可以用已有的函数实现：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span> <span class="operator">@@@</span> <span class="built_in">Transpose</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">p</span><span class="operator">,</span> <span class="variable">q</span><span class="operator">,</span> <span class="variable">r</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">u</span><span class="operator">,</span> <span class="variable">v</span><span class="operator">,</span> <span class="variable">w</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">p</span><span class="operator">,</span> <span class="variable">u</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">b</span><span class="operator">,</span> <span class="variable">q</span><span class="operator">,</span> <span class="variable">v</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">c</span><span class="operator">,</span> <span class="variable">r</span><span class="operator">,</span> <span class="variable">w</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>Scan函数也有类似于Map函数的用法，但是存在一点不同：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Scan</span><span class="punctuation">[</span><span class="built_in">Print</span><span class="punctuation">[</span><span class="string">&quot;Hey! I&#x27;m &quot;</span><span class="operator">,</span> <span class="type">#</span><span class="punctuation">]</span> <span class="operator">&amp;,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">a</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">c</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span><span class="punctuation">[</span><span class="built_in">Print</span><span class="punctuation">[</span><span class="string">&quot;Hey! I&#x27;m &quot;</span><span class="operator">,</span> <span class="type">#</span><span class="punctuation">]</span> <span class="operator">&amp;,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">a</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">Hey</span><span class="operator">!</span> <span class="built_in">I</span><span class="operator">&#x27;</span><span class="variable">m</span> <span class="variable">c</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="built_in">Null</span><span class="operator">,</span> <span class="built_in">Null</span><span class="operator">,</span> <span class="built_in">Null</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>Scan不关心中间的返回值。<br>Through函数：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Through</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="variable">f</span> <span class="operator">+</span> <span class="variable">g</span> <span class="operator">+</span> <span class="variable">h</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Through</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">]</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">h</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">g</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p><h4 id="函数迭代"><a href="#函数迭代" class="headerlink" title="函数迭代"></a>函数迭代</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Nest</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">NestList</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="函数不动点"><a href="#函数不动点" class="headerlink" title="函数不动点"></a>函数不动点</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">N</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="variable">x</span> <span class="operator">+</span> <span class="number">2</span><span class="operator">/</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">2</span><span class="operator">,</span> <span class="number">20</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FixedPoint</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1.4142135623730950488</span></span><br><span class="line"><span class="built_in">FixedPointList</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">1.5000000000000000000</span><span class="operator">,</span> <span class="number">1.4166666666666666667</span><span class="operator">,</span> \</span><br><span class="line"><span class="number">1.4142156862745098039</span><span class="operator">,</span> <span class="number">1.4142135623746899106</span><span class="operator">,</span> <span class="number">1.4142135623730950488</span><span class="operator">,</span> \</span><br><span class="line"><span class="number">1.4142135623730950488</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="条件迭代"><a href="#条件迭代" class="headerlink" title="条件迭代"></a>条件迭代</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NestWhile</span><span class="punctuation">[</span><span class="type">#</span><span class="operator">^</span><span class="number">2</span> <span class="operator">&amp;,</span> <span class="number">2</span><span class="operator">,</span> <span class="punctuation">(</span><span class="type">#</span> <span class="operator">&lt;</span> <span class="number">10</span><span class="operator">^</span><span class="number">10</span><span class="punctuation">)</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">NestWhileList</span><span class="punctuation">[</span><span class="type">#</span><span class="operator">^</span><span class="number">2</span> <span class="operator">&amp;,</span> <span class="number">2</span><span class="operator">,</span> <span class="punctuation">(</span><span class="type">#</span> <span class="operator">&lt;</span> <span class="number">10</span><span class="operator">^</span><span class="number">10</span><span class="punctuation">)</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">18446744073709551616</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">2</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> <span class="number">256</span><span class="operator">,</span> <span class="number">65536</span><span class="operator">,</span> <span class="number">4294967296</span><span class="operator">,</span> <span class="number">18446744073709551616</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>条件迭代也可以用于求解不动点<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">N</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="variable">x</span> <span class="operator">+</span> <span class="number">3</span><span class="operator">/</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">2</span><span class="operator">,</span> <span class="number">20</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">NestWhile</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="built_in">Unequal</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1.7320508075688772935</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NestWhileList</span><span class="punctuation">[</span><span class="built_in">Mod</span><span class="punctuation">[</span><span class="number">3</span> <span class="type">#</span><span class="operator">,</span> <span class="number">57</span><span class="punctuation">]</span> <span class="operator">&amp;,</span> <span class="number">1</span><span class="operator">,</span> <span class="built_in">Unequal</span><span class="operator">,</span> <span class="built_in">All</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">9</span><span class="operator">,</span> <span class="number">27</span><span class="operator">,</span> <span class="number">24</span><span class="operator">,</span> <span class="number">15</span><span class="operator">,</span> <span class="number">45</span><span class="operator">,</span> <span class="number">21</span><span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> <span class="number">18</span><span class="operator">,</span> <span class="number">54</span><span class="operator">,</span> <span class="number">48</span><span class="operator">,</span> <span class="number">30</span><span class="operator">,</span> <span class="number">33</span><span class="operator">,</span> <span class="number">42</span><span class="operator">,</span> <span class="number">12</span><span class="operator">,</span> <span class="number">36</span><span class="operator">,</span> <span class="number">51</span><span class="operator">,</span> \</span><br><span class="line"><span class="number">39</span><span class="operator">,</span> <span class="number">3</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="折叠运算"><a href="#折叠运算" class="headerlink" title="折叠运算"></a>折叠运算</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Fold</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FoldList</span><span class="punctuation">[</span><span class="variable">f</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">x</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">b</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">c</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第六周"><a href="#第六周" class="headerlink" title="第六周"></a>第六周</h2><h3 id="模块化、语境和包"><a href="#模块化、语境和包" class="headerlink" title="模块化、语境和包"></a>模块化、语境和包</h3><p>在Mathematica中，变量默认为全局变量。这是因为大多数Mathematica程序都比较短小，因此只要靠用户自己维护就可以避免全局变量重名带来的各种问题。但是有些时候人们也需要编制大型的Mathematica程序，这时候就需要将一些全局变量隔离、打包的机制，这就是今天要将的模块化、语境和包等概念。<br>模块化：Module<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">y</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">y</span> <span class="operator">=</span> <span class="variable">x</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span> <span class="variable">x</span><span class="operator">/</span><span class="variable">y</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="number">10</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">y</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span><span class="operator">/</span><span class="number">11</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><br>Module的作用是定义一个封闭的环境。其中存在一些局部变量(由第一个参数(必须是一个表)的元素组成)。当Module表达式求值完毕之后，这个环境就不存在了，其中的局部变量自然也会消失。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">print</span> <span class="operator">:=</span> <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">y</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">print</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">y$14115</span></span><br></pre></td></tr></table></figure><br>在Module中，局部变量<code>y</code>被替换为带有内部编号的一种变量<code>y$num</code>，其中<code>num</code>是一个自然数，取自Mathematica内部的一个计数变量<script type="math/tex">ModuleNumber`。每次调用Module或者具有类似功能的结构时都会增加`$ModuleNumber`，于是`y</script>后面的数字永远不相同，所以也就不会有重名问题。<br>我们可以用<code>Unique</code>生成计数器：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="built_in">Unique</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="built_in">Unique</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="built_in">Unique</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="variable">x$14690</span></span><br><span class="line"><span class="variable">x$14691</span></span><br><span class="line"><span class="variable">x$14692</span></span><br></pre></td></tr></table></figure><br>注意，带<code>$</code>和编号的变量具有Temporary属性：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="string">&quot; has attributes &quot;</span><span class="operator">,</span> <span class="built_in">Attributes</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">x$15746</span> <span class="variable">has</span> <span class="variable">attributes</span> <span class="punctuation">&#123;</span><span class="built_in">Temporary</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>我们可以使用<code>?x*</code>来查看<code>x</code>的临时属性。<br>带有临时属性的变量在生存期结束时就会被系统<code>Remove</code>，除非它们生存期内被显式地返回给外部的全局环境。<br>我们下面考察以下另一种结构<code>with</code>来与<code>Module</code>做一下对比：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="variable">a</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">a</span></span><br></pre></td></tr></table></figure><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">4</span><span class="operator">;</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">(*打印5，警告，n不能再被赋值了*)</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">4</span><span class="operator">;</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">&#125;</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">-&gt;</span> <span class="number">5</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">4</span></span><br><span class="line"><span class="comment">(* 因为是先打印，再替换，所以打印出的是4 *)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ReleaseHold</span><span class="punctuation">[</span><span class="built_in">Hold</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">4</span><span class="operator">;</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">/.</span> <span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">-&gt;</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="comment">(*首先先将(n = 4; Print[n]) hold住，使其变为一个表达式而不执行，替换完成后释放hold执行*)</span></span><br></pre></td></tr></table></figure></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">n</span></span><br></pre></td></tr></table></figure><p>With的作用是定义一个封闭的环境，其中存在一些局部变量。在With的第二个参数表达式中所有这些常量都会直接替换成第一个参数中赋值语句右边的值。在这个环境中，局部常量的值是不变的。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">a</span> <span class="operator">=</span> <span class="variable">x</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="variable">a</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">n</span> <span class="operator">=</span> <span class="variable">b</span><span class="operator">;</span> <span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">a</span></span><br><span class="line"><span class="variable">x</span></span><br><span class="line"><span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">b</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">b</span></span><br></pre></td></tr></table></figure><br>注意，在这个例子中，<code>a</code>是一个外部环境的变量，Mathematica的变量实际上都是指针。所以，在With内部，n是与a相等的指针，当我们写n=b时，实际上是在写a=b，它的作用是把a的值换成b的值，n和a始终始终是指向同一个地方，所以”n”仍是常量。<br>但是如果变成<code>n=1;n=b</code>就会警告，因为如果<code>n=1</code>，那么我们就无法将常量<code>1</code>赋值为其他的值。<br>Module和With的内部环境叫做相应的局部变量或局部变量的作用域。下面我们看几种隐式出现的作用域：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span> <span class="operator">=</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">y</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">+</span> <span class="variable">y</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">y$</span><span class="operator">,</span> <span class="variable">y</span> <span class="operator">+</span> <span class="variable">y$</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>在这个例子中，<code>f</code>的函数体部分因为某种外部原因，这是Mathematica就会把内层的变量<code>y</code>自动命名为<code>y$</code>，这是一个临时变量，他会在函数定义结束后被销毁。另一个自动改名的例子：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">With</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">w</span> <span class="operator">=</span> <span class="variable">x</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="variable">w</span> <span class="operator">+</span> <span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">h</span><span class="punctuation">[</span><span class="type">x$_</span><span class="punctuation">]</span> <span class="operator">:&gt;</span> <span class="variable">x</span> <span class="operator">+</span> <span class="variable">x$</span></span><br></pre></td></tr></table></figure><br>Function定义的是纯函数，或者叫匿名函数、$\lambda-$表达式，它们的参数是所谓的哑变量，可以随意换名字而不影响定义。Mathematica在这里做的正是这样一件事，其原因是为了避免与可能存在的全局变量重名。<br>除了Module、With、Function以外，各种赋值，规则中的模式名称(x_、x__、x:pattern)也具有自动改名的功能，这些赋值、规则语句就成为这些改名后的临时变量的作用域。注意，常量是不能自动改名的。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">x</span> <span class="operator">=</span>  <span class="number">1</span><span class="operator">;</span> <span class="variable">y</span> <span class="operator">=</span> <span class="variable">a</span><span class="operator">;</span> <span class="variable">f</span><span class="punctuation">[</span><span class="type">x_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="punctuation">(</span><span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="operator">;</span> <span class="variable">g</span><span class="punctuation">[</span><span class="type">y_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="punctuation">(</span><span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="operator">;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">g</span><span class="punctuation">[</span><span class="variable">y</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">2</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">(*第一个居于报错，因为我们想赋值1=2*)</span></span><br></pre></td></tr></table></figure><br>再看一些哑变量的例子：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">i</span> <span class="operator">=</span> <span class="number">50</span><span class="operator">;</span> <span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span><span class="operator">;</span><span class="comment">(*此例子中x必须是变量，不能是常数，否则不能做积分变量*)</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="built_in">Sum</span><span class="punctuation">[</span><span class="variable">i</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">100</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">,</span> <span class="built_in">Integrate</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">i</span><span class="operator">,</span> <span class="variable">x</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">5050</span><span class="operator">,</span> <span class="number">1</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">50</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">p</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">Integrate</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="variable">x</span><span class="operator">^</span><span class="variable">n</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">p</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="comment">(*局部变量与全局变量混淆*)</span></span><br><span class="line"><span class="variable">q</span><span class="punctuation">[</span><span class="type">n_</span><span class="punctuation">]</span> <span class="operator">:=</span> <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="built_in">Integrate</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="variable">x</span><span class="operator">^</span><span class="variable">n</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">q</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p><p>Module和With都是通过改名的办法将作用域内的变量变为与外部变量不同的局部变量。有的时候我们需要另外一种隔离手段，我们想要构造一个作用域，其中局部变量与全局变量具有相同的”名字”和不同的”值”，这就要用Block来做隔离。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Block</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">3</span> <span class="operator">+</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">+</span> <span class="variable">a</span><span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">3</span> <span class="operator">+</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">+</span> <span class="variable">a</span><span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Block</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">x</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">y</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">3</span> <span class="operator">+</span> <span class="variable">x</span><span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="number">3</span> <span class="operator">+</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">+</span> <span class="variable">a</span><span class="punctuation">)</span><span class="operator">^</span><span class="number">2</span></span><br></pre></td></tr></table></figure><br>我们可以换一种角度来解释两者的不同。在上面的例子中，Module里的局部变量只生存在Module内，它不会跟踪y的定义跑出到Module外面去；另一方面，Block里的局部变量x会跟踪出去，找出y中出现的所有x，然后替换，所以它的作用域可以从Block延伸出去，侵入到y的作用域中。上面提到的积分变量必须是变量是因为积分是用<code>Block</code>实现的。</p><p>利用这些域规则我们可以创造出很对有趣的函数。<br>闭包的例子：计数器产生器<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">CounterCreator</span><span class="punctuation">[</span><span class="type">first_</span><span class="operator">:</span> <span class="number">1</span><span class="operator">,</span> <span class="type">delta_</span><span class="operator">:</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">:=</span> </span><br><span class="line"> <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">i</span> <span class="operator">=</span> <span class="variable">first</span> <span class="operator">-</span> <span class="variable">delta</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="variable">i</span> <span class="operator">+=</span> <span class="variable">delta</span><span class="punctuation">&#125;</span> <span class="operator">&amp;</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">counter1</span> <span class="operator">=</span> <span class="variable">CounterCreator</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">counter2</span> <span class="operator">=</span> <span class="variable">CounterCreator</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">counter3</span> <span class="operator">=</span> <span class="variable">CounterCreator</span><span class="punctuation">[</span><span class="number">19</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><br>这样就创建了三个计数器，各个计数器之间互不干扰。<br>另一个闭包的例子，状态机：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">StateMachine</span> <span class="operator">=</span> </span><br><span class="line">  <span class="built_in">Module</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">i</span><span class="punctuation">&#125;</span><span class="operator">,</span> </span><br><span class="line">   <span class="built_in">Function</span><span class="punctuation">[</span><span class="variable">func</span><span class="operator">,</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> </span><br><span class="line">    <span class="built_in">Switch</span><span class="punctuation">[</span><span class="variable">func</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="variable">i</span> <span class="operator">&amp;,</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">++</span><span class="variable">i</span> <span class="operator">&amp;,</span> <span class="number">2</span><span class="operator">,</span> <span class="operator">--</span><span class="variable">i</span> <span class="operator">&amp;,</span> <span class="number">3</span><span class="operator">,</span> <span class="punctuation">(</span><span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span> <span class="operator">&amp;,</span> <span class="type">_</span><span class="operator">,</span> </span><br><span class="line">     <span class="built_in">Print</span><span class="punctuation">[</span><span class="string">&quot;Illegal function!&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">read</span> <span class="operator">=</span> <span class="variable">StateMachine</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">up</span> <span class="operator">=</span> <span class="variable">StateMachine</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">down</span> <span class="operator">=</span> <span class="variable">StateMachine</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">reset</span> <span class="operator">=</span> <span class="variable">StateMachine</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><br>这四个相互影响。<br>在各种程序语言中，还有一种显式指定作用域的方法。典型的例子就是C++语言中的命名空间(namespace)。在Mathematica中也有一种类似的机制，叫做语境(Context)。<br>Global`是Mathematica的默认语境，所有用户自己定义的符号、函数都存在于这个语境中。用户也可以自己定义语境：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">foo</span><span class="operator">`</span><span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">;</span></span><br><span class="line"><span class="comment">(*语境也可以嵌套*)</span></span><br><span class="line"><span class="variable">foo</span><span class="operator">`</span><span class="variable">bar</span><span class="operator">`</span><span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><br>语境就像是文件系统中的文件夹，语境下面的嵌套语境就像文件夹下的子文件夹。语境中的符号、函数则像文件夹中的各种文件。无论如何，我们在Mathematica中总存在于一个语境中，它可以通过变量<code>$Context</code>访问。<br>如果Mathematica遇到一个符号，他首先会在当前语境中查找这个符号的意义。如果找不到，则会在<code>$ContextPath</code>所指定语境路径按顺序查找这个符号。<br>我们可以通过赋值改变当前语境，也可以向语境路径中添加我们的语境：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$Context</span> <span class="operator">=</span> <span class="string">&quot;foo`&quot;</span></span><br><span class="line"><span class="built_in">$ContextPath</span> <span class="operator">=</span> <span class="built_in">PrependTo</span><span class="punctuation">[</span><span class="built_in">$ContextPath</span><span class="operator">,</span> <span class="string">&quot;bar&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>函数<code>Context[]</code>可以查找当前语境或者某个符号所属的语境：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Context</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Context</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>函数<code>Contexts</code>可以列出所有的语境，或者按通配符列出相应的语境：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Contexts</span><span class="punctuation">[</span><span class="string">&quot;System`**&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>语境可以通过<code>Begin[&quot;Content&quot;]</code>和<code>End[]</code>进出：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Begin</span><span class="punctuation">[</span><span class="string">&quot;新语境&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Print</span><span class="punctuation">[</span><span class="variable">x</span><span class="operator">=</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">End</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>我们后面介绍包(package)的概念、包都自带一个语境。如果导入了某个程序包，那么它的语境会自动添加为语境路径的第一个语境。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Needs</span><span class="punctuation">[</span><span class="string">&quot;Quaternions&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">$ContextPath</span></span><br></pre></td></tr></table></figure></p><h2 id="第七周"><a href="#第七周" class="headerlink" title="第七周"></a>第七周</h2><h3 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h3><p>要谈优化，首先要有测量：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Timing</span><span class="punctuation">[</span><span class="built_in">FactorInteger</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">^</span><span class="punctuation">(</span><span class="number">2</span><span class="operator">^</span><span class="number">8</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">AbsoluteTiming</span><span class="punctuation">[</span><span class="built_in">FactorInteger</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">^</span><span class="punctuation">(</span><span class="number">2</span><span class="operator">^</span><span class="number">8</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="number">0.359375</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">1238926361552897</span><span class="operator">,</span> </span><br><span class="line">   <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">93461639715357977769163558199606896584051237541638188580280321</span>\</span><br><span class="line"><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="number">0.365291</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">1238926361552897</span><span class="operator">,</span> </span><br><span class="line">   <span class="number">1</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">93461639715357977769163558199606896584051237541638188580280321</span>\</span><br><span class="line"><span class="operator">,</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>还有空间的度量<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">pts</span> <span class="operator">=</span> <span class="built_in">RandomReal</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">10000</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">gr</span> <span class="operator">=</span> <span class="built_in">Graphics</span><span class="punctuation">[</span><span class="built_in">Point</span> <span class="operator">/@</span> <span class="variable">pts</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">grMulti</span> <span class="operator">=</span> <span class="built_in">Graphics</span><span class="punctuation">[</span><span class="built_in">Point</span><span class="punctuation">[</span><span class="variable">pts</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ByteCount</span> <span class="operator">/@</span> <span class="punctuation">&#123;</span><span class="variable">gr</span><span class="operator">,</span> <span class="variable">grMulti</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="number">1760128</span><span class="operator">,</span> <span class="number">160248</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>除此之外，还有<code>MemoryInUse</code>等。<br>我们主要关心对时间的优化，有以下几条大的原则：</p><ol><li>不要重复造轮子，尽量用Mathematica自己的函数。</li><li>不要自己写循环：要尽可能地将循环都转为表处理。</li><li>要善于用数学。</li><li>知道得越多，算得越快。</li><li>简单比复杂好</li><li>纯函数比模式匹配快<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><code>StringLength</code>获取字符串长度、<code>StringJoin</code>连接字符串。<code>&lt;&gt;</code>字符串连接。<br><code>CharacterRange[&quot;a&quot;,&quot;z&quot;]</code>：生成从”a”到”z”的ASSIC码。<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">alphabet</span> <span class="operator">=</span> <span class="built_in">StringJoin</span><span class="punctuation">[</span><span class="built_in">CharacterRange</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="operator">,</span> <span class="string">&quot;z&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringTake</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringDrop</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringPart</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringTake</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">12</span><span class="operator">,</span> <span class="number">16</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringTake</span><span class="punctuation">[</span><span class="variable">alphabet</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">12</span> <span class="operator">;;</span> <span class="number">16</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>字符串模式：<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">d</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">c</span><span class="operator">,</span> <span class="variable">d</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="string">&quot;abcd&quot;</span><span class="operator">,</span> <span class="type">___</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">___</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="string">&quot;abccd&quot;</span><span class="operator">,</span> <span class="type">___</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">___</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringFreeQ</span><span class="punctuation">[</span><span class="string">&quot;aabbccdd&quot;</span><span class="operator">,</span> <span class="string">&quot;bc&quot;</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="string">&quot;d&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringCases</span><span class="punctuation">[</span><span class="string">&quot;aabbccdd&quot;</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringCases</span><span class="punctuation">[</span><span class="string">&quot;aabbccdd&quot;</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">:&gt;</span> <span class="variable">x</span> <span class="operator">&lt;&gt;</span> <span class="variable">x</span> <span class="operator">&lt;&gt;</span> <span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringPosition</span><span class="punctuation">[</span><span class="string">&quot;aabbccdd&quot;</span><span class="operator">,</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">x_</span> <span class="operator">~~</span> <span class="type">y_</span> <span class="operator">~~</span> <span class="type">y_</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringCount</span><span class="punctuation">[</span><span class="string">&quot;abcadcadcbqwertaac&quot;</span><span class="operator">,</span> <span class="string">&quot;a&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringCount</span><span class="punctuation">[</span><span class="string">&quot;abcadcadcbqwertaac&quot;</span><span class="operator">,</span> <span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">_</span> <span class="operator">~~</span> <span class="string">&quot;c&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringReplace</span><span class="punctuation">[</span><span class="string">&quot;abbaabbaa&quot;</span><span class="operator">,</span> <span class="string">&quot;ab&quot;</span> <span class="operator">-&gt;</span> <span class="string">&quot;X&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringReplace</span><span class="punctuation">[</span><span class="string">&quot;ababbabbaaababa&quot;</span><span class="operator">,</span> <span class="string">&quot;ab&quot;</span> <span class="operator">..</span> <span class="operator">-&gt;</span> <span class="string">&quot;X&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringReplaceList</span><span class="punctuation">[</span><span class="string">&quot;ccccc&quot;</span><span class="operator">,</span> <span class="string">&quot;c&quot;</span> <span class="operator">-&gt;</span> <span class="string">&quot;XYX&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringReplaceList</span><span class="punctuation">[</span><span class="string">&quot;abcdeabacde&quot;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="string">&quot;abc&quot;</span> <span class="operator">-&gt;</span> <span class="string">&quot;X&quot;</span><span class="operator">,</span> <span class="string">&quot;cde&quot;</span> <span class="operator">-&gt;</span> <span class="string">&quot;Y&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringReplace</span><span class="punctuation">[</span><span class="string">&quot;the cat in the hat&quot;</span><span class="operator">,</span>  </span><br><span class="line"> <span class="built_in">Except</span><span class="punctuation">[</span><span class="built_in">Characters</span><span class="punctuation">[</span><span class="string">&quot;aeiou&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">-&gt;</span> <span class="string">&quot;&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a bbb cccc aa d&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a----bbb---ccc--dddd&quot;</span><span class="operator">,</span> <span class="string">&quot;--&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a----bbb---ccc--dddd&quot;</span><span class="operator">,</span> <span class="string">&quot;-&quot;</span> <span class="operator">..</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a--.-bbb- -|-ccc--ddd&quot;</span><span class="operator">,</span> <span class="punctuation">(</span><span class="string">&quot;-&quot;</span> <span class="operator">|</span> <span class="string">&quot;.&quot;</span> <span class="operator">|</span> <span class="string">&quot;|&quot;</span> <span class="operator">|</span> <span class="string">&quot; &quot;</span><span class="punctuation">)</span> <span class="operator">..</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>字符串的完整形式：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">_</span> <span class="operator">~~</span> <span class="string">&quot;b&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">__</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">___</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">..</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">FullForm</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span> <span class="operator">...</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Repeated</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">RepeatedNull</span><span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>其他字符串模式：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a bbb \t cc \rcc aa \n d&quot;</span><span class="operator">,</span> <span class="built_in">Whitespace</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a384bcibeyu198e7wr&quot;</span><span class="operator">,</span> <span class="built_in">CharacterRange</span><span class="punctuation">[</span><span class="string">&quot;0&quot;</span><span class="operator">,</span> <span class="string">&quot;9&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringSplit</span><span class="punctuation">[</span><span class="string">&quot;a384bcibeyu198e7wr&quot;</span><span class="operator">,</span> <span class="built_in">LetterCharacter</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="string">&quot;abaababb&quot;</span><span class="operator">,</span> <span class="built_in">StartOfString</span> <span class="operator">~~</span> <span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="type">__</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="string">&quot;abaababb&quot;</span><span class="operator">,</span> <span class="type">__</span> <span class="operator">~~</span> <span class="string">&quot;a&quot;</span> <span class="operator">~~</span> <span class="built_in">EndOfString</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><br>将一般的表达式转换为字符串搜索会提速：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">test</span> <span class="operator">=</span> <span class="built_in">Range</span><span class="punctuation">[</span><span class="number">1000</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="variable">test</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="number">50</span><span class="operator">,</span> <span class="number">75</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Position</span><span class="punctuation">[</span><span class="variable">test</span><span class="operator">,</span> <span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">MatchQ</span><span class="punctuation">[</span><span class="variable">test</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">&#125;</span><span class="punctuation">]</span> <span class="operator">//</span> <span class="built_in">Timing</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">50</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">75</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">3.71875</span><span class="operator">,</span> <span class="built_in">True</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">teststr</span> <span class="operator">=</span> <span class="built_in">FromCharacterCode</span><span class="punctuation">[</span><span class="variable">test</span><span class="punctuation">]</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">StringPosition</span><span class="punctuation">[</span><span class="variable">teststr</span><span class="operator">,</span> <span class="built_in">FromCharacterCode</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">StringMatchQ</span><span class="punctuation">[</span><span class="variable">teststr</span><span class="operator">,</span> </span><br><span class="line">  <span class="built_in">StringExpression</span><span class="punctuation">[</span><span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="operator">,</span> <span class="type">x_</span><span class="operator">,</span> <span class="type">___</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">//</span> <span class="built_in">Timing</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">5</span><span class="operator">,</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">50</span><span class="operator">,</span> <span class="number">50</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="punctuation">&#123;</span><span class="number">75</span><span class="operator">,</span> <span class="number">75</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="punctuation">&#123;</span><span class="number">0.015625</span><span class="operator">,</span> <span class="built_in">True</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F13376661231%2F641&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1660719664&amp;t=7a06182fcd2599240cf9b86397be591b&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;


&lt;blockquote&gt;
&lt;p&gt; B站课程链接：&lt;a href=&quot;https://www.bilibili.com/video/BV1av411N7Xi?spm_id_from=333.999.0.0&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;https://www.bilibili.com/video/BV1av411N7Xi?spm_id_from=333.999.0.0&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://www.hfcouc.work/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Mathematica" scheme="https://www.hfcouc.work/tags/Mathematica/"/>
    
  </entry>
  
  <entry>
    <title>Statistical Rethinking:Chapter5</title>
    <link href="https://www.hfcouc.work/2022/07/16/rt5/"/>
    <id>https://www.hfcouc.work/2022/07/16/rt5/</id>
    <published>2022-07-16T09:34:46.000Z</published>
    <updated>2022-07-16T09:40:29.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Multivariate-Linear-Models"><a href="#Multivariate-Linear-Models" class="headerlink" title="Multivariate Linear Models"></a>Multivariate Linear Models</h2><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/MLN1.png" alt=""></p><span id="more"></span><p>美国平均每人多少华夫饼店与离婚率存在着相关关系，一般某个州平均每人每个华夫饼店的数量越多，离婚率越高，但是两者之间并没有明显的因果关系，主要是南部的州含有较多的华夫饼店并且不允许未婚同居。所以相关性在自然界非常常见，但是相关并不意味着因果关系，我们需要工具来区分单纯的关联和因果关系。这就是为什么如此多的统计工作致力于多元回归，使用多个预测变量来模拟输出变量。</p><h3 id="Spurious-association"><a href="#Spurious-association" class="headerlink" title="Spurious association"></a>Spurious association</h3><p>假设我们用结婚率和结婚时的年龄两个变量来预测离婚率，我们的模型为：</p><script type="math/tex; mode=display">\begin{aligned}D_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta_{R} R_{i}+\beta_{A} A_{i} \\\alpha & \sim \operatorname{Normal}(10,10) \\\beta_{R} & \sim \operatorname{Normal}(0,1) \\\beta_{A} & \sim \operatorname{Normal}(0,1) \\\sigma & \sim \operatorname{Uniform}(0,10)\end{aligned}</script><p>下面我们拟合模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归一化数据</span></span><br><span class="line">d$MedianAgeMarriage.s &lt;- (d$MedianAgeMarriage-mean(d$MedianAgeMarriage))/</span><br><span class="line">  sd(d$MedianAgeMarriage)</span><br><span class="line"></span><br><span class="line">d$Marriage.s &lt;- (d$Marriage - mean(d$Marriage))/sd(d$Marriage)</span><br><span class="line"></span><br><span class="line">m5.3 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    Divorce ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + bR*Marriage.s + bA*MedianAgeMarriage.s,</span><br><span class="line">    a ~ dnorm(<span class="number">10</span>, <span class="number">10</span>),</span><br><span class="line">    bR ~ dnorm(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    bA ~ dnorm(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  ),</span><br><span class="line">  data = d</span><br><span class="line">)</span><br><span class="line">precis(m5.3)</span><br><span class="line"></span><br><span class="line">       mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a      <span class="number">9.69</span> <span class="number">0.20</span>  <span class="number">9.36</span> <span class="number">10.01</span></span><br><span class="line">bR    -<span class="number">0.13</span> <span class="number">0.28</span> -<span class="number">0.58</span>  <span class="number">0.31</span></span><br><span class="line">bA    -<span class="number">1.13</span> <span class="number">0.28</span> -<span class="number">1.58</span> -<span class="number">0.69</span></span><br><span class="line">sigma  <span class="number">1.44</span> <span class="number">0.14</span>  <span class="number">1.21</span>  <span class="number">1.67</span></span><br></pre></td></tr></table></figure><p>可以看到bR非常接近于零，而bA的值离零很远。我们可以说，一旦我们知道了一个州的结婚年龄的中位数，就几乎没有或没有额外的预测能力来了解该州的结婚率。</p><p>我们也可以绘制多元后验，包括：</p><ul><li>Predictor residual plots：这些图展示输出值与预测残差值的关系</li><li>Counterfactual plots</li><li>Posterior prediction plots</li></ul><p>下面先看Predictor residual plots：<br>在我们关于离婚率的多变量模型中，我们有两个预测变量(结婚率和结婚年龄的中位数)。为了计算每一个的预测残差，我们需要利用另一个预测变量对其进行建模，因此对于结婚率，下列模型是我们需要的：</p><script type="math/tex; mode=display">\begin{aligned}R_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta A_{i} \\\alpha & \sim \operatorname{Normal}(0,10) \\\beta & \sim \operatorname{Normal}(0,1) \\\sigma & \sim \operatorname{Uniform}(0,10)\end{aligned}</script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m5.4 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    Marriage.s ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + b*MedianAgeMarriage.s,</span><br><span class="line">    a ~ dnorm(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">    b ~ dnorm(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  ),</span><br><span class="line">  data = d</span><br><span class="line">)</span><br><span class="line">mu &lt;- coef(m5.4)[<span class="string">&#x27;a&#x27;</span>] + coef(m5.4)[<span class="string">&#x27;b&#x27;</span>]*d$MedianAgeMarriage.s</span><br><span class="line">m.resid &lt;- d$Marriage.s - mu</span><br></pre></td></tr></table></figure><p>得到残差，我们可以以它为横坐标，以离婚率为纵坐标绘制如下图所示的图：<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/MLN2.jpg" alt=""></p><blockquote><p>左边的图，垂直的虚线表示结婚率等于预测值(残差为零)，左边的区域表示结婚率低于期望值，而右边的区域表示结婚率高于期望值。左右两边的离婚率大小大致相等，所以说明结婚率和离婚率的关系较小。也可以将残差理解为结婚率在去除结婚年龄的中位数的影响后得到的东西。<br>右边的图类似。</p></blockquote><p>Counterfactual plots：固定一个变量不变，其他变量对于输出变量的影响。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A.avg &lt;- mean(d$MedianAgeMarriage.s)</span><br><span class="line">R.seq &lt;- seq(from=-<span class="number">3</span>, to=<span class="number">3</span>, length.out=<span class="number">30</span>)</span><br><span class="line">pred.data &lt;- data.frame(</span><br><span class="line">  Marriage.s = R.seq,</span><br><span class="line">  MedianAgeMarriage.s=A.avg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">mu &lt;- link(m5.3, data = pred.data)</span><br><span class="line">mu.mean &lt;- apply(mu, <span class="number">2</span>, mean)</span><br><span class="line">mu.PI &lt;- apply(mu, <span class="number">2</span>, PI)</span><br><span class="line"></span><br><span class="line">R.sim &lt;- sim(m5.3, data = pred.data, n=<span class="number">1e4</span>)</span><br><span class="line">R.PI &lt;- apply(R.sim, <span class="number">2</span>, PI)</span><br><span class="line"></span><br><span class="line">plot(Divorce ~ Marriage.s, data=d, type=<span class="string">&quot;n&quot;</span>)</span><br><span class="line">mtext(<span class="string">&quot;MedianAgeMarriage.s=0&quot;</span>)</span><br><span class="line">lines(R.seq, mu.mean)</span><br><span class="line">shade(mu.PI, R.seq)</span><br><span class="line">shade(R.PI, R.seq)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们也可以绘制另一个变量的结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R.avg &lt;- mean( d$Marriage.s )</span><br><span class="line">A.seq &lt;- seq( from=-<span class="number">3</span> , to=<span class="number">3.5</span> , length.out=<span class="number">30</span> )</span><br><span class="line">pred.data2 &lt;- data.frame(</span><br><span class="line">Marriage.s=R.avg, </span><br><span class="line">MedianAgeMarriage.s=A.seq</span><br><span class="line">)</span><br><span class="line">mu &lt;- link( m5.3 , data=pred.data2 )</span><br><span class="line">mu.mean &lt;- apply( mu , <span class="number">2</span> , mean )</span><br><span class="line">mu.PI &lt;- apply( mu , <span class="number">2</span> , PI )</span><br><span class="line">A.sim &lt;- sim( m5.3 , data=pred.data2 , n=<span class="number">1e4</span> )</span><br><span class="line">A.PI &lt;- apply( A.sim , <span class="number">2</span> , PI )</span><br><span class="line">plot( Divorce ~ MedianAgeMarriage.s , data=d , type=<span class="string">&quot;n&quot;</span> ) </span><br><span class="line">mtext( <span class="string">&quot;Marriage.s = 0&quot;</span> )</span><br><span class="line">lines( A.seq , mu.mean ) </span><br><span class="line">shade( mu.PI , A.seq ) </span><br><span class="line">shade( A.PI , A.seq )</span><br></pre></td></tr></table></figure><p>结果为<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/MLN3.jpg" alt=""></p><blockquote><p>由此可以看出结婚率与离婚率几乎没有什么关系。</p></blockquote><p>Posterior prediction plots：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mu &lt;- link(m5.3)</span><br><span class="line">mu.mean &lt;- apply(mu, <span class="number">2</span>, mean)</span><br><span class="line">mu.PI &lt;- apply(mu, <span class="number">2</span>, PI)</span><br><span class="line"></span><br><span class="line">divorce.sim &lt;- sim(m5.3, n=<span class="number">1e4</span>)</span><br><span class="line">divorce.PI &lt;- apply(divorce.sim, <span class="number">2</span>, PI)</span><br><span class="line"></span><br><span class="line">plot(mu.mean~d$Divorce, col=rangi2, ylim=<span class="built_in">range</span>(mu.PI), xlab=<span class="string">&quot;Observed divorce&quot;</span>, ylab=<span class="string">&quot;Predicted divorce&quot;</span>)</span><br><span class="line">abline(a=<span class="number">0</span>, b=<span class="number">1</span>, lty=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:nrow(d)) &#123;</span><br><span class="line">  lines(<span class="built_in">rep</span>(d$Divorce[i],<span class="number">2</span>), <span class="built_in">c</span>(mu.PI[<span class="number">1</span>,i], mu.PI[<span class="number">2</span>,i]),col=rangi2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用另一种方法绘制：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">divorce.resid &lt;- d$Divorce - mu.mean</span><br><span class="line">o &lt;- order(divorce.resid)</span><br><span class="line">dotchart(divorce.resid[o], labels = d$Loc[o], xlim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">5</span>),cex=<span class="number">0.6</span>)</span><br><span class="line">abline(v=<span class="number">0</span>, col=col.alpha(<span class="string">&quot;black&quot;</span>,<span class="number">0.2</span>))</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:nrow(d)) &#123;</span><br><span class="line">  j &lt;- o[i]</span><br><span class="line">  lines(d$Divorce[j]-<span class="built_in">c</span>(mu.PI[<span class="number">1</span>,j], mu.PI[<span class="number">2</span>,j]), <span class="built_in">rep</span>(i,<span class="number">2</span>))</span><br><span class="line">  points(d$Divorce[j]-<span class="built_in">c</span>(divorce.PI[<span class="number">1</span>,j], divorce.PI[<span class="number">2</span>,j]), <span class="built_in">rep</span>(i,<span class="number">2</span>),</span><br><span class="line">         pch=<span class="number">3</span>, cex=<span class="number">0.6</span>, col=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Masked-relationship"><a href="#Masked-relationship" class="headerlink" title="Masked relationship"></a>Masked relationship</h3><p>下面我们将使用一个新的数据集：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">d &lt;- milk</span><br></pre></td></tr></table></figure><p>我们考虑数据集中的如下三个变量：</p><ul><li><code>kcal.per.g</code>：每克牛奶的卡路里热量</li><li><code>mass</code>：雌性平均体重，单位千克</li><li><code>neocortex.perc</code>：新皮质质量占大脑总质量的百分比<br>这里的问题是牛奶的能量含量（这里用千卡来衡量）与大脑新皮层的百分比有关。我们最终也需要雌性体重，以查看隐藏变量之间关系的掩蔽。<br>我们首先需要删除含有缺失值的行：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcc &lt;- d[complete.cases(d),]</span><br></pre></td></tr></table></figure><p>下面我们构建模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m5.5 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + bn*neocortex.perc,</span><br><span class="line">    a ~ dnorm(<span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">    bn ~ dnorm(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">  ),</span><br><span class="line">  data = dcc</span><br><span class="line">)</span><br><span class="line">precis(m5.5)</span><br><span class="line"></span><br><span class="line">&gt; precis(m5.5, digits = <span class="number">3</span>)</span><br><span class="line">       mean    sd   <span class="number">5.5</span>% 94.5%</span><br><span class="line">a     <span class="number">0.353</span> <span class="number">0.471</span> -<span class="number">0.399</span> <span class="number">1.106</span></span><br><span class="line">bn    <span class="number">0.005</span> <span class="number">0.007</span> -<span class="number">0.007</span> <span class="number">0.016</span></span><br><span class="line">sigma <span class="number">0.166</span> <span class="number">0.028</span>  <span class="number">0.120</span> <span class="number">0.211</span></span><br></pre></td></tr></table></figure><p>可以用<code>neocortex.perc</code>来拟合模型得到的结果并不好，系数接近于0。下面我们用变量<code>mass</code>的对数试一下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dcc$log.mass &lt;- <span class="built_in">log</span>(dcc$mass)</span><br><span class="line">m5.6 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm( mu , sigma ) ,</span><br><span class="line">    mu &lt;- a + bm*log.mass ,</span><br><span class="line">    a ~ dnorm ( <span class="number">0</span> , <span class="number">100</span> ) ,</span><br><span class="line">    bm ~ dnorm ( <span class="number">0</span> , <span class="number">1</span> ) ,</span><br><span class="line">    sigma ~ dunif( <span class="number">0</span> , <span class="number">1</span> )</span><br><span class="line">  ) ,</span><br><span class="line">  data=dcc )</span><br><span class="line">precis(m5.6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a      <span class="number">0.71</span> <span class="number">0.05</span>  <span class="number">0.63</span>  <span class="number">0.78</span></span><br><span class="line">bm    -<span class="number">0.03</span> <span class="number">0.02</span> -<span class="number">0.06</span>  <span class="number">0.00</span></span><br><span class="line">sigma  <span class="number">0.16</span> <span class="number">0.03</span>  <span class="number">0.11</span>  <span class="number">0.20</span></span><br></pre></td></tr></table></figure><p>可以看到结果也不是很好，那么我们试试将两个变量同时加入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">m5.7 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    kcal.per.g ~ dnorm( mu , sigma ) ,</span><br><span class="line">    mu &lt;- a + bn*neocortex.perc + bm*log.mass ,</span><br><span class="line">    a ~ dnorm ( <span class="number">0</span> , <span class="number">100</span> ) ,</span><br><span class="line">    bn ~ dnorm ( <span class="number">0</span> , <span class="number">1</span> ) ,</span><br><span class="line">    bm ~ dnorm ( <span class="number">0</span> , <span class="number">1</span> ) ,</span><br><span class="line">    sigma ~ dunif( <span class="number">0</span> , <span class="number">1</span> )</span><br><span class="line">  ) ,</span><br><span class="line">  data=dcc)</span><br><span class="line">precis(m5.7)</span><br><span class="line"></span><br><span class="line">&gt; precis(m5.7)</span><br><span class="line">       mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a     -<span class="number">1.08</span> <span class="number">0.47</span> -<span class="number">1.83</span> -<span class="number">0.34</span></span><br><span class="line">bn     <span class="number">0.03</span> <span class="number">0.01</span>  <span class="number">0.02</span>  <span class="number">0.04</span></span><br><span class="line">bm    -<span class="number">0.10</span> <span class="number">0.02</span> -<span class="number">0.13</span> -<span class="number">0.06</span></span><br><span class="line">sigma  <span class="number">0.11</span> <span class="number">0.02</span>  <span class="number">0.08</span>  <span class="number">0.15</span></span><br></pre></td></tr></table></figure><p>可以看到当两个变量结合后其与预测变量的相关性都得到了提升。<br>下面我们绘制在<code>log(mass)</code>固定的情况下其余两个变量之间的关系：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mean.log.mass &lt;- mean( <span class="built_in">log</span>(dcc$mass) ) </span><br><span class="line">np.seq &lt;- 0:<span class="number">100</span></span><br><span class="line">pred.data &lt;- data.frame(</span><br><span class="line">  neocortex.perc=np.seq, </span><br><span class="line">  log.mass=mean.log.mass</span><br><span class="line">)</span><br><span class="line">mu &lt;- link( m5.7 , data=pred.data , n=<span class="number">1e4</span> )</span><br><span class="line">mu.mean &lt;- apply( mu , <span class="number">2</span> , mean )</span><br><span class="line">mu.PI &lt;- apply( mu , <span class="number">2</span> , PI )</span><br><span class="line">plot( kcal.per.g ~ neocortex.perc , data=dcc , type=<span class="string">&quot;n&quot;</span> ) </span><br><span class="line">lines( np.seq , mu.mean )</span><br><span class="line">lines( np.seq , mu.PI[<span class="number">1</span>,] , lty=<span class="number">2</span> ) </span><br><span class="line">lines( np.seq , mu.PI[<span class="number">2</span>,] , lty=<span class="number">2</span> )</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/MLN4.jpeg" alt=""><br>可以看到<code>neocortex.perc</code>与<code>kcal.per.g</code>的相关性得到了增强。为什么将新皮质和体重添加到同一模型中会导致两者的估计效应更大？在这种情况下，有两个变量与结果相关，但一个与结果正相关，另一个与结果负相关。此外，两个解释变量彼此呈正相关。结果，它们倾向于相互抵消。<br>也就是说当两个变量单独与结果的关系较弱，但是两个变量之间存在着正相关，可以相互促进对结果的影响。</p><h3 id="When-adding-variables-hurts"><a href="#When-adding-variables-hurts" class="headerlink" title="When adding variables hurts"></a>When adding variables hurts</h3><p>为什么在上面的例子中不使用所有的变量呢？这是因为使用所有的变量会存在以下问题：</p><ol><li>多重共线性</li><li>post-treatment bias</li><li>过拟合<br>多重共线性会导致与结果没有多少关联性的变量也会得到很大的关联性。<br>下面我们看一个例子，我们知道人的身高与其腿长存在关系，我们按照下述方式生成体长和腿长的数据：</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N &lt;- 100 <span class="comment"># number of individuals</span></span><br><span class="line">height &lt;- rnorm(N,<span class="number">10</span>,<span class="number">2</span>) <span class="comment"># sim total height of each</span></span><br><span class="line">leg_prop &lt;- runif(N,<span class="number">0.4</span>,<span class="number">0.5</span>) <span class="comment"># leg as proportion of height</span></span><br><span class="line">leg_left &lt;- leg_prop*height + <span class="comment"># sim left leg as proportion + error</span></span><br><span class="line">  rnorm( N , <span class="number">0</span> , <span class="number">0.02</span> )</span><br><span class="line">leg_right &lt;- leg_prop*height + <span class="comment"># sim right leg as proportion + error</span></span><br><span class="line">  rnorm( N , <span class="number">0</span> , <span class="number">0.02</span> )</span><br><span class="line"><span class="comment"># combine into data frame</span></span><br><span class="line">d &lt;- data.frame(height,leg_left,leg_right)</span><br></pre></td></tr></table></figure><p>在拟合模型之前我们预测体长与腿长的系数应该大约为体长的均值除以腿长比例的均值$10/4.5=2.2$，但是结果却为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m5.8 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    height ~ dnorm( mu , sigma ) ,</span><br><span class="line">    mu &lt;- a + bl*leg_left + br*leg_right ,</span><br><span class="line">    a ~ dnorm( <span class="number">10</span> , <span class="number">100</span> ) ,</span><br><span class="line">    bl ~ dnorm( <span class="number">2</span> , <span class="number">10</span> ) ,</span><br><span class="line">    br ~ dnorm( <span class="number">2</span> , <span class="number">10</span> ) ,</span><br><span class="line">    sigma ~ dunif( <span class="number">0</span> , <span class="number">10</span> )</span><br><span class="line">  ) , </span><br><span class="line">  data=d )</span><br><span class="line">precis(m5.8)</span><br><span class="line"></span><br><span class="line">      mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a     <span class="number">1.16</span> <span class="number">0.32</span>  <span class="number">0.64</span>  <span class="number">1.67</span></span><br><span class="line">bl    <span class="number">0.02</span> <span class="number">2.23</span> -<span class="number">3.55</span>  <span class="number">3.58</span></span><br><span class="line">br    <span class="number">1.96</span> <span class="number">2.21</span> -<span class="number">1.58</span>  <span class="number">5.50</span></span><br><span class="line">sigma <span class="number">0.61</span> <span class="number">0.04</span>  <span class="number">0.54</span>  <span class="number">0.68</span></span><br></pre></td></tr></table></figure><p>与我们的预测相差很大。<br>这是因为左右腿的长度具有明显的共线性，我们可以将其看作同一个变量，即：</p><script type="math/tex; mode=display">\begin{aligned}&y_{i} \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\&\mu_{i}=\alpha+\left(\beta_{1}+\beta_{2}\right) x_{i}\end{aligned}</script><p>这样的话，我们估计出来的$\beta_1+\beta_2$应该是准确的，而$\beta_1,\beta_2$之中的一个大会导致另一个小。</p><p>Post-treatment bias：因为包含其他预测变量而对后验估计产生影响。下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># number of plants</span></span><br><span class="line">N &lt;- 100</span><br><span class="line"><span class="comment"># simulate initial heights </span></span><br><span class="line">h0 &lt;- rnorm(N,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># assign treatments and simulate fungus and growth </span></span><br><span class="line">treatment &lt;- <span class="built_in">rep</span>( <span class="number">0</span>:<span class="number">1</span> , each=N/<span class="number">2</span> )</span><br><span class="line">fungus &lt;- rbinom( N , size=<span class="number">1</span> , prob=<span class="number">0.5</span> - treatment*<span class="number">0.4</span> )</span><br><span class="line">h1 &lt;- h0 + rnorm(N, <span class="number">5</span> - <span class="number">3</span>*fungus)</span><br><span class="line"><span class="comment"># compose a clean data frame</span></span><br><span class="line">d &lt;- data.frame( h0=h0 , h1=h1 , treatment=treatment , fungus=fungus )</span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">~~~R</span><br><span class="line">m5.13 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    h1 ~ dnorm(mu,sigma),</span><br><span class="line">    mu &lt;- a + bh*h0 + bt*treatment + bf*fungus,</span><br><span class="line">    a ~ dnorm(<span class="number">0</span>,<span class="number">100</span>),</span><br><span class="line">    <span class="built_in">c</span>(bh,bt,bf) ~ dnorm(<span class="number">0</span>,<span class="number">10</span>), </span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">  ),</span><br><span class="line">  data=d )</span><br><span class="line">precis(m5.13)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       mean   sd  <span class="number">5.5</span>% 94.5%</span><br><span class="line">a      <span class="number">4.85</span> <span class="number">0.50</span>  <span class="number">4.06</span>  <span class="number">5.65</span></span><br><span class="line">bh     <span class="number">1.01</span> <span class="number">0.05</span>  <span class="number">0.93</span>  <span class="number">1.08</span></span><br><span class="line">bt     <span class="number">0.05</span> <span class="number">0.21</span> -<span class="number">0.29</span>  <span class="number">0.38</span></span><br><span class="line">bf    -<span class="number">2.57</span> <span class="number">0.22</span> -<span class="number">2.92</span> -<span class="number">2.22</span></span><br><span class="line">sigma  <span class="number">0.91</span> <span class="number">0.06</span>  <span class="number">0.80</span>  <span class="number">1.01</span></span><br></pre></td></tr></table></figure><p>我们知道我们的照料(treatment)对植物的照料很重要，但是结果显示其影响很小，这是因为真菌(fungus)是照料的结果，添加post-treatment(fungus)会掩盖treatment的结果，这是因为知道了真菌再知不知道treatment对结果已经不重要了。</p><h3 id="Categorical-variables"><a href="#Categorical-variables" class="headerlink" title="Categorical variables"></a>Categorical variables</h3><p>二分类变量例子：男女身高：</p><script type="math/tex; mode=display">\begin{aligned}h_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta_{m} m_{i} \\\alpha & \sim \operatorname{Normal}(178,100) \\\beta_{m} & \sim \operatorname{Normal}(0,10) \\\sigma & \sim \operatorname{Uniform}(0,50)\end{aligned}</script><p>$m_i=1$表示男性，$m_i=0$表示女性。<br>多分类变量：对于多分类变量，我们可以这样对其进行编码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data(milk) </span><br><span class="line">d &lt;- milk</span><br><span class="line">unique(d$clade)</span><br><span class="line">d$clade.NWM &lt;- ifelse( d$clade==<span class="string">&quot;New World Monkey&quot;</span> , <span class="number">1</span> , <span class="number">0</span> )</span><br><span class="line">d$clade.OWM &lt;- ifelse( d$clade==<span class="string">&quot;Old World Monkey&quot;</span> , <span class="number">1</span> , <span class="number">0</span> )</span><br><span class="line">d$clade.S &lt;- ifelse( d$clade==<span class="string">&quot;Strepsirrhine&quot;</span> , <span class="number">1</span> , <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>构建模型为：</p><script type="math/tex; mode=display">\begin{aligned}k_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta_{\mathrm{NWM}} \mathrm{NWM}_{i}+\beta_{\mathrm{OWM}} \mathrm{OWM}_{i}+\beta_{\mathrm{S}} \mathrm{S}_{i} \\\alpha & \sim \operatorname{Normal}(0.6,10) \\\beta_{\mathrm{NWM}} & \sim \operatorname{Normal}(0,1) \\\beta_{\mathrm{OWM}} & \sim \operatorname{Normal}(0,1) \\\beta_{\mathrm{S}} & \sim \operatorname{Normal}(0,1) \\\sigma & \sim \operatorname{Uniform}(0,10)\end{aligned}</script><p>还有另一种构建方法，即采用索引的方法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对不同类别采用不同的索引</span></span><br><span class="line">( d$clade_id &lt;- coerce_index(d$clade) )</span><br><span class="line"></span><br><span class="line">m5.16_alt &lt;- map(</span><br><span class="line">alist(</span><br><span class="line">kcal.per.g ~ dnorm( mu , sigma ) ,</span><br><span class="line">mu &lt;- a[clade_id] ,</span><br><span class="line">a[clade_id] ~ dnorm( <span class="number">0.6</span> , <span class="number">10</span> ) , </span><br><span class="line">sigma ~ dunif( <span class="number">0</span> , <span class="number">10</span> )</span><br><span class="line">) , </span><br><span class="line">data=d )</span><br><span class="line">precis( m5.16_alt , depth=<span class="number">2</span> )</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Multivariate-Linear-Models&quot;&gt;&lt;a href=&quot;#Multivariate-Linear-Models&quot; class=&quot;headerlink&quot; title=&quot;Multivariate Linear Models&quot;&gt;&lt;/a&gt;Multivariate Linear Models&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/HFC666/image/master/img/MLN1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="书籍阅读" scheme="https://www.hfcouc.work/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="概率编程" scheme="https://www.hfcouc.work/tags/%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B/"/>
    
    <category term="贝叶斯统计" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1/"/>
    
    <category term="Statistical Rethinking" scheme="https://www.hfcouc.work/tags/Statistical-Rethinking/"/>
    
  </entry>
  
  <entry>
    <title>Statistical Rethinking:Chapter4</title>
    <link href="https://www.hfcouc.work/2022/07/14/rt4/"/>
    <id>https://www.hfcouc.work/2022/07/14/rt4/</id>
    <published>2022-07-14T03:28:53.000Z</published>
    <updated>2022-07-16T09:39:33.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Linear-Models"><a href="#Linear-Models" class="headerlink" title="Linear Models"></a>Linear Models</h2><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM1.png" alt=""></p><span id="more"></span><p>托勒密的地心说在一段时间内曾经占据天文学的统治地位。托勒密用轨道内的轨道即本轮(epicycles)来描述行星复杂的活动，如下图所示。虽然这个模型现在看来是错的，但是却具有很高的预测准确度。<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM2.jpg" alt=""><br>线性回归(Linear Regression)为应用统计的地心模型。与地心说一样，线性回归可以有效地描述各种各样的自然现象。但是如果我们用线性回归描述线性内部的原理结果，我们将很容易犯错误。即虽然可能会得到很好的预测，但是其内部的机制不一定正确。</p><h3 id="Why-normal-distributions-are-normal"><a href="#Why-normal-distributions-are-normal" class="headerlink" title="Why normal distributions are normal"></a>Why normal distributions are normal</h3><h4 id="Normal-by-addition"><a href="#Normal-by-addition" class="headerlink" title="Normal by addition"></a>Normal by addition</h4><p>任何将来自同一分布的随机值相加的过程都会收敛到正态分布。这可以理解为产生此数据的源分布产生的数据为此数据的均值加上一个随机波动，随着数据数量的增多，随机波动逐渐互相抵消，均值处数据最多，得到正态分布。</p><h4 id="Normal-by-multiplication"><a href="#Normal-by-multiplication" class="headerlink" title="Normal by multiplication"></a>Normal by multiplication</h4><p>下面是另一种方法来得到高斯分布。假设每年的增长率位于$1.0\sim 1.1$，经过$12$年，总增长率为：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">prod</span>(<span class="number">1</span> + runif(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0.1</span>))</span><br></pre></td></tr></table></figure><br>那么总增长率的分布为什么？我们采$10000$个样绘制其概率分布：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">growth &lt;- replicate(<span class="number">10000</span>, <span class="built_in">prod</span>(<span class="number">1</span>+runif(<span class="number">12</span>,<span class="number">0</span>,<span class="number">0.1</span>)))</span><br><span class="line">dens(growth, norm.comp=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><br>得到的结果如下：<br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM3.jpeg" alt=""><br>可以看到近似正态分布。我们之前说过正态分布可以通过将随机波动相加得到，但是我们这里是相乘，为什么也会得到正态分布呢？<br>这是因为我们每次相乘的生长率很小，可以近似于加法，如：</p><script type="math/tex; mode=display">1.1\times1.1=1.21=(1+0.1)(1+0.1)=1+0.2+0.01\approx 1.2</script><h4 id="Normal-by-log-multiplication"><a href="#Normal-by-log-multiplication" class="headerlink" title="Normal by log-multiplication"></a>Normal by log-multiplication</h4><p>相乘大的增长率不会产生高斯分布，但是它们的对数会产生高斯分布：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.big &lt;- replicate(<span class="number">10000</span>, <span class="built_in">log</span>(<span class="built_in">prod</span>(<span class="number">1</span>+runif(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0.5</span>))))</span><br><span class="line">dens(log.big, norm.comp=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM4.jpeg" alt=""></p><h4 id="Using-Gaussian-distributions"><a href="#Using-Gaussian-distributions" class="headerlink" title="Using Gaussian distributions"></a>Using Gaussian distributions</h4><p>使用高斯分布主要有两个原因：一个是因为其在自然界中分布广泛，另一个原因是[[EXP]]，根据指数分布的性质，高斯分布作为指数分布的特例，具有最大熵(包含最少信息)。</p><h3 id="A-language-for-describing-models"><a href="#A-language-for-describing-models" class="headerlink" title="A language for describing models"></a>A language for describing models</h3><p>统计模型一般采用下述方法表示：</p><script type="math/tex; mode=display">\begin{aligned}\text { outcome }_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\beta \times \operatorname{predictor}{ }_{i} \\\beta & \sim \operatorname{Normal}(0,10) \\\sigma & \sim \operatorname{HalfCauchy}(0,1)\end{aligned}</script><h3 id="A-Gaussian-model-of-height"><a href="#A-Gaussian-model-of-height" class="headerlink" title="A Gaussian model of height"></a>A Gaussian model of height</h3><h4 id="The-data"><a href="#The-data" class="headerlink" title="The data"></a>The data</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data(<span class="string">&quot;Howell1&quot;</span>)</span><br><span class="line">d &lt;- Howell1</span><br><span class="line">d2 &lt;- d[d$age &gt;= <span class="number">18</span>,]</span><br></pre></td></tr></table></figure><h4 id="The-model"><a href="#The-model" class="headerlink" title="The model"></a>The model</h4><p>假设我们的模型为：</p><script type="math/tex; mode=display">\begin{aligned}h_i &\sim \text{Normal}(\mu,\sigma)\\\mu&\sim \text{Normal}(178, 20)\\\sigma&\sim \text{Uniform}(0,50)\end{aligned}</script><h4 id="Grid-approximation-of-the-posterior-distribution"><a href="#Grid-approximation-of-the-posterior-distribution" class="headerlink" title="Grid approximation of the posterior distribution"></a>Grid approximation of the posterior distribution</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mu.list &lt;- seq(from=<span class="number">140</span>, to=<span class="number">160</span>, length.out=<span class="number">200</span>)</span><br><span class="line">sigma.list &lt;- seq(from=<span class="number">4</span>, to=<span class="number">9</span>, length.out=<span class="number">200</span>)</span><br><span class="line">post &lt;- expand.grid(mu=mu.list, sigma=sigma.list)</span><br><span class="line">post$LL &lt;- sapply(<span class="number">1</span>:nrow(post), <span class="keyword">function</span>(i) <span class="built_in">sum</span>(</span><br><span class="line">  dnorm(d2$height, mean = post$mu[i], sd=post$sigma[i], <span class="built_in">log</span>=<span class="literal">TRUE</span>)</span><br><span class="line">))</span><br><span class="line">post$prod &lt;- post$LL + dnorm(post$mu, <span class="number">178</span>, <span class="number">20</span>, <span class="literal">TRUE</span>) + dunif(post$sigma, <span class="number">0</span>, <span class="number">50</span>, <span class="literal">TRUE</span>)</span><br><span class="line">post$prob &lt;- <span class="built_in">exp</span>(post$<span class="built_in">prod</span> - <span class="built_in">max</span>(post$<span class="built_in">prod</span>))</span><br></pre></td></tr></table></figure><p>你可以对结果进行绘制：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contour_xyz(post$mu, post$sigma, post$prob)</span><br></pre></td></tr></table></figure></p><h4 id="Sampling-from-the-posterior"><a href="#Sampling-from-the-posterior" class="headerlink" title="Sampling from the posterior"></a>Sampling from the posterior</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sample.rows &lt;- sample(<span class="number">1</span>:nrow(post), size = <span class="number">1e4</span>, replace = <span class="literal">TRUE</span>, prob = post$prob)</span><br><span class="line">sample.mu &lt;- post$mu[sample.rows]</span><br><span class="line">sample.sigma &lt;- post$sigma[sample.rows]</span><br></pre></td></tr></table></figure><p>绘制结果<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(sample.mu, sample.sigma, cex=<span class="number">0.5</span>, pch=<span class="number">16</span>, col=col.alpha(rangi2,<span class="number">0.1</span>))</span><br></pre></td></tr></table></figure></p><h4 id="Fitting-the-model-with-map"><a href="#Fitting-the-model-with-map" class="headerlink" title="Fitting the model with map"></a>Fitting the model with <code>map</code></h4><p>下面我们利用二次逼近来对后验分布进行估计：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flist &lt;- alist(</span><br><span class="line">  height ~ dnorm(mu, sigma),</span><br><span class="line">  mu ~ dnorm(<span class="number">178</span>, <span class="number">20</span>),</span><br><span class="line">  sigma ~ dunif(<span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line">)</span><br><span class="line">m4.1 &lt;- map(flist, data = d2)</span><br><span class="line">precis(m4.1)</span><br><span class="line"></span><br><span class="line">        mean   sd   <span class="number">5.5</span>%  94.5%</span><br><span class="line">mu    <span class="number">154.61</span> <span class="number">0.41</span> <span class="number">153.95</span> <span class="number">155.27</span></span><br><span class="line">sigma   <span class="number">7.73</span> <span class="number">0.29</span>   <span class="number">7.27</span>   <span class="number">8.20</span></span><br></pre></td></tr></table></figure><br><code>map</code>通过像爬坡一样的方式来估计后验，它需要从一个初始位置开始。我们可以指定初始位置，一个好的初始位置位于最大后验概率(MAP)处：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start &lt;- <span class="built_in">list</span>(mu=mean(d2$height), sigma = sd(d2$height) )</span><br></pre></td></tr></table></figure><br>注意这里是<code>list</code>而不是<code>alist</code>，它们两者的区别是<code>list</code>会计算你放到其内部的代码，而<code>alist</code>不会。</p><h4 id="Sampling-from-a-map-fit"><a href="#Sampling-from-a-map-fit" class="headerlink" title="Sampling from a map fit"></a>Sampling from a <code>map</code> fit</h4><p>二次逼近不止计算了每个参数的方差，还计算了它们之间的协方差，即协方差矩阵。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vcov(m4.1)</span><br><span class="line"></span><br><span class="line">               mu       sigma</span><br><span class="line">mu    <span class="number">0.169740079</span> <span class="number">0.000217271</span></span><br><span class="line">sigma <span class="number">0.000217271</span> <span class="number">0.084906413</span></span><br></pre></td></tr></table></figure><br>我们可以用<code>extract.samples</code>函数进行抽样，其实质为对多元高斯进行抽样：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post &lt;- extract.samples(m4.1, n=<span class="number">1e4</span>)</span><br></pre></td></tr></table></figure><br>$\sigma$的分布可能不是正态分布，所以我们的二次逼近可能存在问题，但是我们可以假设$\sigma$的对数为正态分布，那么变为：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m4.1_logsigma &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    height ~ dnorm(mu, <span class="built_in">exp</span>(log_sigma)),</span><br><span class="line">    mu ~ dnorm(<span class="number">178</span>, <span class="number">20</span>),</span><br><span class="line">    log_sigma ~ dnorm(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">), data =d2)</span><br><span class="line"></span><br><span class="line">post &lt;- extract.samples(m4.1_logsigma)</span><br><span class="line">sigma &lt;- <span class="built_in">exp</span>(post$log_sigma)</span><br></pre></td></tr></table></figure></p><h3 id="Adding-a-predictor"><a href="#Adding-a-predictor" class="headerlink" title="Adding a predictor"></a>Adding a predictor</h3><h4 id="The-linear-model-strategy"><a href="#The-linear-model-strategy" class="headerlink" title="The linear model strategy"></a>The linear model strategy</h4><p>我们的模型为：</p><script type="math/tex; mode=display">\begin{aligned}h_{i} & \sim \operatorname{Normal}\left(\mu_{i}, \sigma\right) \\\mu_{i} &=\alpha+\beta x_{i} \\\alpha & \sim \operatorname{Normal}(178,100) \\\beta & \sim \operatorname{Normal}(0,10) \\\sigma & \sim \operatorname{Uniform}(0,50)\end{aligned}</script><h4 id="Fitting-the-model"><a href="#Fitting-the-model" class="headerlink" title="Fitting the model"></a>Fitting the model</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m4.3 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    height ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + b*weight,</span><br><span class="line">    a ~ dnorm(<span class="number">156</span>, <span class="number">100</span>),</span><br><span class="line">    b ~ dnorm(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>,<span class="number">50</span>)</span><br><span class="line">  ),</span><br><span class="line">  data=d2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>得到的结果如下：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">precis(m4.3)</span><br><span class="line"></span><br><span class="line">        mean   sd   <span class="number">5.5</span>%  94.5%</span><br><span class="line">a     <span class="number">113.89</span> <span class="number">1.91</span> <span class="number">110.85</span> <span class="number">116.94</span></span><br><span class="line">b       <span class="number">0.90</span> <span class="number">0.04</span>   <span class="number">0.84</span>   <span class="number">0.97</span></span><br><span class="line">sigma   <span class="number">5.07</span> <span class="number">0.19</span>   <span class="number">4.77</span>   <span class="number">5.38</span></span><br></pre></td></tr></table></figure><br>我们可以查看各个参数之间的相关系数：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                  a             b         sigma</span><br><span class="line">a      <span class="number">1.0000000000</span> -<span class="number">0.9898830268</span>  <span class="number">0.0006161621</span></span><br><span class="line">b     -<span class="number">0.9898830268</span>  <span class="number">1.0000000000</span> -<span class="number">0.0005736179</span></span><br><span class="line">sigma  <span class="number">0.0006161621</span> -<span class="number">0.0005736179</span>  <span class="number">1.0000000000</span></span><br></pre></td></tr></table></figure><br>可以看出$a$与$b$几乎成负相关，这并不是我们想要的，我们可以采用下面的方法：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">d2$weight.c &lt;- d2$weight - mean(d2$weight)</span><br><span class="line"></span><br><span class="line">m4.4 &lt;- map(</span><br><span class="line">  alist(</span><br><span class="line">    height ~ dnorm(mu, sigma),</span><br><span class="line">    mu &lt;- a + b*weight.c,</span><br><span class="line">    a ~ dnorm(<span class="number">178</span>, <span class="number">100</span>),</span><br><span class="line">    b ~ dnorm(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">    sigma ~ dunif(<span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line">  ),</span><br><span class="line">  data = d2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">precis(m4.4)</span><br><span class="line">        mean   sd   <span class="number">5.5</span>%  94.5%</span><br><span class="line">a     <span class="number">154.60</span> <span class="number">0.27</span> <span class="number">154.17</span> <span class="number">155.03</span></span><br><span class="line">b       <span class="number">0.90</span> <span class="number">0.04</span>   <span class="number">0.84</span>   <span class="number">0.97</span></span><br><span class="line">sigma   <span class="number">5.07</span> <span class="number">0.19</span>   <span class="number">4.77</span>   <span class="number">5.38</span></span><br><span class="line"></span><br><span class="line">cov2cor(vcov(m4.4))</span><br><span class="line">                  a             b         sigma</span><br><span class="line">a      <span class="number">1.000000e+00</span> -<span class="number">1.630888e-11</span>  <span class="number">2.556226e-07</span></span><br><span class="line">b     -<span class="number">1.630888e-11</span>  <span class="number">1.000000e+00</span> -<span class="number">6.380061e-05</span></span><br><span class="line">sigma  <span class="number">2.556226e-07</span> -<span class="number">6.380061e-05</span>  <span class="number">1.000000e+00</span></span><br></pre></td></tr></table></figure><br>可以看到$a$和$b$的相关系数接近于零，这是因为$a$表示当体重为$0$时的身高，而变换后的体重均值为$0$，因为线性回归经过体重的均值、身高的均值这个点，而体重的均值为$0$，所以$a$就表示在体重为体重均值时身高的值，即身高的均值，所以与$b$无关。</p><p>我们也可以绘制后验分布得到的结果：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot(height~weight, data=d2)</span><br><span class="line">abline(a=coef(m4.3)[<span class="string">&quot;a&quot;</span>], b=coef(m4.3)[<span class="string">&quot;b&quot;</span>])</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM5.jpeg" alt=""><br>上图我们只是绘制了一条直线，对应于后验的均值。为了表达不确定性，我们可以对后验分布进行抽样。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post &lt;- extract.samples(m4.3, n=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plot(d2$weight, d2$height, xlim=<span class="built_in">range</span>(d2$weight), ylim=<span class="built_in">range</span>(d2$height), col=rangi2, xlab=<span class="string">&quot;weight&quot;</span>, ylab=<span class="string">&quot;height&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">20</span>) &#123;</span><br><span class="line">  abline(a=post$a[i], b=post$b[i], col=col.alpha(<span class="string">&quot;black&quot;</span>, <span class="number">0.3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM6.jpeg" alt=""><br>对于每个确定的<code>weight</code>，由于$a$和$b$都为高斯分布，所以生成的$\mu_i = a + b w_i$也服从高斯分布。我们可以使用link函数，link函数默认从后验分布中抽取$1000$个样本，对每个固定的weight根据这$1000$个样本计算其$\mu$的值。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mu &lt;- link(m4.3)</span><br><span class="line">str(mu)</span><br><span class="line"></span><br><span class="line"> num [<span class="number">1</span>:<span class="number">1000</span>, <span class="number">1</span>:<span class="number">352</span>] <span class="number">158</span> <span class="number">157</span> <span class="number">157</span> <span class="number">157</span> <span class="number">157</span> ...</span><br></pre></td></tr></table></figure><p>生成的<code>mu</code>为一个矩阵，行表示从后验分布中抽取的样本，列表示数据的数目。<br>这样我们就可以绘制在某个确定weight值上$\mu$的分布：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weight.seq &lt;- seq(from=<span class="number">25</span>, to=<span class="number">70</span>, by=<span class="number">1</span>)</span><br><span class="line">mu &lt;- link(m4.3, data = data.frame(weight=weight.seq))</span><br><span class="line">plot(height~weight, d2, type=<span class="string">&quot;n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">100</span>) &#123;</span><br><span class="line">  points(weight.seq, mu[i,], pch=<span class="number">16</span>, col=col.alpha(rangi2, <span class="number">0.1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/HFC666/image/master/img/LM7.jpeg" alt=""><br>这样我们也可以计算关于$\mu$的分布的信息了：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mu.mean &lt;- apply(mu, <span class="number">2</span>, mean)</span><br><span class="line">mu.HPDI &lt;- apply(mu, <span class="number">2</span>, HPDI, prob=<span class="number">0.89</span>)</span><br><span class="line"></span><br><span class="line">plot( height ~ weight , data=d2 , col=col.alpha(rangi2,<span class="number">0.5</span>) )</span><br><span class="line">lines( weight.seq , mu.mean )</span><br><span class="line">shade( mu.HPDI , weight.seq )</span><br></pre></td></tr></table></figure><br>之前我们只是对平均高度$\mu$进行采样，现在我们生成真实的高度height。这意味着我们也将$\sigma$的不确定性结合在一起。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sim.height &lt;- sim(m4.3, data = <span class="built_in">list</span>(weight=weight.seq))</span><br><span class="line">str(sim.height)</span><br><span class="line">height.PI &lt;- apply( sim.height , <span class="number">2</span> , PI , prob=<span class="number">0.89</span> )</span><br></pre></td></tr></table></figure><br>我们也可以绘制图：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plot(height~weight, d2, col=col.alpha(rangi2, <span class="number">0.5</span>))</span><br><span class="line">lines(weight.seq, mu.mean)</span><br><span class="line">shade(mu.HPDI, weight.seq,col=col.alpha(rangi2, <span class="number">0.5</span>))</span><br><span class="line">shade(height.PI, weight.seq,col=col.alpha(rangi2, <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure></p><blockquote><p>不知到为什么shade函数失效</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linear-Models&quot;&gt;&lt;a href=&quot;#Linear-Models&quot; class=&quot;headerlink&quot; title=&quot;Linear Models&quot;&gt;&lt;/a&gt;Linear Models&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/HFC666/image/master/img/LM1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="书籍阅读" scheme="https://www.hfcouc.work/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="概率编程" scheme="https://www.hfcouc.work/tags/%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B/"/>
    
    <category term="贝叶斯统计" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1/"/>
    
    <category term="Statistical Rethinking" scheme="https://www.hfcouc.work/tags/Statistical-Rethinking/"/>
    
  </entry>
  
  <entry>
    <title>A tutorial on Bayesian nonparametric models</title>
    <link href="https://www.hfcouc.work/2022/07/12/BN/"/>
    <id>https://www.hfcouc.work/2022/07/12/BN/</id>
    <published>2022-07-12T09:31:16.000Z</published>
    <updated>2022-07-12T09:54:16.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="A-Tutorial-on-Bayesian-Nonparametric-Models"><a href="#A-Tutorial-on-Bayesian-Nonparametric-Models" class="headerlink" title="A Tutorial on Bayesian Nonparametric Models"></a>A Tutorial on Bayesian Nonparametric Models</h2><p align="center">    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170401%2F66c0602968c0463c805dcd5ab16a87dc_th.jpeg&refer=http%3A%2F%2Fimg.mp.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660210656&t=6f0b4c7c45167ff59154a4b5ee75eb30" style="zoom: 100%;" /></p><blockquote><p>文章地址：<a href="https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X">https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X</a></p></blockquote><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>统计模型的一个核心问题就是模型选择，怎样选择模型复杂度，如在聚类问题中选择聚类的数目等。贝叶斯无参模型通过让数据确定模型复杂度来跳过模型选择的步骤。比如说在传统的机器学习中如聚类中，我们需要事先确定聚类的数目，而贝叶斯无参模型会估计聚类的数目并允许未来的数据来自之前没有的类。</p><p>一般我们进行贝叶斯推断时是对参数的后验分布进行推断，无参贝叶斯与其他贝叶斯模型显著的不同在于其隐藏结构是随着数据增长的。它的复杂度，如聚类的数目，是后验分布的一部分。这些参数无需实现给定，而是作为分析数据的一部分来确定。</p><p>在本文中我们主要介绍两种模型，混合模型(mixture models)和隐语义模型(latent factor models)。贝叶斯无参混合模型，也被称为中国餐馆过程混合(或者狄利克雷过程混合)，从数据中推断聚类的个数并且随着数据的增长允许聚类数增长。</p><p>隐语义模型将观察到的数据分解为潜在因素的线性组合。关于因子分布的不同假设会产生如因子分析、主成分分析、独立成分分析等等。印度自助餐过程隐语义模型通过数据推断因子的数量并且允许因子的数量随着新数据的加入而增加。</p><h3 id="Mixture-models-and-clustering"><a href="#Mixture-models-and-clustering" class="headerlink" title="Mixture models and clustering"></a>Mixture models and clustering</h3><p>在一个混合模型中，每一个观测数据都假设属于一个类。</p><h4 id="Finite-mixture-modeling"><a href="#Finite-mixture-modeling" class="headerlink" title="Finite mixture modeling"></a>Finite mixture modeling</h4><p>有限混合模型假设有$K$个类，每个类与参数$\theta_k$有关。每一个观测$y_n$都假设是首先通过$P(c_n)$来选择一个类$c_n$之后通过与参数$\theta_{c_n}$相对应的分布中产生观测，每一个参数对应一个分布$F(y_n\mid \theta_{c_n})$。</p><p>贝叶斯混合模型引入了混合分布$P(c)$的先验和聚类参数的先验$\theta\sim G_0$。</p><p>这个生成过程定义了关于观测、聚类分配(数据属于哪个类)和聚类参数的联合分布：</p><script type="math/tex; mode=display">P(\mathrm{y,c},\theta) = \prod_{k=1}^K G_0(\theta_k)\prod_{n=1}^NF(Y_n\mid\theta_{c_n})P(c_n)</script><p>其中观测为$\mathrm{y} = \{y_1,\cdots,y_N\}$，聚类分配为$\mathrm{c}=\{c_1,\cdots,c_N\}$，聚类参数为$\theta=\{\theta_1,\cdots,\theta_K\}$。</p><blockquote><p>这里$N$个样本相乘是因为样本之间是独立同分布的，而$K$个$G_0(\theta_k)$相乘是因为每个$\theta_k$也是独立的。</p></blockquote><p>给定数据集，我们经常对聚类分配感兴趣，我们可以用贝叶斯公式计算它们：</p><script type="math/tex; mode=display">P(\mathrm{c}\mid\mathrm{y}) = \frac{P(\mathrm{y}\mid \mathrm{c})P(\mathrm{c})}{\sum_{\mathrm{c}}P(\mathrm{y}\mid\mathrm{c})P(\mathrm{c})}</script><p>其中似然函数可以通过对$\theta$积分得到：</p><script type="math/tex; mode=display">P(\mathrm{y\mid c}) = \int_{\theta}\left[\prod_{n=1}^NF(\mathrm{y}\mid\theta_{c_n})\prod_{k=1}^KG_0(\theta_k)\right]d\theta</script><p>后验分布是很难处理的，因为计算分母需要将每种分配方式进行求和。</p><h4 id="The-Chinese-restaurant-process"><a href="#The-Chinese-restaurant-process" class="headerlink" title="The Chinese restaurant process"></a>The Chinese restaurant process</h4><p>见我的一篇博客(<a href="https://hfcouc.work/2022/07/06/BNP/)。">https://hfcouc.work/2022/07/06/BNP/)。</a></p><h3 id="Latent-factor-models-and-dimensionality-reduction"><a href="#Latent-factor-models-and-dimensionality-reduction" class="headerlink" title="Latent factor models and dimensionality reduction"></a>Latent factor models and dimensionality reduction</h3><p>混合模型假设每个数据都来自$K$个类中的一个。隐语义模型削弱了这一假设：每个观测受到$K$个分量的不同的影响。</p><p>隐语义模型可以用来降维当分量的数目小于数据维度时。每个观察都与一个分量激活向量（潜在因子）相关联，该向量描述了每个分量对其贡献的程度，并且这个向量可以看作是观察本身的低维表示。</p><p>非常著名的降维模型有因子分析(FA)，主成分分析(PCA)和独立成分分析(ICA)等，所有的都假设因子的数量$K$已经确定了。无参贝叶斯模型允许分量的数量随着数据的增长而增多。</p><p>在经典的降维模型中，我们的观测数据一般为$N$个$M$维向量，$\mathrm{Y=\{y_1,\cdots,y_N\}}$。因此$\mathrm{Y}$每行表示一个数据。数据假设是从有噪声的隐语义的加权组合产生的：</p><script type="math/tex; mode=display">\mathrm{y_n = Gx_n+\epsilon_n}</script><p>其中$\mathrm{G}$为$M\times K$的矩阵表示，表示隐语义$k$怎么影响观测维度$m$，$x_n$为一个$K$维向量表示每个隐语义的影响，其中$\epsilon_n$维独立高斯噪声向量。我们可以将其拓展为稀疏模型通过将$\mathrm{G}$进行分解，$\mathrm{G}_{mk}=z_{mk}w_{mk}$，其中$z_{mk}$是一个二元掩码(mask)变量指示因子$k$是否影响维度$m$，而$w_{ik}$为连续权重变量。这个有时被称为<code>spike and slab</code>模型因为$x_{mk}$的期望为一个在隐语义空间上的<code>slab</code>$P(w_{mk})$和在零的位置$P(z_{mk}=0)$的<code>spike</code>。</p><p>我们使用贝叶斯的方法推理隐语义、掩码变量和权重。我们在它们上面定义先验并利用贝叶斯公式计算后验$P(\mathrm{G,Z,W\mid Y})$。</p><p>利用无参贝叶斯模型，我们令数据自动确定隐语义的数目$K$。$Z$为一个二元矩阵，有有限多的行和无限多的列。</p><p>与中国餐馆过程类似，$\mathrm{Z}$上的无限容量的分布也被赋予了一个有关烹饪的隐喻，被称为印度自助餐过程。一个顾客(维度)进入一个具有无限菜品的自主餐馆。顾客$m$选择菜品$k$的概率正比于他被之前顾客选择的次数$h_k$。当顾客考虑了所有之前采样过的菜肴($h_k&gt;0$)的菜肴时，他会额外采样之前从未采样过的$\operatorname{Poisson}(\alpha/N)$菜肴。当所有$M$个顾客都选完菜后，形成的二元矩阵$\mathrm{Z}$从IBP(Indian buffet process)中采样得到。</p><p>与中国餐馆过程不同的是，中国餐馆过程每个观测只能选择一个隐语义，而印度自助餐过程每个观测的每个维度可以选择无数多个隐语义。如下图：</p><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/IBP.jpg" alt=""></p><blockquote><p>印度餐馆过程：IBP的生成过程，其中有序号的菱形代表顾客，与与它们相关的观测连接。大圆形表示菜品，与与它们相关的参数$\phi$相连。每个顾客选择多个菜品，并且每个顾客的观测为选择的菜品的参数的线性组合。</p></blockquote><p>现在回到我们的后验分布，我们想要对我们的隐语义矩阵进行推理：</p><script type="math/tex; mode=display">P(\mathrm{X,W,Z}\mid \mathrm{Y})\propto P(\mathrm{Y\mid X,W,Z})P(\mathrm{X})P(\mathrm{W})P(\mathrm{Z})</script><p>精确的推理是很困难的因为归一化参数需要对所有可能的二元矩阵进行积分。</p><h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><p>在BNP建模中最基本的计算问题是计算后验概率。下面我们只简单介绍几种计算方法。</p><ul><li>MCMC</li><li>变分贝叶斯推断：见我的一篇博客(<a href="https://hfcouc.work/2022/07/10/VBI/">https://hfcouc.work/2022/07/10/VBI/</a>)</li></ul><h3 id="Limitations-and-extensions"><a href="#Limitations-and-extensions" class="headerlink" title="Limitations and extensions"></a>Limitations and extensions</h3><p>我们前面介绍到的两种BNP只是最简单的两种，它们存在着很多限制，为了解决这些限制有很多上述模型的拓展。</p><h4 id="Hierarchical-structure"><a href="#Hierarchical-structure" class="headerlink" title="Hierarchical structure"></a>Hierarchical structure</h4><p>第一个限制是关于分组数据的：我们如何捕捉一个群体中的共性和特性呢？比如说同一种动物既有共性也有自己的特性。解决这个问题的标准贝叶斯方法是基于层次模型，在这个模型中，个体由于来自同一群体的分布而被耦合在一起。在非参数的设定下发展出的模型为分层狄利克雷过程。</p><h4 id="Time-series-models"><a href="#Time-series-models" class="headerlink" title="Time series models"></a>Time series models</h4><p>第二个限制是关于序列数据的：我们怎样才能捕捉到序列观察结果之间的依赖关系？关于这方面非常著名的是隐马尔可夫模型。无限隐马尔科夫模型提出了相同的序列结构，但采用了无限多的潜在类，无限隐马尔可夫模型为分层狄利克雷过程的一个特殊情况。<br>作为<code>HMM</code>（隐状态为离散的）的替代品，线性动态系统（也被称为自回归移动平均模型）假定隐状态是连续的，并根据线性高斯马尔可夫过程随时间演变。在一个切换的线性动态系统中，系统可以有许多动态模式；这使得边际转移分布可以是非线性的。有学者探索了切换线性动态系统的非参数变体，其中动态模式的数量是利用HDP先验从数据中推断出来的。</p><h4 id="Spatial-models"><a href="#Spatial-models" class="headerlink" title="Spatial models"></a>Spatial models</h4><p>很多数据集上的依赖是在空间上的。如某种疾病在某个地方出现，在它附近的地方也可能出现。在BNP模型中捕获这种依赖关系的一种方法是使DP的基分布依赖于一个位置变量。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;A-Tutorial-on-Bayesian-Nonparametric-Models&quot;&gt;&lt;a href=&quot;#A-Tutorial-on-Bayesian-Nonparametric-Models&quot; class=&quot;headerlink&quot; title=&quot;A Tutorial on Bayesian Nonparametric Models&quot;&gt;&lt;/a&gt;A Tutorial on Bayesian Nonparametric Models&lt;/h2&gt;&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170401%2F66c0602968c0463c805dcd5ab16a87dc_th.jpeg&amp;refer=http%3A%2F%2Fimg.mp.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1660210656&amp;t=6f0b4c7c45167ff59154a4b5ee75eb30&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章地址：&lt;a href=&quot;https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X&quot;&gt;https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://www.hfcouc.work/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="贝叶斯" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>变分贝叶斯推断</title>
    <link href="https://www.hfcouc.work/2022/07/10/VBI/"/>
    <id>https://www.hfcouc.work/2022/07/10/VBI/</id>
    <published>2022-07-10T12:03:59.000Z</published>
    <updated>2022-07-10T12:14:43.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Variational-Bayesian-inference"><a href="#Variational-Bayesian-inference" class="headerlink" title="Variational Bayesian inference"></a>Variational Bayesian inference</h2><p align="center">    <img src="https://img0.baidu.com/it/u=2387178916,3720682298&fm=253&fmt=auto?w=1280&h=720" style="zoom: 100%;" /></p><blockquote><p>参考文献</p><ol><li><a href="https://github.com/roboticcam/machine-learning-notes/blob/master/files/variational.pdf">徐亦达老师变分推断课件</a></li><li><a href="https://link.springer.com/article/10.1007/s10462-011-9236-8">A tutorial on variational Bayesian inference</a></li><li><a href="https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8">白板推导指数族分布</a></li><li><a href="https://www.bilibili.com/video/BV1DW41167vr?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8">白板推导变分推断</a></li></ol></blockquote><span id="more"></span><h3 id="Log-likelihood-and-Evidence-Lower-Bound-ELOB"><a href="#Log-likelihood-and-Evidence-Lower-Bound-ELOB" class="headerlink" title="Log-likelihood and Evidence Lower Bound(ELOB)"></a>Log-likelihood and Evidence Lower Bound(ELOB)</h3><p>下列表达式总是成立：</p><script type="math/tex; mode=display">\ln(p(X)) = \ln(p(X,Z)) - \ln(P(Z\mid X))</script><p>所以下式也成立：</p><script type="math/tex; mode=display">\ln(P(X)) = \left[\ln(p(X,Z))-\ln(q(Z))\right] - \left[\ln(p(Z\mid X))-\ln(q(Z))\right]</script><p>所以现在我们有</p><script type="math/tex; mode=display">\ln(p(X)) = \ln\left(\frac{p(X,Z)}{q(Z)}\right) - \ln\left(\frac{p(Z\mid X)}{q(Z)}\right)</script><p>两边同时取期望：</p><script type="math/tex; mode=display">\begin{aligned}\ln (p(X)) &=\int q(Z) \ln \left(\frac{p(X, Z)}{q(Z)}\right) \mathrm{d} Z-\int q(Z) \ln \left(\frac{p(Z \mid X)}{q(Z)}\right) \mathrm{d} Z \\&=\underbrace{\int q(Z) \ln (p(X, Z)) \mathrm{d} Z-\int q(Z) \ln (q(Z)) \mathrm{d} Z}_{\mathcal{L}(q)}+\underbrace{\left(-\int q(Z) \ln \left(\frac{p(Z \mid X)}{q(Z)}\right) \mathrm{d} Z\right)}_{\mathbb{K} \mathbb{L}(q \| p)} \\&=\mathcal{L}(q)+\mathbb{K} \mathbb{L}(q \| p)\end{aligned}</script><p>KL散度一般用于度量两个概率分布函数之间的距离，其定义如下：</p><script type="math/tex; mode=display">\mathbb{KL}[p(X)\mid q(X)] = \sum_{x\in X}\left[p(x)\log\frac{p(x)}{q(x)}\right] = \mathbb{E}_{x\sim p(x)}\left[\log\frac{p(x)}{q(x)}\right]</script><p>我们要做的就是找到与后验分布$p(Z\mid X)$最接近的简单分布$p(Z)$。</p><h3 id="Alternative-Evidence-Lower-Bound-ELOB"><a href="#Alternative-Evidence-Lower-Bound-ELOB" class="headerlink" title="Alternative Evidence Lower Bound(ELOB)"></a>Alternative Evidence Lower Bound(ELOB)</h3><p>我们看另一种推导方法：</p><script type="math/tex; mode=display">\begin{aligned}\ln (p(X)) &=\log \int_{Z} p(X, Z) \mathrm{d} z \\&=\log \int_{Z} p(X, Z) \frac{q(Z)}{q(Z)} \mathrm{d} z \\&=\log \left(\mathbb{E}_{q}\left[\frac{p(X, Z)}{q(Z)}\right]\right) \\& \geq \mathbb{E}_{q}\left[\log \left(\frac{p(X, Z)}{q(Z)}\right)\right] \text { using Jensen's inequality } \\&=\mathbb{E}_{q}[\log (p(X, Z))]-\mathbb{E}_{q}[\log (q(Z))] \\& \triangleq \mathcal{L}(q)\end{aligned}</script><h3 id="Maximize-Evidence-Lower-Bound-ELOB"><a href="#Maximize-Evidence-Lower-Bound-ELOB" class="headerlink" title="Maximize Evidence Lower Bound(ELOB)"></a>Maximize Evidence Lower Bound(ELOB)</h3><p>我们给每个部分一个名字：</p><script type="math/tex; mode=display">\begin{array}{ll}\text {Evidence Lower Bound (ELOB):} & \mathcal{L}(q)=\int q(Z) \ln (p(X, Z)) \mathrm{d} Z-\int q(Z) \ln (q(Z)) \mathrm{d} Z \\\mathrm{KL} \text { divergence: } & \mathbb{K} \mathbb{L}(q \| p)=-\int q(Z) \ln \left(\frac{p(Z \mid X)}{q(Z)}\right) d Z\end{array}</script><ul><li>注意$p(X)$对于$q(Z)$的选择是固定的。我们想要去选择一个$q(Z)$函数最小化KL散度，因此$q(Z)$变得离$p(Z\mid X)$越来越近。很容易验证，当$q(Z)=p(Z\mid X)$时，KL散度为$0$。</li><li>我们知道$\ln p(X) = \mathcal{L}(q)+\mathbb{KL}(q| p)$。最小化$\mathbb{KL}(q| p)$等同于最大化$\mathcal{L}(q)$。</li></ul><p>我们可以选择$q(Z)$使得</p><script type="math/tex; mode=display">q(Z) = \prod_{i=1}^Mq_i(Z_i)</script><p>其中$M$为$Z$的维度，也就是说$q(Z)$的各个维度是独立的，这被称为<strong>平均场变分贝叶斯</strong>。</p><blockquote><p>注意$q(Z)$对联合概率密度函数$p(Z\mid X)$是一个很好地近似，但是边缘分布$q(Z_i)$对$p(Z_i\mid x)$的近似不一定好。</p></blockquote><p>将其带入到$\mathcal{L}(q)$中：</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}(q) &=\int q(Z) \ln (p(X, Z)) \mathrm{d} Z-\int q(Z) \ln (q(Z)) \mathrm{d} Z \\&=\underbrace{\int \prod_{i=1}^{M} q_{i}\left(Z_{i}\right) \ln (p(X, Z)) \mathrm{d} Z}_{\text {part (1) }}-\underbrace{\int \prod_{i=1}^{M} q_{i}\left(Z_{i}\right) \sum_{i=1}^{M} \ln \left(q_{i}\left(Z_{i}\right)\right) \mathrm{d} Z}_{\text {part (2) }}\end{aligned}</script><p>我们先看Part1，假设我们只对$Z_i$感兴趣，将其拿出来，变为：</p><script type="math/tex; mode=display">(\operatorname{Part} 1)=\int_{Z_{j}} q_{j}\left(Z_{j}\right)\left(\int_{Z_{i \neq j}} \ldots \int \prod_{i \neq j}^{M} q_{i}\left(Z_{i}\right) \ln (p(X, Z)) \prod_{i \neq j}^{M} d Z_{i}\right) d Z_{j}</script><p>或者将其写为更紧凑的形式：</p><script type="math/tex; mode=display">(\operatorname{Part} 1)=\int_{Z_{j}} q_{j}\left(Z_{j}\right)\left(\int_{Z_{i \neq j}} \cdots \int \ln (p(X, Z)) \prod_{i \neq j}^{M} q_{i}\left(Z_{i}\right) d Z_{i}\right) d Z_{j}</script><p>或者，为了让其更具有意义，可以将其放进一个期望函数里：</p><script type="math/tex; mode=display">(\operatorname{Part} 1)=\int_{Z_{j}} q_{j}\left(Z_{j}\right)\left[\mathbb{E}_{i \neq j}[\ln (p(X, Z))]\right] d Z_{j}</script><p>现在再看Part2：</p><script type="math/tex; mode=display">(\text { Part 2) }=\int \prod_{i=1}^{M} q_{i}(Z_{i}) \sum_{i=1}^{M} \ln \left(q_{i}(Z_{i}\right)) d Z</script><p>将其化简：</p><script type="math/tex; mode=display">\begin{aligned}\operatorname{(Part2)} &= \int q(Z)\sum_{i=1}^M\ln(q_i(Z_i))dZ\\&=\sum_{i=1}^M\int_{Z}q(Z_1,\cdots,Z_M)\ln(q_i(Z_i))dZ\\&=\sum_{i=1}^M\int_{Z_i}q_i(Z_i)\ln(q_i(Z_i))dZ_i\end{aligned}</script><p>假设现在我们只对$q_j(Z_j)$感兴趣，则其余部分可以看作常数，因此上式可以进一步写为：</p><script type="math/tex; mode=display">(\text { Part } 2)=\int_{Z_{j}} q_{j}\left(Z_{j}\right) \ln \left(q_{j}\left(Z_{j}\right)\right) d Z_{j}+\text { const}</script><p>则$\mathcal{L}(q)$变为：</p><script type="math/tex; mode=display">\mathcal{L}(q)=\operatorname{Part}(1)-\operatorname{Part}(2)=\int_{Z_{j}} q_{j}\left(Z_{j}\right) \mathbb{E}_{i \neq j}[\ln (p(X, Z))] \mathrm{d} Z_{j}-\int_{Z_{j}} q_{j}\left(Z_{j}\right) \ln \left(q_{j}\left(Z_{j}\right)\right) \mathrm{d} Z_{j}+\operatorname{const}</script><p>我们定义：</p><script type="math/tex; mode=display">\ln(\tilde{p}_j(X,Z_j)) = \mathbb{E}_{i\neq j}[\ln(p(X,Z))]</script><p>或者定价的我们可以将ELOB写为：</p><script type="math/tex; mode=display">\mathcal{L}(q_j) = \int_{Z_j}q_j(Z_j)\ln\left[\frac{\tilde{p}_j(X,Z_j)}{q_j(Z_j)}\right]+\text{const}</script><p>这与</p><script type="math/tex; mode=display">-\mathbb{KL}\left(\exp(\mathbb{E}_{i\neq j}[\ln(p(X,Z))])\| q_i(Z_i)\right)</script><p>相等。</p><p><strong>所以我们可以最大化ELOB，或者$\mathcal{L}(q)$，通过最小化这个特殊的KL散度，也就是找到近似和最优$q^\star_i(Z_i)$，使得</strong></p><script type="math/tex; mode=display">\ln(q_i^\star(Z_i)) = \mathbb{E}_{i\neq j}[\ln(p(X,Z))]</script><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>令数据$\mathcal{D}=\{x_1,\cdots,x_n\}$，则</p><script type="math/tex; mode=display">\begin{gathered}p(\mathcal{D} \mid \mu, \tau)=\prod_{i=1}^{n}\left(\frac{\tau}{2 \pi}\right)^{\frac{1}{2}} \exp \left(\frac{-\tau}{2}\left(x_{i}-\mu\right)^{2}\right) \\=\left(\frac{\tau}{2 \pi}\right)^{\frac{n}{2}} \exp \left(\frac{-\tau}{2} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}\right) \\p(\mu \mid \tau)=\mathcal{N}\left(\mu_{0},\left(\lambda_{0} \tau\right)^{-1}\right) \propto \exp \left(\frac{-\lambda_{0} \tau}{2}\left(\mu-\mu_{0}\right)^{2}\right) \\p(\tau)=\operatorname{Gamma}\left(\tau \mid a_{0}, b_{0}\right) \propto \tau^{a_{0}-1} \exp ^{-b_{0} \tau}\end{gathered}</script><p>并且</p><script type="math/tex; mode=display">p(\mathcal{D},\mu,\tau) = p(\mathcal{D}\mid \mu,\tau)p(\mu\mid \tau)p(\tau)</script><p>则：</p><script type="math/tex; mode=display">p(\mu,\tau\mid d)\propto p(\mathcal{D}\mid \mu,\tau)p(\mu\mid \tau)p(\tau)=\mathcal{N}(\mu_n,(\lambda \tau)^{-1})\text{Gamma}(\tau\mid a_n,b_n)</script><p>其中</p><script type="math/tex; mode=display">\begin{aligned}\mu_{n} &=\frac{\lambda_{0} \mu_{0}+n \bar{x}}{\lambda_{0}+n} \\\lambda_{n} &=\lambda_{0}+n \\a_{n} &=a_{0}+n / 2 \\b_{n} &=b_{0}+\frac{1}{2} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}+\frac{\lambda_{0} n\left(\bar{x}-\mu_{0}\right)^{2}}{2\left(\lambda_{0}+n\right)}\end{aligned}</script><p>可以看出是由解析解的，但是为了例子，我们再采用变分贝叶斯的方法，我们假设$q(\mu,\tau)$：</p><script type="math/tex; mode=display">q(\mu,\tau) = q_{\mu}(\mu)q_\tau(\tau)</script><p>则：</p><script type="math/tex; mode=display">\begin{aligned}\ln \left(q_{\mu}^{*}(\mu)\right) &=\mathbb{E}_{q_{\tau}}[\ln (p(\mu, \tau \mid \mathcal{D}))] \\&=\mathbb{E}_{q_{\tau} \tau}[\ln (p(\mathcal{D} \mid \mu, \tau))+\ln p(\mu \mid \tau)]+\text { const. } \quad \text { remove terms do NOT contain } \mu \\&=\mathbb{E}_{q_{\tau}}[\underbrace{-\frac{\tau}{2} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\underbrace{\frac{\lambda_{0} \tau}{2}\left(\mu-\mu_{0}\right)^{2}}_{\ln p(\mu \mid \gamma)}]}_{\ln (p(\mathcal{D} \mid \mu, \tau))}+\text { const. }\\&=-\frac{\mathbb{E}_{q_{\tau}}[\tau]}{2} \underbrace{\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right]}_{\text {terms contain } \mu \text { but does not contain } \tau}+\text { const. }\end{aligned}</script><p>将关于$\mu$的项展开：</p><script type="math/tex; mode=display">\begin{aligned}& \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}=n \mu^{2}-2 n \mu \bar{x}+\lambda_{0} \mu^{2}-2 \lambda_{0} \mu_{0} \mu+\text { const. } \\=&\left(n+\lambda_{0}\right) \mu^{2}-2 \mu\left(n \bar{x}+\lambda_{0} \mu_{0}\right)=\left(n+\lambda_{0}\right)\left(\mu^{2}-\frac{2 \mu\left(n \bar{x}+\lambda_{0} \mu_{0}\right)}{\left(n+\lambda_{0}\right)}\right) \\=&\left(n+\lambda_{0}\right)\left(\mu-\frac{\left(n \bar{x}+\lambda_{0} \mu_{0}\right)}{\left(n+\lambda_{0}\right)}\right)^{2}+\text { const. }\end{aligned}</script><p>因此我们有：</p><script type="math/tex; mode=display">\begin{aligned}\ln \left(q_{\mu}^{*}(\mu)\right) &=-\frac{\mathbb{E}_{q_{\tau}}[\tau]}{2}\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right]+\text { const. } \\&=-\frac{\mathbb{E}_{q_{\tau}}[\tau]\left(n+\lambda_{0}\right)}{2}\left(\mu-\frac{\left(n \bar{x}+\lambda_{0} \mu_{0}\right)}{\left(n+\lambda_{0}\right)}\right)^{2}+\text { const. } \\&=\mathcal{N}\left(\frac{n \bar{x}+\lambda_{0} \mu_{0}}{n+\lambda_{0}}, \mathbb{E}_{q_{\tau}}[\tau]\left(n+\lambda_{0}\right)\right)\end{aligned}</script><p>关于$\tau$，我们有</p><script type="math/tex; mode=display">\begin{aligned}\ln \left(q_{\tau}^{*}(\tau)\right) &=\mathbb{E}_{q_{\mu}}[\ln (p(\mu, \tau \mid \mathcal{D}))] \\&=\mathbb{E}_{q_{\mu}}[\ln (p(\mathcal{D} \mid \mu, \tau))+\ln p(\mu \mid \tau)+\ln p(\tau)]+\text { const. } \\&=\mathbb{E}_{q_{\mu}}[\underbrace{\frac{n}{2} \ln (\tau)-\frac{\tau}{2} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}}_{\ln (p(\mathcal{D} \mid \mu, \tau))} \underbrace{-\frac{\lambda_{0} \tau}{2}\left(\mu-\mu_{0}\right)^{2}}_{\ln p(\mu \mid \gamma)} \underbrace{+\left(a_{0}-1\right) \ln (\tau)-b_{0} \tau}_{\ln p(\tau)}]+\text { const. }\end{aligned}</script><p>将没有$\mu$的项拿出积分：</p><script type="math/tex; mode=display">\begin{aligned}&=\frac{n}{2} \ln (\tau)+\left(a_{0}-1\right) \ln (\tau)-b_{0} \tau-\frac{\tau}{2} \mathbb{E}_{q_{\mu}(\mu)}\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right]+\text { const. } \\&=(\underbrace{\frac{n}{2}+a_{0}}_{a_{n}}-1) \ln (\tau)-\tau(\underbrace{b_{0}+\frac{1}{2} \mathbb{E}_{q_{\mu}(\mu)}\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right]}_{b_{n}}+\text { const. }\end{aligned}</script><p>重写为：</p><script type="math/tex; mode=display">\begin{aligned}b_{n} &=b_{0}+\frac{1}{2} \mathbb{E}_{q_{\mu}}\left[\sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}+\lambda_{0}\left(\mu-\mu_{0}\right)^{2}\right] \\&=b_{0}+\frac{1}{2} \mathbb{E}_{q_{\mu}}\left[-2 \mu n \bar{x}+n \mu^{2}+\lambda_{0} \mu^{2}-2 \lambda_{0} \mu_{0} \mu\right]+\sum_{i=1}^{n}\left(x_{i}\right)^{2}+\lambda_{0} \mu_{0}^{2} \\&=b_{0}+\frac{1}{2}\left[\left(n+\lambda_{0}\right) \mathbb{E}_{q_{\mu}}\left[\mu^{2}\right]-2\left(n \bar{x}+\lambda_{0} \mu_{0}\right) \mathbb{E}_{q_{\mu}}[\mu]+\sum_{i=1}^{n}\left(x_{i}\right)^{2}+\lambda_{0} \mu_{0}^{2}\right]\end{aligned}</script><p>因为$q_{\mu}(\mu)$事先定义好了我们可以计算$\mathbb{E}_{q_\mu}[\mu]$和$\mathbb{E}_{q_\mu}[\mu^2]$。</p><h3 id="随机梯度变分推断"><a href="#随机梯度变分推断" class="headerlink" title="随机梯度变分推断"></a>随机梯度变分推断</h3><p>上面提到的基于平均场的变分推断实际上是坐标上升法，其存在一些问题：</p><ul><li>假设太强，对复杂模型也许假设不好甚至不成立。</li><li>即使假设是成立的，但是因为其递推式包含很多积分，也可能无法计算。</li></ul><p>下面我们采用随机梯度上升的方法来求解变分推断问题：</p><p>我们知道目标函数：</p><script type="math/tex; mode=display">\hat{q} = \arg\min _q\mathbb{KL}(q\| p) = \arg\max_q\mathcal{L}(q)</script><p>其中$q$是$z$的函数，设其参数为$\phi$，我们将其记为$q_{\phi}(z)$，那么我们的目标函数变为：</p><script type="math/tex; mode=display">\hat{q} = \arg\max_{\phi}\mathcal{L}(\phi)</script><p>其中</p><script type="math/tex; mode=display">\mathcal{L}(\phi) = \mathbb{E}_{q_\phi}[\log P]</script><p>因为是随机梯度下降，所以我们每次选取一个样本，假设选取的样本为$x_i$，那么目标函数变为：</p><script type="math/tex; mode=display">\mathcal{L}(\phi) = \mathbb{E}_{q_\phi}[\log P(x_i,z) - \log q_{\phi}(z)]</script><p>对其进行求导，得：</p><script type="math/tex; mode=display">\begin{aligned}\nabla_{\phi} \mathcal{L}(\phi) &=\nabla_{\phi} \mathbb{E}_{q_{\phi}}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] \\&=\nabla_{\phi} \int q_{\phi}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] d z \\&=\int \nabla_{\phi}\left(q_{\phi}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right]\right) d z \\&=\underbrace{\int \nabla_{\phi} q_{\phi} \cdot\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] d z}_{\text{Part1}}+\underbrace{\int q_{\phi} \cdot \nabla_{\phi}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] d z}_{\text{Part2}}\end{aligned}</script><p>我们首先看Part2：</p><script type="math/tex; mode=display">\begin{aligned}\text { Part2 } &=\int q_{\phi} \cdot \nabla_{\phi}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] d z \\&=\int q_{\phi} \cdot\left(-\nabla_{\phi} \log q_{\phi}\right) d z \\&=\int q_{\phi} \cdot\left(-\frac{1}{q_{\phi}} \nabla_{\phi} q_{\phi}\right) d z \\&=-\int \nabla_{\phi} q_{\phi} d z \\&=-\nabla_{\phi} \int q_{\phi} d z \\&=-\nabla_{\phi} 1 \\&=0\end{aligned}</script><p>所以</p><script type="math/tex; mode=display">\nabla_\phi\mathcal{L}(\phi) = \int\nabla_\phi q_\phi\cdot[\log P(x_i,z)-\log q_\phi]dz</script><p>如果能写成期望的形式，我们就可以采用蒙特卡洛的方法对其进行采样，因此进行一个小的变换：$\nabla_\phi q_\phi = \nabla(\log q_\phi)q_\phi$，得到</p><script type="math/tex; mode=display">\begin{aligned}\nabla_\phi\mathcal{L}(\phi) &= \int \nabla_\phi(\log q_\phi)\cdot q_\phi\cdot[\log P(x_i,z)-\log q_\phi]dz\\&= \mathbb{E}_{q_\phi}[\nabla_\phi(\log q_\phi)\cdot (\log P(x_i,z)-\log q_\phi)]\end{aligned}</script><p>这样就可以采用蒙特卡洛的方式进行采样后求解期望：</p><p>从$q_{\phi}(z)$中采样$z$，$z_l \sim q_{\phi}(z),l=1,2,\cdots,L$，因此：</p><script type="math/tex; mode=display">\nabla_\phi\mathcal{L}(\phi)\approx \frac{1}{L}\sum_{l=1}^L\nabla_\phi\log q_{\phi}(z_l)(\log P(x_i,z_l)-\log q_\phi(z_l))</script><p>但是存在一个问题，因为$q_{\phi}(z)$为概率密度函数，所以其值位于$[0,1]$，在$[0,1]$内对数函数的变化非常大，这就导致其方差较大，导致此方法很可能无法使用。</p><p>因此我们采用了重参数化技巧，假定$z = g_\phi(\epsilon,x_i),\epsilon\sim P(\epsilon)$，其中$g_\phi$为参数变换的函数，相当于$z$把随机性转移到了$\epsilon$上，根据随机变量变换的性质：</p><script type="math/tex; mode=display">|q_\phi(z)dz| = |P(\epsilon)d\epsilon|</script><blockquote><p>即：</p><script type="math/tex; mode=display">\frac{q_\phi(z)}{P(\epsilon)} = \left|\frac{dz}{d\epsilon}\right|</script></blockquote><p>将上述变换代入梯度，得：</p><script type="math/tex; mode=display">\begin{aligned}\nabla_{\phi} \mathcal{L}(\phi) &=\nabla_{\phi} \int\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] q_{\phi} d z \\&=\nabla_{\phi} \int\left[\log P\left(x_i, z\right)-\log q_{\phi}\right] \cdot P(\epsilon) d \epsilon \\&=\nabla_{\phi} \mathbb{E}_{P(\epsilon)}\left[\log P\left(x_i, z\right)-\log q_{\phi}\right]\end{aligned}</script><p>因为$P(\epsilon)$与$\phi$的梯度无关，因此可以将其放在期望内部：</p><script type="math/tex; mode=display">\begin{aligned}\nabla_{\phi} \mathcal{L}(\phi) &=E_{P(\epsilon)}\left[\nabla_{\phi}\left(\log P\left(x_i, z\right)-\log q_{\phi}\right)\right] \\&=E_{P(\epsilon)}\left[\nabla_{z}\left(\log P\left(x_i, z\right)-\log q_{\phi}(z)\right) \nabla_{\phi} z\right] \\&=E_{P(\epsilon)}\left[\nabla_{z}\left(\log P\left(x_i, z\right)-\log q_{\phi}(z)\right) \nabla_{\phi} g_{\phi}\left(\epsilon, x_i\right)\right]\end{aligned}</script><p>这样就可以再次采用蒙特卡洛的方法：</p><script type="math/tex; mode=display">\begin{aligned}&\epsilon_l \sim P(\epsilon), \quad l=1,2, \cdots, L \\&\nabla_{\phi} \mathcal{L}(\phi) \approx \frac{1}{L} \sum_{l=1}^{L}\left[\nabla_{z}\left(\log P\left(x_i, z\right)-\log q_{\phi}(z)\right) \nabla_{\phi} g_{\phi}\left(\epsilon_l, x_i\right)\right]\end{aligned}</script><h3 id="Variational-Bayes-with-message-passing"><a href="#Variational-Bayes-with-message-passing" class="headerlink" title="Variational Bayes with message passing"></a>Variational Bayes with message passing</h3><p>上述的手动推导的方式有些繁琐，但是现在的变分信息传递算法(variational message passing(VMP))可以自动对共轭指数分布族进行推导。对于非共轭指数网络，如果需要以牺牲精度为代价快速逼近，VMP 可能仍然有用。</p><p>对于指数族分布，其形式为：</p><script type="math/tex; mode=display">P(x\mid \eta) = h(x)\exp\left(\eta^T\phi(x)-A(\eta)\right)</script><p>其中$\eta$为参数，$\phi(x)$为充分统计量。</p><p>关于指数族分布的标准理论证明了指数分布的充分统计量的性质为：</p><script type="math/tex; mode=display">\langle \phi(x)\rangle = \nabla_{\eta}A(\eta)\mid_\eta</script><p>即充分统计量的期望为$A(\eta)$函数对$\eta$的导数。</p><p>我们用$\text{pa}(z_i)$表示$z_i$的父结点，$\text{ch}(z_i)$表示其子结点，$\text{cop}(z_i;\text{ch})$表示与$x_i$共同子结点为$\text{ch}$父结点的集合；$\text{cop}(z_i)$表示与$z_i$有共同子结点的父结点。我们的更新公式为：</p><script type="math/tex; mode=display">\ln q_i(z_i) = \langle\ln P(z_i,\text{mb}(z_i)),D\rangle_{q(\text{mb}(z_i))}</script><p>其中$\langle\rangle_{q(\text{mb}(z_i))}$相当于对$q(\text{mb}(z_i))$求期望，而$\text{mb}$表示马尔可夫毯。</p><blockquote><p>马尔可夫毯：在随机变量的全集$U$中，对于给定的变量$\mathrm{X}\in \mathrm{U}$和变量集$\mathrm{MB}\subset \mathrm{U}$，若有：</p><script type="math/tex; mode=display">\mathrm{X}\perp \{\mathrm{U-MB-\{X\}}\mid\mathrm{MB}\}</script><p>则称能满足上述条件的最小变量集$\mathrm{MB}$为$\mathrm{X}$的马尔可夫毯。</p></blockquote><p>则可以写为：</p><script type="math/tex; mode=display">=\langle\ln P(\text{pa}(z_i))+\ln P(\text{cop}(z_i))+\ln P(z_i\mid\text{pa}(z_i))+\ln P(\text{ch}(z_i)\mid z_i,\text{cop}(z_i))\rangle_{q(\text{mb}(z_i))}</script><p>去除和$z_i$无关的常数项：</p><script type="math/tex; mode=display">=\langle \ln P(z_i\mid \text{pa}(z_i))\rangle_{q(\text{pa}(z_i))} +\langle\ln P(\text{ch}(z_i)\mid z_i,\text{cop}(z_i))\rangle_{q(\text{ch}(z_i),\text{cop}(z_i))}</script><p>将子结点拆开得：</p><script type="math/tex; mode=display">=\langle \ln P(z_i\mid \text{pa}(z_i))\rangle_{q(\text{pa}(z_i))} +\sum_{\text{ch}\in\text{ch}(z_i)}\langle\ln P(\text{ch}\mid z_i,\text{cop}(z_i))\rangle_{q(\text{ch},\text{cop}(z_i))}</script><p>我们将会将这两部分分开考虑</p><h4 id="Messages-from-parents"><a href="#Messages-from-parents" class="headerlink" title="Messages from parents"></a>Messages from parents</h4><p>共轭指数节点$z_i$由自然参数向量$\phi_i$参数化。通过这些节点的定义：</p><script type="math/tex; mode=display">\begin{aligned}\langle\ln P(z_i\mid \text{pa}(z_i))_{q(\text{pa}(z_i))} &= \langle \phi_i\mu(z_i) + f_i(z_i)+g_i(\phi_i)\rangle_{q(\text{pa}(z_i))}\\&=\langle\phi_i\rangle_{q(\text{pa}(z_i))}\mu_i(z_i)+f_i(z_i)+\langle g(\phi_i)\rangle_{q(\text{pa}(z_i))}\end{aligned}</script><p>由于$\phi$和$g$是父节点充分统计量的多线性函数（通过构造），并且使用平均场假设，我们可以简单地采用它们的公式（定义为以父节点的单个值为条件）并将期望替换为充分统计，根据需要得到整个表达式的期望值。因此$z_i$的父结点只需要将它们的充分统计期望作为信息传递给$z_i$。</p><h4 id="Messages-to-parents"><a href="#Messages-to-parents" class="headerlink" title="Messages to parents"></a>Messages to parents</h4><p>指数族的一个关键性质是我们可以通过将其自然参数相加来得到相似分布的乘积：</p><script type="math/tex; mode=display">\begin{aligned}&\exp\left[\phi_1\mu(z_i)+f(z_i)+g(\phi_1)\right]\cdot\exp\left[\phi_2\mu(z_i)+f(z_i)+g(\phi_2)\right]\\&= \exp\left[(\phi_1+\phi_2)\mu(z_i)+f(z_i)+g(\phi_1+\phi_2)\right]\end{aligned}</script><p>第二个性质是关于共轭，$\phi$和$g$在父结点的充分统计量中也是多线性的。因此我们总是可以通过找到函数$\phi_{ij},f_j,g_{ij}$来重新组合公式是其像是一个父结点$z_j\in\text{pa}(z_i)$的函数：</p><script type="math/tex; mode=display">\left\langle\ln P\left(z_{i} \mid \text{pa}\left(z_{i}\right)\right)\right\rangle_{q\left(\text{pa}\left(z_{i}\right)\right)}=\left\langle\phi_{i j} u_{j}\left(z_{j}\right)+f_{i j}\left(z_{j}\right)+g_{i j}\left(\phi_{i j}\right)\right\rangle_{q\left(\text{pa}\left(z_{i}\right)\right)}</script><p>和以前一样，我们可以通过使用多线性属性来处理期望，以将所有期望推到充分统计量附近。因此，从父结点的角度来看，这是根据其子结点和共同父结点的充分统计期望来写的。因此，我们可以传递一个似然信息，包括：</p><script type="math/tex; mode=display">\phi_{ij}\left(\langle\mu(z_i)\rangle,\{\langle\mu(\text{cop})\rangle\}_{\text{cop}\in\text{cop}(z_j;z_i)}\right)</script><p>然后，父结点可以通过第一个属性将这些简单地添加到其先前的参数中。</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/VBI1.jpg" alt=""></p><p>则：</p><script type="math/tex; mode=display">\ln P(\mu\mid m,\beta) = \begin{bmatrix}m\beta&-\beta/2\end{bmatrix}\cdot \begin{bmatrix}\mu\\\mu^2\end{bmatrix} - \frac{1}{2}(-\ln \beta + \beta m^2+\ln2\pi)</script><p>其中$\phi(x) = \begin{bmatrix}\mu\\\mu^2\end{bmatrix}, \eta^T = \begin{bmatrix}m\beta&amp;-\beta/2\end{bmatrix},A(\eta) = \frac{1}{2}(-\ln \beta + \beta m^2+\ln2\pi)$。</p><p>所以很容易得到充分统计量的期望为：</p><script type="math/tex; mode=display">\left\langle \begin{bmatrix}\mu\\\mu^2\end{bmatrix}\right\rangle = \nabla A(\eta) = \begin{bmatrix}\mu\\\mu^2+\beta^{-1}\end{bmatrix}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Variational-Bayesian-inference&quot;&gt;&lt;a href=&quot;#Variational-Bayesian-inference&quot; class=&quot;headerlink&quot; title=&quot;Variational Bayesian inference&quot;&gt;&lt;/a&gt;Variational Bayesian inference&lt;/h2&gt;&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://img0.baidu.com/it/u=2387178916,3720682298&amp;fm=253&amp;fmt=auto?w=1280&amp;h=720&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/roboticcam/machine-learning-notes/blob/master/files/variational.pdf&quot;&gt;徐亦达老师变分推断课件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.springer.com/article/10.1007/s10462-011-9236-8&quot;&gt;A tutorial on variational Bayesian inference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;白板推导指数族分布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1DW41167vr?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;白板推导变分推断&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://www.hfcouc.work/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="贝叶斯" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>指数分布族</title>
    <link href="https://www.hfcouc.work/2022/07/10/EXP/"/>
    <id>https://www.hfcouc.work/2022/07/10/EXP/</id>
    <published>2022-07-10T12:03:45.000Z</published>
    <updated>2022-07-10T12:08:25.180Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Exponential-Family-Distribution"><a href="#Exponential-Family-Distribution" class="headerlink" title="Exponential Family Distribution"></a>Exponential Family Distribution</h2><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/EX1.png" alt=""></p><blockquote><p>课程地址：<a href="https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8">https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8</a></p></blockquote><span id="more"></span><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>指数分布族是可以写为如下形式的分布：</p><script type="math/tex; mode=display">P(x\mid \eta) = h(x)\exp\left(\eta^T\phi(x)-A(\eta)\right)</script><p>其中$\eta$为参数向量，$x\in \mathbb{R}^p$，$A(\eta)$为对数配分函数(log partition function)。</p><p>下面我们解释一下<strong>配分函数</strong>，配分函数可以理解为<strong>归一化因子</strong>，例如我们在无向图模型中经常用到的：</p><script type="math/tex; mode=display">P(X\mid \theta) = \frac{1}{Z}\hat{P}(X\mid \theta)</script><p>其中$\hat{P}(X\mid \theta)$是我们构造出来的分布，但是概率分布必须满足和为$1$，所以我们在前面添加归一化因子使得：</p><script type="math/tex; mode=display">Z = \int_x \hat{P}(x\mid \theta)dx</script><p>可以看出$Z$与$X$无关，那为什么$A(\eta)$称为对数配分函数呢？这是因为：</p><script type="math/tex; mode=display">\begin{aligned}P(x\mid \eta) &= h(x)\exp\left(\eta^T\phi(x)-A(\eta)\right)\\&= \frac{1}{\exp(A(\eta))}h(x)\exp(\eta^T\phi(x))\end{aligned}</script><p>所以$Z = \exp(A(\eta))\Rightarrow A(\eta)=\ln Z$，所以其被称为对数配分函数。</p><p>其中$\phi(x)$为<strong>充分统计量</strong>。充分统计量指的是能够包含样本中所有信息的统计量。</p><p>如对于数据$x_1,\cdots,x_N$，我们假设其服从于高斯分布，那么其充分统计量就为：</p><script type="math/tex; mode=display">\phi(x) = \begin{bmatrix}\sum_{i=1}^Nx_i\\\sum_{i=1}^Nx_i^2\end{bmatrix}</script><p>因为有了这两个统计量我们就可以求出其<strong>均值</strong>和<strong>方差</strong>。</p><p>在贝叶斯推断中我们常常遇到这样的问题：</p><script type="math/tex; mode=display">P(Z\mid X) = \frac{P(X\mid Z)P(Z)}{\int_ZP(X\mid Z)P(Z)dZ}</script><p>有时候积分很难算出，即使积分算出了，$P(Z\mid X)$的形式可能很复杂，我们无法求解其期望和方差，这时候我们可以采用采样的方法(MCMC)或者通过变分推断来寻找接近$P(Z\mid X)$的概率分布$Q(X)$。</p><p>但是指数族分布可以采用共轭的性质。</p><p>指数族分布与广义线性模型，广义线性模型的重要组成部分为：</p><ol><li>线性组合，如$w^Tx$</li><li>link function：为激活函数的逆函数</li><li>指数族分布：$y\mid x\sim$指数族分布</li></ol><p>概率图模型中非常重要的一组模型为无向图RBF，与指数族分布具有非常重要的关系。</p><p>另外当分布为指数族分布时，变分推断可见极大地简化。</p><h3 id="高斯分布的指数族形式"><a href="#高斯分布的指数族形式" class="headerlink" title="高斯分布的指数族形式"></a>高斯分布的指数族形式</h3><p>高斯分布的形式为：</p><script type="math/tex; mode=display">\begin{aligned}P(x\mid\theta) &= \frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{1}{2\sigma^2}(x-\mu)^2\right)\quad \theta = (\mu,\sigma^2)\\&=\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{1}{2\sigma^2}(x^2-2\mu x+\mu^2)\right)\\&=\exp\left(\log(2\pi\sigma^2)^{-\frac{1}{2}}\right)\exp\left(-\frac{1}{2\sigma^2}\begin{pmatrix}-2\mu&1\end{pmatrix}\begin{pmatrix}x\\x^2\end{pmatrix}-\frac{\mu^2}{2\sigma^2}\right)\\&=\exp\left(\underbrace{\begin{pmatrix}\frac{\mu}{\sigma^2}&-\frac{1}{2\sigma^2}\end{pmatrix}}_{\eta^T}\cdot\underbrace{\begin{pmatrix}x\\x^2\end{pmatrix}}_{\phi(x)}-\underbrace{\left(\frac{\mu^2}{2\sigma^2}+\frac{1}{2}\log2\pi\sigma^2\right)}_{A(\eta)}\right)\end{aligned}</script><p>其中我们令$\eta_1=\frac{\mu}{\sigma^2},\eta_2=-\frac{1}{2\sigma^2}$。则$\sigma^2=-\frac{1}{2\eta_2},\mu=-\frac{\eta_1}{2\eta_2}$。代入$A(\eta)$，得：</p><script type="math/tex; mode=display">A(\eta) = -\frac{\eta_1^2}{4\eta_2}+\frac{1}{2}\log\left(-\frac{\pi}{\eta_2}\right)</script><h3 id="对数配分函数与充分统计量的关系"><a href="#对数配分函数与充分统计量的关系" class="headerlink" title="对数配分函数与充分统计量的关系"></a>对数配分函数与充分统计量的关系</h3><p>我们之前提到过：</p><script type="math/tex; mode=display">\exp(A(\eta)) = \int_x h(x)\exp(\eta^T\phi(x))dx</script><p>两边同时对$\eta$求导，得：</p><script type="math/tex; mode=display">\begin{aligned}\exp(A(\eta))\cdot A^\prime(\eta) &= \frac{\partial}{\partial \eta}(\int h(x)\exp(\eta^T\phi(x))dx)\\&= \int_xh(x)\exp(\eta^T\phi(x))\phi(x)dx\end{aligned}</script><p>两边同除以$A^\prime(\eta)$，得</p><script type="math/tex; mode=display">\begin{aligned}A^\prime(\eta) &= \frac{\int_xh(x)\exp(\eta^T\phi(x))\phi(x)dx}{\exp(A(\eta))}\\&=\int_x \underbrace{h(x)\exp(\eta^T\phi(x)-A(\eta))}_{P(x\mid\eta)}\phi(x)dx\\&= \mathbb{E}_{P(x\mid\eta)}[\phi(x)]\end{aligned}</script><p>所以$A^\prime(\eta) = \mathbb{E}_{P(x\mid \eta)}[\phi(x)]$。</p><p>同样地，我们也可以研究一下二阶导，对式子</p><script type="math/tex; mode=display">A^\prime(\eta) =\int_x \underbrace{h(x)\exp(\eta^T\phi(x)-A(\eta))}_{P(x\mid\eta)}\phi(x)dx</script><p>两边同时求导得：</p><script type="math/tex; mode=display">\begin{aligned}A^{\prime\prime}(\eta) &= \int_x \underbrace{h(x)\exp(\eta^T\phi(x)-A(\eta))}_{P(x\mid\eta)}(\phi(x)-A^{\prime}(\eta))\phi(x)dx\\&= \int_xP(x\mid\eta)(\phi(x)-\mathbb{E}_{P(x\mid\eta)}[\phi(x)])\phi(x)dx\\&= \int_x P(x\mid \eta)\phi(x)^2dx - \mathbb{E}_{P(x\mid\eta)}[\phi(x)])\int_xP(x\mid \eta)\phi(x)dx\\&= \mathbb{E}_{P(x\mid\eta)}[\phi(x)^2] - \left(\mathbb{E}_{P(x\mid \eta)}[\phi(x)]\right)^2\\&=\operatorname{Var}[\phi(x)]\end{aligned}</script><h3 id="极大似然估计与充分统计量"><a href="#极大似然估计与充分统计量" class="headerlink" title="极大似然估计与充分统计量"></a>极大似然估计与充分统计量</h3><p>假设我们的数据为：$D=\{x_1,x_2,\cdots,x_N\}$，所以我们有：</p><script type="math/tex; mode=display">\begin{aligned}\eta_{\text{mle}} &= \arg\max\log P(D\mid \eta)\\&=\arg\max \log\prod_{i=1}^N P(x_i\mid \eta)\\&=\arg\max \sum_{i=1}^N\log P(x_i\mid \eta)\\&=\arg\max\sum_{i=1}^N\log\left[h(x_i)\exp(\eta^T\phi(x_i)-A(\eta))\right]\\&= \arg\max\sum_{i=1}^N\left[\log h(x_i)+\eta^T\phi(x_i)-A(\eta)\right]\\&= \arg\max\sum_{i=1}^N(\eta^T\phi(x_i)-A(\eta))\end{aligned}</script><p>我们对其求导，得：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial}{\partial \eta}\left(\sum_{i=1}^N\eta^T\phi(x_i)-A(\eta)\right)&=\sum_{i=1}^N\frac{\partial}{\partial \eta}(\eta^T\phi(x_i)-A(\eta))\\&=\sum_{i=1}^N\phi(x_i)-A^{\prime}(\eta)\\&=\sum_{i=1}^N\phi(x_i)-NA^{\prime}(\eta)\end{aligned}</script><p>令导数等于$0$，得</p><script type="math/tex; mode=display">A^{\prime}(\eta_{\text{mle}}) = \frac{1}{N}\sum_{i=1}^N\phi(x_i)</script><p>这样我们就可以求出$\eta_{\text{mle}}$，可以看出$\eta_{\text{mle}}$仅与$\phi(x)$有关，即确定了$\phi(x)$即确定了$\eta_{\text{mle}}$，即确定了分布，更加验证了$\phi(x)$充分统计量的结论。</p><h3 id="最大熵角度"><a href="#最大熵角度" class="headerlink" title="最大熵角度"></a>最大熵角度</h3><p>假设一个事件发生的概率为$p$，其信息量为$-\log p$。熵的概念就是信息量关于分布本身的期望：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}_{p(x)}[-\log p] &= -\int_x p(x)\log p(x)dx\\&= -\sum_x p(x)\log p(x)\end{aligned}</script><p>最大熵的思想通俗来说就是等可能的，当我们对一个事件一无所知时，我们一般假设其是等可能的。下面看一个例子：</p><p>我们用$H[P]$来表示熵：</p><script type="math/tex; mode=display">H[p] = -\sum_x p(x)\log p(x)</script><p>我们假设$x$是离散的，$x$可以取值的个数为$K$，概率分别对应于$p_1,\cdots,p_K$，并且$\sum_{i=1}^K p_i=1$。所以其熵为：</p><script type="math/tex; mode=display">H[p] = -\sum_{i=1}^K p_i\log (p_i)</script><p>我们令其最大，即变为了优化问题：</p><script type="math/tex; mode=display">\begin{aligned}&\min \sum_{i=1}^K p_i\log p_i\\&\text{s.t. }\sum_{i=1}^K p_i=1\end{aligned}</script><p>我们可以直接用拉格朗日乘子法进行求解，定义：</p><script type="math/tex; mode=display">\mathcal{L}(p,\lambda) = \sum_{i=1}^K p_i\log(p_i)+\lambda(1-\sum_{i=1}^Kp_i)</script><p>对$p_i$求导，得：</p><script type="math/tex; mode=display">\frac{\partial \mathcal{L}(p,\lambda)}{\partial p_i} = \log(p_i)+p_i\cdot\frac{1}{p_i}-\lambda</script><p>所以：</p><script type="math/tex; mode=display">p_i = \exp(\lambda-1)</script><p>对于每个$p_i$都是如此，所以$p_1=p_2=\cdots=p_K=\frac{1}{K}$，所以其为等可能的。</p><p>最大熵原理：在满足既定事实的前提下，具有最大熵的分布即为我们想要的分布。在机器学习中，我们的既定事实即为数据，假设我们的数据为$D=\{x_1,\cdots,x_N\}$。</p><p>在这里我们引入经验分布的概念，其是对已知样本的描述，其定义为：</p><script type="math/tex; mode=display">\hat{p}(X=x) = \frac{\text{count}(x)}{N}</script><p>因为分布$\hat{p}$我们已经求出来了，所以对于$x$的任意函数$f(x)$向量，我们也能求其期望：</p><script type="math/tex; mode=display">\mathbb{E}_{\hat{p}}[f(x)] = \Delta(\text{已知})</script><p>这个就是我们的<strong>已知约束</strong>。</p><p>下面我们求满足上述约束的最大熵的分布，这就变成了优化问题：</p><script type="math/tex; mode=display">\begin{aligned}&\min \sum_x p(x)\log p(x)\\&\text{s.t. } \sum_x p(x)=1\\&\quad\quad \mathbb{E}_{\hat{p}} [f(x) ]= \mathbb{E}_p[f(x)] = \Delta\end{aligned}</script><p>定义拉格朗日乘子：</p><script type="math/tex; mode=display">\mathcal{L}(p,\lambda_0,\lambda) = \sum_x p(x)\log p(x) + \lambda_0(1-\sum_x p(x))+\lambda^T(\Delta-\mathbb{E}_p[f(x)])</script><p>对$p(x)$求导得：</p><script type="math/tex; mode=display">\frac{\mathcal{L}}{\partial p(x)} =(\log p(x)+1)-\lambda_0-\lambda^T f(x)</script><p>令其等于$0$，得</p><script type="math/tex; mode=display">\log p(x) = \lambda^T f(x) + \lambda_0-1</script><p>所以</p><script type="math/tex; mode=display">p(x) = \exp\left(\lambda^T f(x) - (1-\lambda_0)\right)</script><p>为指数族分布。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Exponential-Family-Distribution&quot;&gt;&lt;a href=&quot;#Exponential-Family-Distribution&quot; class=&quot;headerlink&quot; title=&quot;Exponential Family Distribution&quot;&gt;&lt;/a&gt;Exponential Family Distribution&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/HFC666/image/master/img/EX1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;https://www.bilibili.com/video/BV1QW411y7D3?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://www.hfcouc.work/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="概率论" scheme="https://www.hfcouc.work/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>狄利克雷过程</title>
    <link href="https://www.hfcouc.work/2022/07/06/BNP/"/>
    <id>https://www.hfcouc.work/2022/07/06/BNP/</id>
    <published>2022-07-06T02:17:50.000Z</published>
    <updated>2022-07-12T09:35:20.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p align="center">    <img src="https://img2.baidu.com/it/u=2682475456,642314187&fm=253&fmt=auto&app=138&f=JPEG?w=799&h=500" style="zoom: 100%;" /></p><blockquote><p>参看文献：</p><ol><li><a href="https://www.bilibili.com/video/BV1Tp411R7Sf?spm_id_from=333.337.search-card.all.click&amp;vd_source=6177c61c946280bb88c727585de76bc8">徐亦达老师课程</a></li><li><a href="http://hil.t.u-tokyo.ac.jp/~kameoka/SAP/papers/Teh2010a.pdf">狄利克雷过程文献</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X">A Tutorial on Bayesian Nonparametric Models</a></li></ol></blockquote><span id="more"></span><h2 id="狄利克雷过程"><a href="#狄利克雷过程" class="headerlink" title="狄利克雷过程"></a>狄利克雷过程</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>考虑下列问题，假设我们用高斯混合模型来做聚类。假设我们的数据为$x_1,x_2,\cdots,x_N$，那我们的似然函数的对数为：</p><script type="math/tex; mode=display">\sum_{i=1}^N\log\sum_{l=1}^K\alpha_i\mathcal{N}(\mu_i,\sigma_i^2)</script><p>但是我们需要事先确定聚类的个数，但是在很多情况下聚类的个数并不是那么容易确定，我们需要从数据中学习到聚类的个数。一个方法是我们将聚类的数目$K$也作为一个参数，那么我们的参数$\theta = (K,\theta_1,\sigma_1,\cdots,\theta_K,\sigma_K)$。我们的优化问题变为：</p><script type="math/tex; mode=display">\hat{\theta} = \arg\max_{\theta}\sum_{i=1}^N\log\sum_{l=1}^K\alpha_i\mathcal{N}(\mu_i,\sigma_i^2)</script><p>但是我们很容易发现当$K=N$，$\mu_i$为数据的值，$\sigma_i=0$的时候似然函数达到最大，即每一个数据都是一个类，这不是我们想要的。<br>我们的一个方法是假设每个数据$x_i$都来自于参数为$\theta_i$的一个分布，而$\theta_i\sim H(\theta)$，其中分布$H(\theta)$为连续分布，但是这样会参在新的问题：因为$H(\theta)$为连续分布，所以$P(\theta_i=\theta_j)=0,i\neq j$。所以这样每个数据来自的分布都不一样，又回到了之前提到的$K=N$的问题了。所以我们令$\theta$来自一个离散分布$G(\theta)$，而$G\sim \text{DP}(\alpha,H)$，其中DP表示狄利克雷过程，而$H$为之前的连续分布，$\alpha&gt;0$为常数，其反映$G$的离散程度，越大表示离散程度越小，当$\alpha\rightarrow0$时，$G$离散程度最大，为一个点；当$\alpha\rightarrow \infty$时，$G\approx H$。</p><blockquote><p>$H$也不一定是连续的，其被称为base measure。</p></blockquote><p>注意这里的$G$为一个random measure，我们每次从$\text{DP}(\alpha,H)$中采样得到的不是一个数值，而是一个分布。假设我们采集到的分布为：</p><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/DP1.png" alt=""></p><blockquote><p>其中$G_1,G_2$为两次采样产生的分布，上面的棍子表示概率密度，其和为$1$。我们将其分为$a_1,a_2,\cdots,a_d$等$d$个区域，其中每个区域的总概率密度符合狄利克雷分布，即</p><script type="math/tex; mode=display">(G(a_1),G(a_2),\cdots,G(a_d))\sim \text{Dir}(\alpha H(a_1),\alpha H(a_2),\cdots,\alpha H(a_d))</script><p>这就是狄利克雷过程的定义。</p></blockquote><p>关于狄利克雷分布：</p><script type="math/tex; mode=display">P(x_1,\cdots,x_i,\cdots,x_K)\sim \text{Dir}(\alpha_1,\cdots,\alpha_i,\cdots,\alpha_K)</script><p>则</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[x_i]  &= \frac{\alpha_i}{\sum_k \alpha_k}\\\text{Var}[x_i]&=\frac{\alpha_i(\sum_k\alpha_k-\alpha_i)}{(\sum_k\alpha_k)^2(\sum_{k}\alpha_k+1)}\end{aligned}</script><p>将其带入到狄利克雷过程中，得：</p><script type="math/tex; mode=display">\mathbb{E}[G[a_i]] = \frac{\alpha H(a_i)}{\sum_k\alpha H(a_k)} = H(a_i)</script><script type="math/tex; mode=display">\text{var}[G[a_i]] = \frac{\alpha H(a_i)(\alpha-\alpha H(a_i))}{\alpha^2(\alpha+1)} = \frac{H(a_i)(1-H(a_i))}{\alpha+1}</script><p>我们之前说过关于$\alpha$的性质。现在我们来看一下，均值(期望)与$\alpha$无关，当$\alpha\rightarrow \infty$是，方差趋近于$0$，这说明不管我们怎么划分，在每个$a_i$处，$G(a_i)=H(a_i)$，说明$G(x)=H(x)$，即$G(x)$是连续的是最不离散的版本；如果$\alpha=0$，则$\text{Var}=H(a_i)(1-H(a_i))$，这正是伯努利分布的方差，因此在每个划分上我们都可以用一根棍来表示它们(包括不划分)，这是最离散的版本。</p><h3 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h3><p>那我们如何构建$G$呢？即如何从$H$中采样得到$G$呢？我们采用<code>stick-breaking construction</code>的方法来产生$G$。其构建方式为：</p><ol><li>从$H$中采样得到$\theta_1$，即$\theta_1\sim H$</li><li>采样$\beta_1\sim\text{Beta}(1,\alpha)$</li><li>权重$\pi_1=\beta_1$</li><li>采样$\theta_2\sim H$</li><li>采样$\beta_2\sim \text{Beta}(1,\alpha)$</li><li>权重$\pi_2 = (1-\pi)\beta_2$<br>以此类推，这样权重$\pi_2$相当于是从取完$\pi_1$剩下的权重中取得。</li></ol><p>我们在看一下关于$\alpha$得一些内容，当$\alpha=0$时，$\mathbb{E}(\beta_i)=1,\text{Var}(\beta_i)=0$，所以一次就把权重全部采完，即只产生一个样本，对应于最离散的情况，而当$\alpha=\infty$时，$\mathbb{E}(\beta_i)=0$，相当于连续分布的情况。我们常将此采样方法写为$\pi \sim \text{GEM}(\alpha)$。</p><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><p>下面我们再回顾一下。对于狄利克雷过程，有如下性质：</p><script type="math/tex; mode=display">G\sim \text{DP}(\alpha,H)\Leftrightarrow (G(a_1),\cdots,G(a_n))\sim \text{DIR}(\alpha H(a_1),\cdots,\alpha H(a_n)),\quad \text{for any partitions }a_1,\cdots,a_n</script><p>总结之前讲过的，我们有：</p><script type="math/tex; mode=display">G\sim \text{DP}(\alpha,H)</script><script type="math/tex; mode=display">\theta_1,\cdots,\theta_N\sim G</script><script type="math/tex; mode=display">X_i\sim F(\theta_i)</script><p>其图模型为：</p><p><img src="https://raw.githubusercontent.com/HFC666/image/master/img/DP2.png" alt=""></p><p>下面我们研究一下$G$的后验分布$P(G\mid \theta_1,\cdots,\theta_N)$：</p><script type="math/tex; mode=display">P(G\mid \theta_1,\cdots,\theta_N)\propto P(\theta_1,\cdots,\theta_N\mid G)P(G)</script><p>在研究之前我们先看一个关于狄利克雷分布和多项式分布的例子：<br>假设</p><script type="math/tex; mode=display">\begin{aligned}p_1,\cdots,p_N&\sim\text{DIR}(\alpha_1,\cdots,\alpha_N)\\n_1,\cdots,n_N&\sim\text{Mult}(p_1,\cdots,p_N)\end{aligned}</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}P(p_1,\cdots,p_N\mid n_1,\cdots,n_N)&\propto\left(\frac{\Gamma(\sum_{i=1}^N\alpha_i)}{\prod_{i=1}^N\Gamma(\alpha_i)}\prod P_i^{\alpha_i-1}\right)\left(\frac{(\sum_{i=1}^Nn_i)!}{n_1!\cdots n_N!}\prod_{i=1}^NP_i^{n_i}\right)\\&\propto \prod_{i=1}^NP_i^{\alpha_i+n_i-1}\\ &= \text{DIR}(\alpha_1+n_1,\cdots,\alpha_N+n_N)\end{aligned}</script><h3 id="Posterior"><a href="#Posterior" class="headerlink" title="Posterior"></a>Posterior</h3><p>有了前面的指示，下面我们来看一下后验分布：<br>对于任何划分</p><script type="math/tex; mode=display">\begin{aligned}P(G(a_1),\cdots,G(a_K)\mid \theta_1,\cdots,\theta_K)&\propto P(\theta_1,\cdots,\theta_K\mid G(a_1),\cdots,G(a_K))P(G)\\&=\text{Mult}(n_1,\cdots,n_K)\text{DIR}(\alpha H(a_1),\cdots,\alpha H(a_K))\\&= \text{Dir}(n_1+\alpha H(a_1),\cdots,n_K+\alpha H(a_K))\\&= \text{DP}\left(\alpha+n,\frac{\alpha H+\sum_{i=1}^K\delta_{\theta_i}}{\alpha+n}\right)\end{aligned}</script><p>其中$n=\sum_{i=1}^K n_i，G=\sum_{i=1}^\infty\pi_i\delta_{\theta_i}$。最后一步是怎么来的呢？<br>所以我们得到的后验分布为：</p><script type="math/tex; mode=display">P(G(a_1),\cdots,G(a_K))\sim \text{Dir}(n_1+\alpha H(a_1),\cdots,n_K+\alpha H(a_K))</script><p>根据之前讲过的狄利克雷过程的性质，狄利克雷过程的第一个参数是对应的狄利克雷分布的测度和，而第二个参数为归一化后的一个概率分布，理解为狄利克雷分布的参数除以归一化系数。所以第一个参数为：$\sum_{i=1}^K n_i+\alpha H(a_i) = \alpha+n$，而第二个参数为$\frac{\alpha H+\sum_{i=1}^K\delta_{\theta_i}}{\alpha+n}$，其中$\alpha+n$为归一化参数，而分子$\sum_{i=1}^N\delta_{\theta_i}(a_j)$实际上就是表示$n_j$。<br>我们再看一下得到的分布：</p><script type="math/tex; mode=display">\frac{\alpha H+\sum_{i=1}^N\delta_{\theta_i}}{\alpha+n} = \frac{\alpha}{\alpha+n}H+\frac{\sum_{i=1}^N\delta_{\theta_i}}{\alpha+n}</script><p>为一个连续的分布加上一个离散的分布，这被称为<code>spike and slab</code>。</p><h3 id="Predictive-distribution"><a href="#Predictive-distribution" class="headerlink" title="Predictive distribution"></a>Predictive distribution</h3><p>什么是预测分布呢？预测分布为：</p><script type="math/tex; mode=display">\begin{aligned}P(X_i\mid X_{-i}) &= \int_w P(X_i,w\mid X_{-i})dw\\&= \int_w P(X_i\mid w,X_{-i})P(w\mid X_{-i})dw\\&= \int_wP(X_i\mid w)P(w\mid X_{-i})dw\end{aligned}</script><p>其中$X_{-i}$表示去除第$i$项后的$X$。<br>对于狄利克雷过程，我们想要求得的为：</p><script type="math/tex; mode=display">P(\theta_i\mid \theta_{-i}) = \int_G P(\theta_i\mid G)P(G\mid \theta_{-i})dG</script><p>由此可以看出，我们的预测分布可以看作是后验分布$\theta_i$在后验分布$P(G\mid \theta_{-i})$下的期望，根据狄利克雷分布的性质，其期望为</p><script type="math/tex; mode=display">\frac{\alpha}{\alpha+n}H+\frac{\sum_{i=1}^N\delta_{\theta_i}}{\alpha+n}</script><p>所以其预测分布等于后验分布。</p><p>$\theta_1,\theta_2,\cdots$预测分布的序列被称为<code>Blackwell-MacQueen urn scheme</code>。这个名字来源于一个隐喻。特别地，在$\Theta$中的每一个值都是唯一的颜色，并且抽样$\theta\sim G$来给球上色。另外我们有一个盒子来装之前看过的球。起初在盒子里没有球，我们从$H$中取颜色，$\theta_1\sim H$，给球上色并将其放在盒子里。在之后的步骤中，如在$n+1$步中，我们要么以$\frac{\alpha}{\alpha+n}$抽取一个新颜色($\theta_{n+1}\sim H$)，给球染色并将其放到盒子中，或者以概率$\frac{n}{\alpha+n}$从盒子中取出一个球，将新球涂成它的颜色(从经验分布中抽样)并放到盒子里。</p><p><code>Blackwell-MacQueen urn scheme</code>可以被用来证明DP的存在。我们可以在序列$\theta_1,\theta_2,\cdots$上构建分布，通过迭代地在给定$\theta_1,\cdots,\theta_{i-1}$的条件下采样$\theta_i$。对于$n\ge1$令</p><script type="math/tex; mode=display">P(\theta_1,\cdots,\theta_n) = \prod_{i=1}^nP(\theta_i\mid \theta_1,\cdots,\theta_{i-1})</script><p>可以得到这个随机序列是无限可交换的。也就是说，对于每一个$n$，生成$\theta_1,\cdots,\theta_n$的概率等于以任何顺序采样得到它们的概率。</p><p>下面我们来证明一下，令$I_k$表示第$k$类的索引，$N_k$表示第$k$类的样本数，那么在第$k$类的样本的上述关于$\theta$的概率为：</p><script type="math/tex; mode=display">\frac{\alpha\cdot1\cdot2\cdots(N_k-1)}{(I_{k,1}-1+\alpha)(I_{k,2}-1+\alpha)\cdots(I_{k,N_k)}-1+\alpha)}</script><p>第一项是因为我们第一次到新的类$k$，所以概率为$\frac{\alpha}{I_{k,1}-1+\alpha}$，第二项是因为$k$已经出现了，所以概率为$\frac{1}{(I_{k,2}-1+\alpha)}$，以此类推。对于所有的类：</p><script type="math/tex; mode=display">p(\theta_{1:N}) = \prod_{k=1}^K\frac{\alpha(N_k-1)!}{(I_{k,1}-1+\alpha)(I_{k,2}-1+\alpha)\cdots(I_{k,N_k}-1+\alpha)}</script><p>注意所有$I_k$的并为所有的索引，我们将索引合并，得：</p><script type="math/tex; mode=display">p(\theta_{1:N}) = \frac{\alpha^K\prod_{k=1}^K(N_k-1)!}{\prod_{i=1}^N(i-1+\alpha)}</script><p>所以很明显看出来是无限可交换的。</p><p>现在<code>de Finetti&#39;s theorem</code>说明对于任何无限可交换序列$\theta_1,\theta_2,\cdots$存在一个随机分布$G$使得序列可以被分解为独立同分布地从下列采样：</p><script type="math/tex; mode=display">P(\theta_1,\cdots,\theta_n) = \int\prod_{i=1}^n G(\theta_i)dP(G)</script><p>在我们的设置中，随机分布$P(G)$的先验正是狄利克雷过程$\text{DP}(\alpha,H)$，因此DP存在。</p><h3 id="Clustering-Partitions-and-the-Chinese-Restaurant-Process"><a href="#Clustering-Partitions-and-the-Chinese-Restaurant-Process" class="headerlink" title="Clustering, Partitions and the Chinese Restaurant Process"></a>Clustering, Partitions and the Chinese Restaurant Process</h3><p>DP的离散性质也暗示了聚类的特性。现在我们假设$H$是光滑的，因此所有的重复值都由于DP的离散性质而不是$H$自身。因此采样得到的值有重复的，令$\theta_1^\star,\cdots,\theta_m^\star$为$\theta_1,\cdots,\theta_n$去除重复值后的结果并且$n_k$为$\theta_k^\star$重复的次数。预测分布可以被等价地写为：</p><script type="math/tex; mode=display">\theta_{n+1}\mid \theta_1,\cdots,\theta_n\sim \frac{1}{\alpha+n}\left(\alpha H+\sum_{k=1}^m n_k\delta_{\theta_k^\star}\right)</script><p>我们可以通过查看由聚类引起的划分来进一步研究DP的聚类属性。$\theta_1,\cdots,\theta_n$去除重复值后将对集合$[n]=\{1,\cdots,n\}$分区引进了聚类使得在每一个类$k$中，$\theta_i$取相同的值$\theta_k^\star$。</p><p>分区的分布被称为中国餐馆过程(CRP)。在这个情境下我们有一个中国餐馆，里面有无穷多个桌子，每个桌子可以坐无穷多个人。第一个人进入餐馆坐在第一个位置，第二个人可以坐在第一个人的位置或者坐在新的位置。一般地，第$n+1$个人要么以正比于$n_k$的概率坐在已经有人的位置$k$，或者以正比于$\alpha$的概率坐在新的位置。</p><p>我们也可以估计聚类数目的期望。假设共有$n$个观测，对于$i\ge1$，观测$\theta_i$以$\frac{\alpha}{\alpha+i-1}$的概率取新的值，所以聚类数$m$的期望为：</p><script type="math/tex; mode=display">\mathbb{E}[m\mid n] = \sum_{i=1}^n\frac{\alpha}{\alpha+i-1}\in \mathcal{O}(\alpha \log n)</script><p>因为$\theta$为离散值，具有相同$\theta$值得数据表示属于同一类，我们可以用$Z$来表示属于哪一类。即计算$P(Z_i\mid Z_{-i})$。有多少类只与参数$\alpha$有关，而$\theta$的位置(值)则与$H$有关。</p><p>我们下面计算：</p><script type="math/tex; mode=display">P(Z_i=m\mid Z_{-i}) = \frac{P(Z_i=m,Z_{-i})}{P(Z_{-i})}</script><p>我们如何将其与狄利克雷过程结合起来呢？将其与狄利克雷过程结合起来很难，因为狄利克雷过程有无限多的项，我们可以假设其外$K$项，然后再将$K$取无穷。我们用如下方法：</p><script type="math/tex; mode=display">\begin{aligned}P(Z_i=m\mid Z_{-i}) &= \frac{P(Z_i=m,Z_{-i})}{P(Z_{-i})}\\&=\frac{\int_{P_1,\cdots,P_K}P(Z_i=m,Z_{-i}\mid P_1,\cdots,P_K)\text{DIR}(\alpha/K,\cdots,\alpha/K)dP}{\int_{P_1,\cdots,P_K}P(Z_{-i}\mid P_1,\cdots,P_K)\text{DIR}(\alpha/K,\cdots,\alpha/K)dP}\end{aligned}</script><p>关于积分的计算就用到我们之前的多项式分布和狄利克雷分布共轭的知识了：</p><script type="math/tex; mode=display">\begin{aligned}&\int_{p_1,\cdots,p_K}P(n_1,\cdots,n_K\mid p_1,\cdots,p_K)P(p_1,\cdots,p_K\mid \alpha_1,\cdots,\alpha_K)dP\\&=\frac{n!}{n_1!\cdots n_K!}\frac{\Gamma(\sum\alpha_i)}{\prod\Gamma(\alpha_i)}\int_{p_1,\cdots,p_K}\prod_{i=1}^K p_i^{n_i+\alpha_i-1}dp\\&=\frac{n!}{n_1!\cdots n_K!}\frac{\Gamma(\sum\alpha_i)}{\prod\Gamma(\alpha_i)}\frac{\prod\Gamma(\alpha_i+n_i)}{\Gamma(\sum\alpha_i+n)}\end{aligned}</script><p>我们将其应用到分子和分母上，首先定义符号：$n_{l,-i}$表示去除第$i$个数据后属于第$l$类的个数。我们知道第二项：</p><script type="math/tex; mode=display">\frac{\Gamma(\sum\alpha_i)}{\prod\Gamma(\alpha_i)}</script><p>只与先验有关，所以分子分母都一样。</p><p>我们先看第一项，因为在我们的情景下，即便类数相等，每个类的个数相等，但是相同个体不属于同一个类，这两种划分方法得到的第一项的值是相同的，但是在我们的情境下是不同的，所以第一项不应该存在。</p><p>第三项代入为：</p><script type="math/tex; mode=display">\frac{\Gamma(\alpha/K+n_{m,-i}+1)\prod_{l\neq i} \Gamma(\alpha/K+n_{l,-i})}{\Gamma(\alpha+n)}\cdot \frac{\Gamma(\alpha+n-1)}{\prod\Gamma(\sum_l \alpha/K+n_{l,-i})}</script><p>伽马函数具有如下性质：</p><script type="math/tex; mode=display">\Gamma(x) = (x-1)\Gamma(x-1)</script><p>上式化简得到：</p><script type="math/tex; mode=display">\frac{n_{m,-i}+\frac{\alpha}{K}}{n+\alpha-1}</script><p>当$K\rightarrow \infty$为</p><script type="math/tex; mode=display">\frac{n_{m,-i}}{n+\alpha-1}</script><p>对$m$进行求和得到：</p><script type="math/tex; mode=display">\sum_m\frac{n_{m,-i}}{n+\alpha-1} = \frac{n-1}{n+\alpha-1}\neq1</script><p>这与概率密度的定义不同，所以有$\frac{\alpha}{n+\alpha-1}$的概率属于新的一个类，这就是<strong>中国餐馆过程</strong>。</p><h3 id="Dirichlet-Process-Mixture-Models"><a href="#Dirichlet-Process-Mixture-Models" class="headerlink" title="Dirichlet Process Mixture Models"></a>Dirichlet Process Mixture Models</h3><p>狄利克雷混合模型可以写为：</p><script type="math/tex; mode=display">\begin{aligned}&\pi \mid \alpha \sim \operatorname{GEM}(\alpha)\\&\theta_{k}^{*} \mid H \sim H\\&z_{i} \mid \pi \sim \operatorname{Mult}(\pi)\\&x_{i} \mid z_{i},\left\{\theta_{k}^{*}\right\} \sim F\left(\theta_{z_{i}}^{*}\right)\end{aligned}</script><p>狄利克雷混合模型为无限混合模型，指的是具有无限可数个类的混合模型。与事先确定了类的有限混合模型不同，狄利克雷混合模型会根据数据确定聚类的数目。</p><blockquote><p>狄利克雷过程为无参贝叶斯方法的一种，为什么是无参？我们理解是狄利克雷过程是分布的先验，而狄利克雷过程采样得到的分布为我们产生数据的分布，在有参数的模型中此分布有参数(感觉像废话)，而狄利克雷过程产生的分布无法用参数表示故为无参数模型。我们将分布作为概率的一部分，并且存在自己的先验分布，也可以让我们通过数据来自动调节分布的复杂度。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://img2.baidu.com/it/u=2682475456,642314187&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=799&amp;h=500&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;参看文献：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Tp411R7Sf?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=6177c61c946280bb88c727585de76bc8&quot;&gt;徐亦达老师课程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hil.t.u-tokyo.ac.jp/~kameoka/SAP/papers/Teh2010a.pdf&quot;&gt;狄利克雷过程文献&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sciencedirect.com/science/article/abs/pii/S002224961100071X&quot;&gt;A Tutorial on Bayesian Nonparametric Models&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="文献阅读" scheme="https://www.hfcouc.work/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="贝叶斯" scheme="https://www.hfcouc.work/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
    <category term="算法" scheme="https://www.hfcouc.work/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>书籍Thinking Julia后几章阅读笔记</title>
    <link href="https://www.hfcouc.work/2022/07/03/thinkjulia2/"/>
    <id>https://www.hfcouc.work/2022/07/03/thinkjulia2/</id>
    <published>2022-07-03T00:55:18.000Z</published>
    <updated>2022-07-03T00:58:24.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p align="center">    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F0641bd5a05ae260e3167b7a6b6f389143abb0416.jpg&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659401858&t=1004217d7de1a7d354b99be904052734" style="zoom: 100%;" /></p><blockquote><p>书籍网址：<a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">https://benlauwens.github.io/ThinkJulia.jl/latest/book.html</a></p></blockquote><span id="more"></span><h2 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h2><h3 id="A-Dictionary-Is-a-Mapping"><a href="#A-Dictionary-Is-a-Mapping" class="headerlink" title="A Dictionary Is a Mapping"></a>A Dictionary Is a Mapping</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; eng2sp = <span class="built_in">Dict</span>()</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>, <span class="built_in">Any</span>&#125;()</span><br></pre></td></tr></table></figure><p>我们可以使用方括号为字典添加数据：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; eng2sp[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;uno&quot;</span></span><br><span class="line"><span class="string">&quot;uno&quot;</span></span><br><span class="line">julia&gt; eng2sp</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>, <span class="built_in">Any</span>&#125; with <span class="number">1</span> entry:</span><br><span class="line">  <span class="string">&quot;one&quot;</span> =&gt; <span class="string">&quot;uno&quot;</span></span><br></pre></td></tr></table></figure><p>上述输出的格式也可以作为输入的格式：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; eng2sp = <span class="built_in">Dict</span>(<span class="string">&quot;one&quot;</span>=&gt;<span class="string">&quot;uno&quot;</span>, <span class="string">&quot;two&quot;</span>=&gt;<span class="string">&quot;dos&quot;</span>,<span class="string">&quot;three&quot;</span>=&gt;<span class="string">&quot;tres&quot;</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">String</span>, <span class="built_in">String</span>&#125; with <span class="number">3</span> entries: …</span><br><span class="line">julia&gt; eng2sp</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">String</span>, <span class="built_in">String</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">&quot;two&quot;</span>   =&gt; <span class="string">&quot;dos&quot;</span></span><br><span class="line">  <span class="string">&quot;one&quot;</span>   =&gt; <span class="string">&quot;uno&quot;</span></span><br><span class="line">  <span class="string">&quot;three&quot;</span> =&gt; <span class="string">&quot;tres&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出字典输出的顺序与我们输入的顺序不同，在<code>Julia</code>中，字典的输出顺序是不可预测的。</p><p>查看长度：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; length(eng2sp)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>keys</code>函数返回字典的键：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; ks = keys(eng2sp);</span><br><span class="line">julia&gt; print(ks)</span><br><span class="line">[<span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;three&quot;</span>]</span><br></pre></td></tr></table></figure><p>也可以用 <code>∈</code> 符号查看某个字符串是否在keys里：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="string">&quot;one&quot;</span> ∈ ks</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>使用<code>values</code>函数获取字典的值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; vs = values(eng2sp);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="string">&quot;uno&quot;</span> ∈ vs</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>字典有<code>get</code>函数，给定key获取其值，如果key不存在，则返回默认值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; get(eng2sp, <span class="string">&quot;one&quot;</span>,<span class="number">1</span>)    </span><br><span class="line"><span class="string">&quot;uno&quot;</span>                          </span><br><span class="line">                               </span><br><span class="line">julia&gt; get(eng2sp, <span class="string">&quot;four&quot;</span>,<span class="number">1</span>)   </span><br><span class="line"><span class="number">1</span>                              </span><br></pre></td></tr></table></figure><h3 id="Reverse-Lookup"><a href="#Reverse-Lookup" class="headerlink" title="Reverse Lookup"></a>Reverse Lookup</h3><p>我们可以根据值找键：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; findall(isequal(<span class="string">&quot;uno&quot;</span>), eng2sp) </span><br><span class="line"><span class="number">1</span>-element <span class="built_in">Vector</span>&#123;<span class="built_in">String</span>&#125;:              </span><br><span class="line"> <span class="string">&quot;one&quot;</span>                                 </span><br></pre></td></tr></table></figure><h3 id="Global-Variables"><a href="#Global-Variables" class="headerlink" title="Global Variables"></a>Global Variables</h3><p>全局变量是位于<code>Main</code>中的变量，我们一般将其用为<code>flag</code>来表示真假，如：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">verbose = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example1()</span><br><span class="line">    <span class="keyword">if</span> verbose</span><br><span class="line">        println(<span class="string">&quot;Running example1&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>但是如果你</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">been_called = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example2()</span><br><span class="line">    been_called = <span class="literal">true</span>         <span class="comment"># WRONG</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>你会发现<code>been_called</code>的值没有改变，这是因为函数中的<code>been_called</code>是局部变量，与函数外的变量无关系。</p><p>要在函数内部重新分配全局变量，必须在使用它之前声明该变量为全局变量：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">been_called = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example2()</span><br><span class="line">    <span class="keyword">global</span> been_called</span><br><span class="line">    been_called = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果一个全局变量引用了一个可变值，您可以修改该值，而不需要声明变量为全局变量：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">known = <span class="built_in">Dict</span>(<span class="number">0</span>=&gt;<span class="number">0</span>, <span class="number">1</span>=&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example4()</span><br><span class="line">    known[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因此，您可以添加、删除和替换全局数组或字典的元素，但如果您想重新分配变量，您必须声明它是全局的：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">known = <span class="built_in">Dict</span>(<span class="number">0</span>=&gt;<span class="number">0</span>, <span class="number">1</span>=&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example5()</span><br><span class="line">    <span class="keyword">global</span> known</span><br><span class="line">    known = <span class="built_in">Dict</span>()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h2><h3 id="Tuples-Are-Immutable"><a href="#Tuples-Are-Immutable" class="headerlink" title="Tuples Are Immutable"></a>Tuples Are Immutable</h3><p>元组是不可变的，其元素可以是不同的类型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure><p>创建只有一个元素的数组，后面必须加<code>,</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t1 = (<span class="string">&#x27;a&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>,)</span><br><span class="line">julia&gt; typeof(t1)</span><br><span class="line"><span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>&#125;</span><br></pre></td></tr></table></figure><p>如果提供了多个参数，则结果是一个具有给定参数的元组</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t3 = tuple(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">pi</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">π</span> = <span class="number">3.1415926535897</span>...)</span><br></pre></td></tr></table></figure><p>可以使用数字对元组进行索引：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; t[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;a&#x27;</span>: ASCII/Unicode U+<span class="number">0061</span> (category Ll: Letter, lowercase)</span><br><span class="line">julia&gt; t[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure><p>但是如果你尝试改变元组的值则会报错：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t[<span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching setindex!(::<span class="built_in">NTuple</span>&#123;<span class="number">5</span>,<span class="built_in">Char</span>&#125;, ::<span class="built_in">Char</span>, ::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure><p>元组逐元素比较大小：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) &lt; (<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2000000</span>) &lt; (<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Tuple-Assignment"><a href="#Tuple-Assignment" class="headerlink" title="Tuple Assignment"></a>Tuple Assignment</h3><p>交换<code>a,b</code>的值我们可以：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><p>左侧的值的数量要少于右边值的数量：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; (a, b) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">julia&gt; a  </span><br><span class="line"><span class="number">1</span>         </span><br><span class="line">          </span><br><span class="line">julia&gt; b  </span><br><span class="line"><span class="number">2</span>         </span><br><span class="line">julia&gt; a, b, c = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">ERROR: <span class="built_in">BoundsError</span>: attempt to access (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  at index [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="Tuples-as-Return-Values"><a href="#Tuples-as-Return-Values" class="headerlink" title="Tuples as Return Values"></a>Tuples as Return Values</h3><p>元组也可以作为返回值，如内置函数<code>diverm</code>返回整除和余数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; q, r = divrem(<span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@show</span> q r;</span><br><span class="line">q = <span class="number">2</span></span><br><span class="line">r = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Variable-length-Argument-Tuples"><a href="#Variable-length-Argument-Tuples" class="headerlink" title="Variable-length Argument Tuples"></a>Variable-length Argument Tuples</h3><p>函数可以接受可变数量的参数。末尾带有<code>...</code>的参数将参数聚集成元组：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> printall(args...)</span><br><span class="line">    println(args)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; printall(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>同样的元组后加<code>...</code>可以将元组分解作为多个参数传入：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = (<span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; divrem(t)</span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching divrem(::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int64</span>,<span class="built_in">Int64</span>&#125;)</span><br><span class="line">julia&gt; divrem(t...)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="Arrays-and-Tuples"><a href="#Arrays-and-Tuples" class="headerlink" title="Arrays and Tuples"></a>Arrays and Tuples</h3><p>内建函数<code>zip</code>可以将两个或多个序列转换为元组的集合，每个元组包含每个序列的一个元素。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; t = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; zip(s,t)</span><br><span class="line">zip(<span class="string">&quot;abc&quot;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>返回一个<code>zip</code>对象，<code>zip</code>对象是一种迭代器，它是对序列进行迭代的任何对象。迭代器在某些方面类似于数组，但与数组不同的是，不能使用索引从迭代器中选择元素。我们可以使用<code>for</code>循环对其进行遍历：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> pair <span class="keyword">in</span> zip(s,t)</span><br><span class="line">       println(pair)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如果你想用数组的方法来操纵<code>zip</code>对象，可以将其转换为数组：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; collect(zip(s,t))</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Vector</span>&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>, <span class="built_in">Int64</span>&#125;&#125;:</span><br><span class="line"> (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"> (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"> (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如果序列长度不一样，那么用长度较小的序列：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; collect(zip(<span class="string">&quot;Anne&quot;</span>, <span class="string">&quot;Elk&quot;</span>))</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Char</span>&#125;,<span class="number">1</span>&#125;:</span><br><span class="line"> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line"> (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line"> (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;k&#x27;</span>)</span><br></pre></td></tr></table></figure><p>你可以在<code>for</code>循环中使用元组赋值来遍历元组数组：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = [(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> (letter, number) <span class="keyword">in</span> t</span><br><span class="line">           println(number, <span class="string">&quot; &quot;</span>, letter)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure><p>使用<code>enumerate</code>来获得索引和元素：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> (index, element) <span class="keyword">in</span> enumerate(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">           println(index, <span class="string">&quot; &quot;</span>, element)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure><h3 id="Dictionaries-and-Tuples"><a href="#Dictionaries-and-Tuples" class="headerlink" title="Dictionaries and Tuples"></a>Dictionaries and Tuples</h3><p>我们可以使用元组来初始化字典：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = [(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">julia&gt; d = <span class="built_in">Dict</span>(t)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">&#x27;c&#x27;</span> =&gt; <span class="number">3</span></span><br><span class="line">  <span class="string">&#x27;b&#x27;</span> =&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>将<code>zip</code>和<code>Dict</code>结合起来创建字典很简洁：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; d = <span class="built_in">Dict</span>(zip(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>:<span class="number">3</span>))</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">&#x27;c&#x27;</span> =&gt; <span class="number">3</span></span><br><span class="line">  <span class="string">&#x27;b&#x27;</span> =&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><h3 id="Reading-and-Writing"><a href="#Reading-and-Writing" class="headerlink" title="Reading and Writing"></a>Reading and Writing</h3><p>使用<code>w</code>模式对文件进行写，如果文件存在则清空以前的内容，不存在则重新创建一个。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; fout = open(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="built_in">IOStream</span>(&lt;file output.txt&gt;)</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; line1 = <span class="string">&quot;This here&#x27;s the wattle,\n&quot;</span></span><br><span class="line"><span class="string">&quot;This here&#x27;s the wattle,\n&quot;</span></span><br><span class="line"></span><br><span class="line">julia&gt; write(fout, line1)</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><p>返回的为写入的字符串长度。</p><p>当写入完毕后，要关闭文件：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; close(fout)</span><br></pre></td></tr></table></figure><h3 id="Filenames-and-Paths"><a href="#Filenames-and-Paths" class="headerlink" title="Filenames and Paths"></a>Filenames and Paths</h3><p><code>pwd</code>获取当前路径，<code>abspath</code>获取文件所处绝对路径，<code>ispath</code>判断是否为路径，<code>isdir</code>判断是否为文件夹，<code>readdir</code>读取路径下所有文件和路径。</p><h3 id="Catching-Exceptions"><a href="#Catching-Exceptions" class="headerlink" title="Catching Exceptions"></a>Catching Exceptions</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">    fin = open(<span class="string">&quot;bad_file.txt&quot;</span>)</span><br><span class="line"><span class="keyword">catch</span> exc</span><br><span class="line">    println(<span class="string">&quot;Something went wrong: <span class="variable">$exc</span>&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">    println(<span class="string">&quot;finally&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h3><p>函数<code>serialize</code>和<code>deserialize</code>可以将任何类型的对象转为字节数组。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> Serialization</span><br><span class="line"></span><br><span class="line">julia&gt; io = <span class="built_in">IOBuffer</span>()</span><br><span class="line"><span class="built_in">IOBuffer</span>(data=<span class="built_in">UInt8</span>[...], readable=<span class="literal">true</span>, writable=<span class="literal">true</span>, seekable=<span class="literal">true</span>, append=<span class="literal">false</span>, size=<span class="number">0</span>, maxsize=<span class="literal">Inf</span>, ptr=<span class="number">1</span>, mark=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; t = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; serialize(io, t)</span><br><span class="line"><span class="number">24</span></span><br><span class="line"></span><br><span class="line">julia&gt; print(take!(io))</span><br><span class="line"><span class="built_in">UInt8</span>[<span class="number">0x37</span>, <span class="number">0x4a</span>, <span class="number">0x4c</span>, <span class="number">0x0f</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0xe2</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]</span><br></pre></td></tr></table></figure><p>输出的类型不利于我们阅读，我们可以将其转换为原来的格式：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; io = <span class="built_in">IOBuffer</span>();</span><br><span class="line"></span><br><span class="line">julia&gt; t1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; serialize(io, t1)</span><br><span class="line"><span class="number">24</span></span><br><span class="line"></span><br><span class="line">julia&gt; s = take!(io)</span><br><span class="line"><span class="number">36</span>-element <span class="built_in">Vector</span>&#123;<span class="built_in">UInt8</span>&#125;: …</span><br><span class="line"></span><br><span class="line">julia&gt; t2 = deserialize(<span class="built_in">IOBuffer</span>(s));</span><br><span class="line"></span><br><span class="line">julia&gt; print(t2)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>尽管新的对象和原对象的值相同，但是它们不是同一个对象：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t1 == t2          </span><br><span class="line"><span class="literal">true</span>                     </span><br><span class="line">                         </span><br><span class="line">julia&gt; t1 === t2         </span><br><span class="line"><span class="literal">false</span>                    </span><br></pre></td></tr></table></figure><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>如果你有一个文件<code>wc.jl</code>，内容为：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> linecount(filename)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> eachline(filename)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    count</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">print(linecount(<span class="string">&quot;wc.jl&quot;</span>))</span><br></pre></td></tr></table></figure><p>如果你运行此段代码，它读取自己并输出$9$。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; include(<span class="string">&quot;wc.jl&quot;</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p><code>Julia</code>引入了一些模块(module)来创建单独的变量工作区，即新的全局作用域。<code>import</code>允许控制来自其他模块的哪些名称是可见的，<code>export</code>确定哪些名称是公共的，即可以在模块外不加模块名称前缀来使用。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> LineCount</span><br><span class="line">    <span class="keyword">export</span> linecount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> linecount(filename)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> eachline(filename)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        count</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>将上述文件保存为<code>LineCount.jl</code>，之后运行<code>push!(LOAD_PATH, &quot;.&quot;)</code>，将当前目录添加到工作路径，<code>.</code>表示当前路径。之后</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> LineCount</span><br><span class="line"></span><br><span class="line">julia&gt; linecount(<span class="string">&quot;wc.jl&quot;</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h2 id="Structs-and-Objects"><a href="#Structs-and-Objects" class="headerlink" title="Structs and Objects"></a>Structs and Objects</h2><h3 id="Composite-Types"><a href="#Composite-Types" class="headerlink" title="Composite Types"></a>Composite Types</h3><p>我们可以通过<code>struct</code>来定义复合类型，如定义<code>Point</code>类型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point</span><br><span class="line">    x</span><br><span class="line">    y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">julia&gt; p = Point(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">Point(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br></pre></td></tr></table></figure><p>返回值是对<code>Point</code>对象的引用，我们将其赋值给<code>p</code>。</p><h3 id="Structs-are-Immutable"><a href="#Structs-are-Immutable" class="headerlink" title="Structs are Immutable"></a>Structs are Immutable</h3><p>你可以使用<code>.</code>符号来获取字段的值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = p.x</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">julia&gt; p.y</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure><p><code>struct</code>在默认情况下是不可变的，构造之后字段的值不可改变：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; p.y = <span class="number">1.0</span></span><br><span class="line">ERROR: setfield! immutable <span class="keyword">struct</span> of type Point cannot be changed</span><br></pre></td></tr></table></figure><h3 id="Mutable-Structs"><a href="#Mutable-Structs" class="headerlink" title="Mutable Structs"></a>Mutable Structs</h3><p>我们可以使用<code>mutate</code>关键字使<code>struct</code>可变：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> MPoint</span><br><span class="line">    x</span><br><span class="line">    y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; blank = MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">julia&gt; blank.x = <span class="number">3.0</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">julia&gt; blank.y = <span class="number">4.0</span></span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure><h3 id="Rectangles"><a href="#Rectangles" class="headerlink" title="Rectangles"></a>Rectangles</h3><p>我们可以创建一个矩形对象，字段为一个端点的坐标和宽度和长度：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Represents a rectangle.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fields: width, height, corner.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">struct</span> Rectangle</span><br><span class="line">    width</span><br><span class="line">    height</span><br><span class="line">    corner</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; origin = MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">julia&gt; box = Rectangle(<span class="number">100.0</span>, <span class="number">200.0</span>, origin)</span><br><span class="line">Rectangle(<span class="number">100.0</span>, <span class="number">200.0</span>, MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>))</span><br></pre></td></tr></table></figure><h3 id="Instances-as-Arguments"><a href="#Instances-as-Arguments" class="headerlink" title="Instances as Arguments"></a>Instances as Arguments</h3><p>实例可以作为参数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> printpoint(p)</span><br><span class="line">    println(<span class="string">&quot;(<span class="subst">$(p.x)</span>, <span class="subst">$(p.y)</span>)&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当把一个实例传入到函数中去，函数会改变实例的字段值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> movepoint!(p, dx, dy)</span><br><span class="line">    p.x += dx</span><br><span class="line">    p.y += dy</span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; origin = MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">julia&gt; movepoint!(origin, <span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; origin</span><br><span class="line">MPoint(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>但是，你可以修改不可变对象的可变属性的值，如：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> moverectangle!(rect, dx, dy)</span><br><span class="line">  movepoint!(rect.corner, dx, dy)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; box</span><br><span class="line">Rectangle(<span class="number">100.0</span>, <span class="number">200.0</span>, MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>))</span><br><span class="line">julia&gt; moverectangle!(box, <span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; box</span><br><span class="line">Rectangle(<span class="number">100.0</span>, <span class="number">200.0</span>, MPoint(<span class="number">1.0</span>, <span class="number">2.0</span>))</span><br></pre></td></tr></table></figure><h3 id="Instances-as-Return-Values"><a href="#Instances-as-Return-Values" class="headerlink" title="Instances as Return Values"></a>Instances as Return Values</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> findcenter(rect)</span><br><span class="line">    Point(rect.corner.x + rect.width / <span class="number">2</span>, rect.corner.y + rect.height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Copying"><a href="#Copying" class="headerlink" title="Copying"></a>Copying</h3><p><code>Julia</code>内建函数<code>deepcopy</code>可以复制任何对象：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; p1 = MPoint(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">MPoint(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">julia&gt; p2 = deepcopy(p1)</span><br><span class="line">MPoint(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">julia&gt; p1 ≡ p2</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">julia&gt; p1 == p2</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>≡</code>的结果我们应该能接受，因为是不同的对象，但是<code>==</code>的结果我们可能无法接受，因为两个对象的值是相同的，这是因为在<code>Julia</code>中可变复合类型<code>mutate</code>，<code>Julia</code>不知道什么是等价的。</p><p>而在不可变复合类型中相反：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; p1 = Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; p2 = deepcopy(p1)</span><br><span class="line">Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; p1==p2</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">julia&gt; p1===p2</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>因为我们不会改变<code>p1</code>，所以复制也就没意义。</p><h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p>判断<code>p</code>是否为<code>Point</code>类型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; p <span class="keyword">isa</span> Point</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>查看<code>Point</code>类型的字段：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; fieldnames(Point)</span><br><span class="line">(:x, :y)</span><br></pre></td></tr></table></figure><p>或者使用：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; isdefined(p, :x)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; isdefined(p, :z)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="Structs-and-Functions"><a href="#Structs-and-Functions" class="headerlink" title="Structs and Functions"></a>Structs and Functions</h2><h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>我们构建时间类：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Represents the time of day.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fields: hour, minute, second</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">struct</span> MyTime</span><br><span class="line">    hour</span><br><span class="line">    minute</span><br><span class="line">    second</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; time = MyTime(<span class="number">11</span>, <span class="number">59</span>, <span class="number">30</span>)</span><br><span class="line">MyTime(<span class="number">11</span>, <span class="number">59</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><h3 id="Pure-Functions"><a href="#Pure-Functions" class="headerlink" title="Pure Functions"></a>Pure Functions</h3><p>下面是两个时间相加的简单原型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> addtime(t1, t2)</span><br><span class="line">    MyTime(t1.hour + t2.hour, t1.minute + t2.minute, t1.second + t2.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面函数被称为纯函数，因为它并没有改变传入的两个对象的值。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; start = MyTime(<span class="number">9</span>, <span class="number">45</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; duration = MyTime(<span class="number">1</span>, <span class="number">35</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; done = addtime(start, duration);</span><br><span class="line"></span><br><span class="line">julia&gt; printtime(done)</span><br><span class="line"><span class="number">10</span>:<span class="number">80</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>出现了$80$分钟，这与我们的常识不同，我们需要添加新的规则</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> addtime(t1, t2)</span><br><span class="line">    second = t1.second + t2.second</span><br><span class="line">    minute = t1.minute + t2.minute</span><br><span class="line">    hour = t1.hour + t2.hour</span><br><span class="line">    <span class="keyword">if</span> second &gt;= <span class="number">60</span></span><br><span class="line">        second -= <span class="number">60</span></span><br><span class="line">        minute += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> minute &gt;= <span class="number">60</span></span><br><span class="line">        minute -= <span class="number">60</span></span><br><span class="line">        hour += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    MyTime(hour, minute, second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> increment!(time, seconds)</span><br><span class="line">    time.second += seconds</span><br><span class="line">    <span class="keyword">if</span> time.second &gt;= <span class="number">60</span></span><br><span class="line">        time.second -= <span class="number">60</span></span><br><span class="line">        time.minute += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> time.minute &gt;= <span class="number">60</span></span><br><span class="line">        time.minute -= <span class="number">60</span></span><br><span class="line">        time.hour += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面定义的函数会改变传入的参数值，我们称其为<code>Modifiers</code>。</p><h2 id="Multiple-Dispatch"><a href="#Multiple-Dispatch" class="headerlink" title="Multiple Dispatch"></a>Multiple Dispatch</h2><p>在<code>Julia</code>中，你可以写在不同类型上运行的代码，这被称为泛型编程。</p><h3 id="Type-Declarations"><a href="#Type-Declarations" class="headerlink" title="Type Declarations"></a>Type Declarations</h3><p>运算符<code>::</code>将类型注释附加到表达式和变量：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; (<span class="number">1</span> + <span class="number">2</span>) :: <span class="built_in">Float64</span></span><br><span class="line">ERROR: <span class="built_in">TypeError</span>: <span class="keyword">in</span> typeassert, expected <span class="built_in">Float64</span>, got <span class="built_in">Int64</span></span><br><span class="line">julia&gt; (<span class="number">1</span> + <span class="number">2</span>) :: <span class="built_in">Int64</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>这帮助确认你的程序按照你期望的方式进行。</p><p><code>::</code>运算符也可以添加到赋值语句的左边，作为声明的一部分：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">function</span> returnfloat()</span><br><span class="line">           x::<span class="built_in">Float64</span> = <span class="number">100</span></span><br><span class="line">           x</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">returnfloat (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line">julia&gt; x = returnfloat()</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line">julia&gt; typeof(x)</span><br><span class="line"><span class="built_in">Float64</span></span><br></pre></td></tr></table></figure><p>也可以作为函数定义的一部分：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sinc(x)::<span class="built_in">Float64</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    sin(x)/(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>方法是具有特定特征的函数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Printf</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyTime</span><br><span class="line">    hour :: <span class="built_in">Int64</span></span><br><span class="line">    minute :: <span class="built_in">Int64</span></span><br><span class="line">    second :: <span class="built_in">Int64</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> printtime(time::MyTime)</span><br><span class="line">    <span class="meta">@printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>, time.hour, time.minute, time.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的函数定义了输入的数据类型，为方法。</p><h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><p>构造是用来创建对象的一类特殊的函数。<code>MyTime</code>的默认构造函数方法有以下特征：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyTime(hour, minute, second) <span class="comment"># 默认构造函数</span></span><br><span class="line">MyTime(hour::<span class="built_in">Int64</span>, minute::<span class="built_in">Int64</span>, second::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure><p>我们也可以添加自己的外部构建方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> MyTime(time::MyTime)</span><br><span class="line">    MyTime(time.hour, time.minute, time.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们也可以构建内部构造函数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyTime</span><br><span class="line">    hour :: <span class="built_in">Int64</span></span><br><span class="line">    minute :: <span class="built_in">Int64</span></span><br><span class="line">    second :: <span class="built_in">Int64</span></span><br><span class="line">    <span class="keyword">function</span> MyTime(hour::<span class="built_in">Int64</span>=<span class="number">0</span>, minute::<span class="built_in">Int64</span>=<span class="number">0</span>, second::<span class="built_in">Int64</span>=<span class="number">0</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">0</span> ≤ minute &lt; <span class="number">60</span>, <span class="string">&quot;Minute is not between 0 and 60.&quot;</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">0</span> ≤ second &lt; <span class="number">60</span>, <span class="string">&quot;Second is not between 0 and 60.&quot;</span>)</span><br><span class="line">        new(hour, minute, second)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在结构<code>MyTime</code>有$4$个内部构造方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyTime()</span><br><span class="line">MyTime(hour::<span class="built_in">Int64</span>)</span><br><span class="line">MyTime(hour::<span class="built_in">Int64</span>, minute::<span class="built_in">Int64</span>)</span><br><span class="line">MyTime(hour::<span class="built_in">Int64</span>, minute::<span class="built_in">Int64</span>, second::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure><blockquote><p>内部构造函数会覆盖默认构造函数。</p></blockquote><p>内部构造函数总是定义在结构的内部，且能使用一个特殊函数<code>new</code>来创建最新定义的类型的对象。</p><p>另一种不使用<code>new</code>函数的参数的方法为：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> MyTime</span><br><span class="line">    hour :: <span class="built_in">Int</span></span><br><span class="line">    minute :: <span class="built_in">Int</span></span><br><span class="line">    second :: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">function</span> MyTime(hour::<span class="built_in">Int64</span>=<span class="number">0</span>, minute::<span class="built_in">Int64</span>=<span class="number">0</span>, second::<span class="built_in">Int64</span>=<span class="number">0</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">0</span> ≤ minute &lt; <span class="number">60</span>, <span class="string">&quot;Minute is between 0 and 60.&quot;</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">0</span> ≤ second &lt; <span class="number">60</span>, <span class="string">&quot;Second is between 0 and 60.&quot;</span>)</span><br><span class="line">        time = new()</span><br><span class="line">        time.hour = hour</span><br><span class="line">        time.minute = minute</span><br><span class="line">        time.second = second</span><br><span class="line">        time</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>但是这样数据结构必须是可变的。</p><h3 id="show"><a href="#show" class="headerlink" title="show"></a><code>show</code></h3><p><code>show</code>函数是一个特殊的函数，返回对象的字符串表示。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Printf</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, time::MyTime)</span><br><span class="line">    <span class="meta">@printf</span>(io, <span class="string">&quot;%02d:%02d:%02d&quot;</span>, time.hour, time.minute, time.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里前缀<code>Base</code>是需要的因为我们创建了<code>Base.show</code>函数的新方法。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; time = MyTime(<span class="number">9</span>, <span class="number">45</span>)</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><h3 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h3><p>通过定义符号方法，你可以定义在定义的类型上的符号的行为。例如：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Base.+</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> +(t1::MyTime, t2::MyTime)</span><br><span class="line">    seconds = timetoint(t1) + timetoint(t2)</span><br><span class="line">    inttotime(seconds)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; start = MyTime(<span class="number">9</span>, <span class="number">45</span>)</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>:<span class="number">00</span></span><br><span class="line">julia&gt; duration = MyTime(<span class="number">1</span>, <span class="number">35</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">35</span>:<span class="number">00</span></span><br><span class="line">julia&gt; start + duration</span><br><span class="line"><span class="number">11</span>:<span class="number">20</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><h3 id="Multiple-Dispatch-1"><a href="#Multiple-Dispatch-1" class="headerlink" title="Multiple Dispatch"></a>Multiple Dispatch</h3><p>在上面我们定义了两个<code>MyTime</code>类型相加，但是你可能也想整数和<code>Mytime</code>类型相加：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> +(time::MyTime, seconds::<span class="built_in">Int64</span>)</span><br><span class="line">    increment(time, seconds)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; start = MyTime(<span class="number">9</span>, <span class="number">45</span>)</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>:<span class="number">00</span></span><br><span class="line">julia&gt; start + <span class="number">1337</span></span><br><span class="line"><span class="number">10</span>:<span class="number">07</span>:<span class="number">17</span></span><br></pre></td></tr></table></figure><p>相加是可交换的，因此我们定义</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> +(seconds::<span class="built_in">Int64</span>, time::MyTime)</span><br><span class="line">  time + seconds</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">1337</span> + start</span><br><span class="line"><span class="number">10</span>:<span class="number">07</span>:<span class="number">17</span></span><br></pre></td></tr></table></figure><p>当一个函数被调用时决定使用哪个方法的决定被称为分派。</p><h3 id="Generic-Programming"><a href="#Generic-Programming" class="headerlink" title="Generic Programming"></a>Generic Programming</h3><p>多分派在必要时很有用，但(幸运的是)并不总是必要的。通常，您可以通过编写对不同类型的参数正确工作的函数来避免这种情况。</p><p>如下面的函数不仅可以对字符串使用，也可以对其他序列类型的数据使用：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> histogram(s)</span><br><span class="line">    d = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s</span><br><span class="line">        <span class="keyword">if</span> c ∉ keys(d)</span><br><span class="line">            d[c] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d[c] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    d</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; t = (<span class="string">&quot;spam&quot;</span>, <span class="string">&quot;egg&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;bacon&quot;</span>, <span class="string">&quot;spam&quot;</span>)</span><br><span class="line">(<span class="string">&quot;spam&quot;</span>, <span class="string">&quot;egg&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;bacon&quot;</span>, <span class="string">&quot;spam&quot;</span>)</span><br><span class="line">julia&gt; histogram(t)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>,<span class="built_in">Any</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">&quot;bacon&quot;</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">&quot;spam&quot;</span>  =&gt; <span class="number">4</span></span><br><span class="line">  <span class="string">&quot;egg&quot;</span>   =&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用多种类型的函数称为多态函数。多态可以促进代码重用。</p><h2 id="Subtyping"><a href="#Subtyping" class="headerlink" title="Subtyping"></a>Subtyping</h2><h3 id="Cards"><a href="#Cards" class="headerlink" title="Cards"></a>Cards</h3><p>假设我们有一副扑克牌，我们想比较其大小，根据花色和数字，先定义卡牌类：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Card</span><br><span class="line">    suit :: <span class="built_in">Int64</span></span><br><span class="line">    rank :: <span class="built_in">Int64</span></span><br><span class="line">    <span class="keyword">function</span> Card(suit::<span class="built_in">Int64</span>, rank::<span class="built_in">Int64</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">1</span> ≤ suit ≤ <span class="number">4</span>, <span class="string">&quot;suit is not between 1 and 4&quot;</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">1</span> ≤ rank ≤ <span class="number">13</span>, <span class="string">&quot;rank is not between 1 and 13&quot;</span>)</span><br><span class="line">        new(suit, rank)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Global-Variables-1"><a href="#Global-Variables-1" class="headerlink" title="Global Variables"></a>Global Variables</h3><p>定义对应的全局变量来一一对应花色和数组：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> suit_names = [<span class="string">&quot;♣&quot;</span>, <span class="string">&quot;♦&quot;</span>, <span class="string">&quot;♥&quot;</span>, <span class="string">&quot;♠&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> rank_names = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;K&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, card::Card)</span><br><span class="line">    print(io, rank_names[card.rank], suit_names[card.suit])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; Card(<span class="number">3</span>, <span class="number">11</span>)</span><br><span class="line">J♥</span><br></pre></td></tr></table></figure><h3 id="Comparing-Cards"><a href="#Comparing-Cards" class="headerlink" title="Comparing Cards"></a>Comparing Cards</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Base.&lt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> &lt;(c1::Card, c2::Card)</span><br><span class="line">    (c1.suit, c1.rank) &lt; (c2.suit, c2.rank)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Decks"><a href="#Decks" class="headerlink" title="Decks"></a>Decks</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Deck</span><br><span class="line">    cards :: <span class="built_in">Array</span>&#123;Card, <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Deck()</span><br><span class="line">    deck = Deck(Card[])</span><br><span class="line">    <span class="keyword">for</span> suit <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="number">1</span>:<span class="number">13</span></span><br><span class="line">            push!(deck.cards, Card(suit, rank))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    deck</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, deck::Deck)</span><br><span class="line">    <span class="keyword">for</span> card <span class="keyword">in</span> deck.cards</span><br><span class="line">        print(io, card, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    println()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; Deck()</span><br><span class="line">A♣ <span class="number">2</span>♣ <span class="number">3</span>♣ <span class="number">4</span>♣ <span class="number">5</span>♣ <span class="number">6</span>♣ <span class="number">7</span>♣ <span class="number">8</span>♣ <span class="number">9</span>♣ <span class="number">10</span>♣ J♣ Q♣ K♣ A♦ <span class="number">2</span>♦ <span class="number">3</span>♦ <span class="number">4</span>♦ <span class="number">5</span>♦ <span class="number">6</span>♦ <span class="number">7</span>♦ <span class="number">8</span>♦ <span class="number">9</span>♦ <span class="number">10</span>♦ J♦ Q♦ K♦ A♥ <span class="number">2</span>♥ <span class="number">3</span>♥ <span class="number">4</span>♥ <span class="number">5</span>♥ <span class="number">6</span>♥ <span class="number">7</span>♥ <span class="number">8</span>♥ <span class="number">9</span>♥ <span class="number">10</span>♥ J♥ Q♥ K♥ A♠ <span class="number">2</span>♠ <span class="number">3</span>♠ <span class="number">4</span>♠ <span class="number">5</span>♠ <span class="number">6</span>♠ <span class="number">7</span>♠ <span class="number">8</span>♠ <span class="number">9</span>♠ <span class="number">10</span>♠ J♠ Q♠ K♠</span><br></pre></td></tr></table></figure><h3 id="Add-Remove-Shuffle-and-Sort"><a href="#Add-Remove-Shuffle-and-Sort" class="headerlink" title="Add, Remove, Shuffle and Sort"></a>Add, Remove, Shuffle and Sort</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.pop!(deck::Deck)</span><br><span class="line">    pop!(deck.cards)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.push!(deck::Deck, card::Card)</span><br><span class="line">    push!(deck.cards, card)</span><br><span class="line">    deck</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Random</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Random.shuffle!(deck::Deck)</span><br><span class="line">    shuffle!(deck.cards)</span><br><span class="line">    deck</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Abstract-Types-and-Subtyping"><a href="#Abstract-Types-and-Subtyping" class="headerlink" title="Abstract Types and Subtyping"></a>Abstract Types and Subtyping</h3><p>现在我们想要定义手(hand)的类型，其与Decks类型大致相同，因此我们先定义抽象类型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract type</span> CardSet <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在类型后可以使用<code>&lt;:</code>来指定其为谁的子类型，如果没有则为<code>Any</code>的子类型。</p><p>我们可以指定<code>Deck</code>为<code>CardSet</code>的子类</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Deck &lt;: CardSet</span><br><span class="line">    cards :: <span class="built_in">Array</span>&#123;Card, <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Deck()</span><br><span class="line">    deck = Deck(Card[])</span><br><span class="line">    <span class="keyword">for</span> suit <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="number">1</span>:<span class="number">13</span></span><br><span class="line">            push!(deck.cards, Card(suit, rank))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    deck</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Hand &lt;: CardSet</span><br><span class="line">    cards :: <span class="built_in">Array</span>&#123;Card, <span class="number">1</span>&#125;</span><br><span class="line">    label :: <span class="built_in">String</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Hand(label::<span class="built_in">String</span>=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    Hand(Card[], label)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; deck = Deck();</span><br><span class="line"></span><br><span class="line">julia&gt; deck <span class="keyword">isa</span> CardSet</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Abstract-Types-and-Functions"><a href="#Abstract-Types-and-Functions" class="headerlink" title="Abstract Types and Functions"></a>Abstract Types and Functions</h3><p>我们现在可以给抽象类型定义函数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, cs::CardSet)</span><br><span class="line">    <span class="keyword">for</span> card <span class="keyword">in</span> cs.cards</span><br><span class="line">        print(io, card, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.pop!(cs::CardSet)</span><br><span class="line">    pop!(cs.cards)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.push!(cs::CardSet, card::Card)</span><br><span class="line">    push!(cs.cards, card)</span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; deck = Deck()</span><br><span class="line">A♣ <span class="number">2</span>♣ <span class="number">3</span>♣ <span class="number">4</span>♣ <span class="number">5</span>♣ <span class="number">6</span>♣ <span class="number">7</span>♣ <span class="number">8</span>♣ <span class="number">9</span>♣ <span class="number">10</span>♣ J♣ Q♣ K♣ A♦ <span class="number">2</span>♦ <span class="number">3</span>♦ <span class="number">4</span>♦ <span class="number">5</span>♦ <span class="number">6</span>♦ <span class="number">7</span>♦ <span class="number">8</span>♦ <span class="number">9</span>♦ <span class="number">10</span>♦ J♦ Q♦ K♦ A♥ <span class="number">2</span>♥ <span class="number">3</span>♥ <span class="number">4</span>♥ <span class="number">5</span>♥ <span class="number">6</span>♥ <span class="number">7</span>♥ <span class="number">8</span>♥ <span class="number">9</span>♥ <span class="number">10</span>♥ J♥ Q♥ K♥ A♠ <span class="number">2</span>♠ <span class="number">3</span>♠ <span class="number">4</span>♠ <span class="number">5</span>♠ <span class="number">6</span>♠ <span class="number">7</span>♠ <span class="number">8</span>♠ <span class="number">9</span>♠ <span class="number">10</span>♠ J♠ Q♠ K♠</span><br><span class="line">julia&gt; shuffle!(deck)</span><br><span class="line">J♦ <span class="number">10</span>♣ <span class="number">8</span>♠ <span class="number">9</span>♥ <span class="number">5</span>♠ <span class="number">7</span>♣ <span class="number">6</span>♦ A♠ J♣ <span class="number">7</span>♠ <span class="number">5</span>♦ <span class="number">10</span>♥ <span class="number">3</span>♦ <span class="number">9</span>♦ <span class="number">9</span>♣ <span class="number">4</span>♣ <span class="number">8</span>♦ <span class="number">8</span>♥ <span class="number">5</span>♣ A♥ K♥ K♦ K♠ <span class="number">4</span>♦ A♦ Q♥ <span class="number">6</span>♠ <span class="number">2</span>♦ <span class="number">6</span>♥ <span class="number">2</span>♣ <span class="number">10</span>♠ <span class="number">3</span>♥ <span class="number">2</span>♥ J♥ Q♣ <span class="number">5</span>♥ <span class="number">2</span>♠ <span class="number">9</span>♠ <span class="number">10</span>♦ Q♠ <span class="number">3</span>♠ <span class="number">8</span>♣ K♣ <span class="number">7</span>♥ <span class="number">3</span>♣ J♠ <span class="number">4</span>♥ <span class="number">6</span>♣ <span class="number">7</span>♦ <span class="number">4</span>♠ A♣ Q♦</span><br><span class="line">julia&gt; card = pop!(deck)</span><br><span class="line">Q♦</span><br><span class="line">julia&gt; push!(hand, card)</span><br></pre></td></tr></table></figure><h2 id="The-Goodies-Syntax"><a href="#The-Goodies-Syntax" class="headerlink" title="The Goodies: Syntax"></a>The Goodies: Syntax</h2><h3 id="Named-Tuples"><a href="#Named-Tuples" class="headerlink" title="Named Tuples"></a>Named Tuples</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = (a=<span class="number">1</span>, b=<span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">(a = <span class="number">1</span>, b = <span class="number">2</span>)</span><br><span class="line">julia&gt; x.a</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>可以以紧凑形式定义函数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; f(x,y) = x + y</span><br><span class="line">f (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br></pre></td></tr></table></figure><h4 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h4><p>我们可以定义没有名字的函数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x -&gt; x^<span class="number">2</span> + <span class="number">2</span>x - <span class="number">1</span></span><br><span class="line"><span class="comment">#1 (generic function with 1 method)</span></span><br><span class="line">julia&gt; <span class="keyword">function</span> (x)</span><br><span class="line">           x^<span class="number">2</span> + <span class="number">2</span>x - <span class="number">1</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="comment">#3 (generic function with 1 method)</span></span><br></pre></td></tr></table></figure><p>匿名函数通常是其他函数的参数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> Plots</span><br><span class="line"></span><br><span class="line">julia&gt; plot(x -&gt; x^<span class="number">2</span> + <span class="number">2</span>x - <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, xlabel=<span class="string">&quot;x&quot;</span>, ylabel=<span class="string">&quot;y&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="Keyword-Arguments"><a href="#Keyword-Arguments" class="headerlink" title="Keyword Arguments"></a>Keyword Arguments</h4><p>函数参数可以命名：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">function</span> myplot(x, y; style=<span class="string">&quot;solid&quot;</span>, width=<span class="number">1</span>, color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line">           <span class="comment">###</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">myplot (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line">julia&gt; myplot(<span class="number">0</span>:<span class="number">10</span>, <span class="number">0</span>:<span class="number">10</span>, style=<span class="string">&quot;dotted&quot;</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br></pre></td></tr></table></figure><p>关键字参数用<code>;</code>隔开，但调用的时候可以使用<code>,</code>。</p><h4 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h4><p><code>closure</code>是允许函数获取在函数范围之外的变量的方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; foo(x) = ()-&gt;x</span><br><span class="line">foo (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; bar = foo(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#1 (generic function with 1 method)</span></span><br><span class="line"></span><br><span class="line">julia&gt; bar()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>块是一种将许多语句分组的方法。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="let-Blocks"><a href="#let-Blocks" class="headerlink" title="let Blocks"></a><code>let</code> Blocks</h4><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x, y, z = -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">let</span> x = <span class="number">1</span>, z</span><br><span class="line">           <span class="meta">@show</span> x y z;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = -<span class="number">1</span></span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: z not defined</span><br><span class="line">julia&gt; <span class="meta">@show</span> x y z;</span><br><span class="line">x = -<span class="number">1</span></span><br><span class="line">y = -<span class="number">1</span></span><br><span class="line">z = -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>在第一个<code>let</code>中，<code>@show</code>打印局部变量<code>x,z</code>，打印全局变量<code>y</code>，全局变量<code>x,y,z</code>并未受影响。</p><h4 id="do-Blocks"><a href="#do-Blocks" class="headerlink" title="do Blocks"></a><code>do</code> Blocks</h4><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; data = <span class="string">&quot;This here&#x27;s the wattle,\nthe emblem of our land.\n&quot;</span></span><br><span class="line"><span class="string">&quot;This here&#x27;s the wattle,\nthe emblem of our land.\n&quot;</span></span><br><span class="line">julia&gt; open(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">do</span> fout</span><br><span class="line">           write(fout, data)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><p>这里<code>fout</code>为文件流，我们不再需要手动关闭<code>fout</code>。</p><p>这在函数上等价于</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; f = fout -&gt; <span class="keyword">begin</span></span><br><span class="line">           write(fout, data)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="comment">#3 (generic function with 1 method)</span></span><br><span class="line">julia&gt; open(f, <span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><p>匿名函数常被用为<code>open</code>的参数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> open(f::<span class="built_in">Function</span>, args...)</span><br><span class="line">    io = open(args...)</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        f(io)</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">        close(io)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>do块可以从它的封闭作用域捕获变量。例如，上面<code>open…do</code>例子中的变量<code>data</code>是从外部作用域捕获的。</p><h3 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h3><h4 id="Ternary-Operator"><a href="#Ternary-Operator" class="headerlink" title="Ternary Operator"></a>Ternary Operator</h4><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a = <span class="number">150</span></span><br><span class="line"><span class="number">150</span></span><br><span class="line">julia&gt; a % <span class="number">2</span> == <span class="number">0</span> ? println(<span class="string">&quot;even&quot;</span>) : println(<span class="string">&quot;odd&quot;</span>)</span><br><span class="line">even</span><br></pre></td></tr></table></figure><h4 id="Short-Circuit-Evaluation"><a href="#Short-Circuit-Evaluation" class="headerlink" title="Short-Circuit Evaluation"></a>Short-Circuit Evaluation</h4><p><code>&amp;&amp;</code>和<code>||</code>是短路运算符，当前一个表达式的值可以确定结果是另一个就不需要计算了。</p><h4 id="Tasks-aka-Coroutines"><a href="#Tasks-aka-Coroutines" class="headerlink" title="Tasks (aka Coroutines)"></a>Tasks (aka Coroutines)</h4><p>任务是一种能够传递协同控制而不返回的控制结构。在Julia中，任务可以作为第一个参数为<code>Channel</code>对象的函数来实现。通道用于将值从函数传递给被调用方。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fib(c::<span class="built_in">Channel</span>)</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    put!(c, a)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        put!(c, b)</span><br><span class="line">        (a, b) = (b, a+b)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>take!</code>可以从通道中取值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; fib_gen = <span class="built_in">Channel</span>(fib);</span><br><span class="line"></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>通道也可以作为迭代对象</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> val <span class="keyword">in</span> <span class="built_in">Channel</span>(fib)</span><br><span class="line">           print(val, <span class="string">&quot; &quot;</span>)</span><br><span class="line">           val &gt; <span class="number">20</span> &amp;&amp; <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><h4 id="Primitive-Types"><a href="#Primitive-Types" class="headerlink" title="Primitive Types"></a>Primitive Types</h4><p>在<code>Julia</code>中，你可以定义自己的原始类型，标准原始类型也用同样的方法定义：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">primitive type</span> <span class="built_in">Float64</span> &lt;: <span class="built_in">AbstractFloat</span> <span class="number">64</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">primitive type</span> <span class="built_in">Bool</span> &lt;: <span class="built_in">Integer</span> <span class="number">8</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">primitive type</span> <span class="built_in">Char</span> &lt;: <span class="built_in">AbstractChar</span> <span class="number">32</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">primitive type</span> <span class="built_in">Int64</span> &lt;: <span class="built_in">Signed</span> <span class="number">64</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>创建<code>Byte</code>原始类型和其构造函数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">primitive type</span> Byte <span class="number">8</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; Byte(val::<span class="built_in">UInt8</span>) = reinterpret(Byte, val)</span><br><span class="line">Byte</span><br><span class="line">julia&gt; b = Byte(<span class="number">0x01</span>)</span><br><span class="line">Byte(<span class="number">0x01</span>)</span><br></pre></td></tr></table></figure><p><code>reinterpret</code>函数用于存储一个8位的无符号整数的位到字节中。</p><h4 id="Parametric-Types"><a href="#Parametric-Types" class="headerlink" title="Parametric Types"></a>Parametric Types</h4><p><code>Julia</code>的类型是参数的，说明其类型可以带参数。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point&#123;T&lt;:<span class="built_in">Real</span>&#125;</span><br><span class="line">    x::T</span><br><span class="line">    y::T</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Type-Unions"><a href="#Type-Unions" class="headerlink" title="Type Unions"></a>Type Unions</h4><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; IntOrString = <span class="built_in">Union</span>&#123;<span class="built_in">Int64</span>, <span class="built_in">String</span>&#125;</span><br><span class="line"><span class="built_in">Union</span>&#123;<span class="built_in">Int64</span>, <span class="built_in">String</span>&#125;</span><br><span class="line">julia&gt; <span class="number">150</span> :: IntOrString</span><br><span class="line"><span class="number">150</span></span><br><span class="line">julia&gt; <span class="string">&quot;Julia&quot;</span> :: IntOrString</span><br><span class="line"><span class="string">&quot;Julia&quot;</span></span><br></pre></td></tr></table></figure><p>类型联合在大多数计算机语言中是对类型进行推理的内部构造。然而，<code>Julia</code>向用户公开了该特性，因为当类型联合只有少量类型时，可以生成有效的代码。这个特性为<code>Julia</code>程序员控制调度提供了极大的灵活性。</p><h3 id="Methods-1"><a href="#Methods-1" class="headerlink" title="Methods"></a>Methods</h3><h4 id="Parametric-Methods"><a href="#Parametric-Methods" class="headerlink" title="Parametric Methods"></a>Parametric Methods</h4><p>方法定义也可以含有参数的类型参数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; isintpoint(p::Point&#123;T&#125;) <span class="keyword">where</span> &#123;T&#125; = (T === <span class="built_in">Int64</span>)</span><br><span class="line">isintpoint (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line">julia&gt; p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">julia&gt; isintpoint(p)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="Function-like-Objects"><a href="#Function-like-Objects" class="headerlink" title="Function-like Objects"></a>Function-like Objects</h4><p><code>Julia</code>中的任何对象都可以被调用，这种可以被调用的对象被称为<code>functors</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Polynomial&#123;R&#125;</span><br><span class="line">    coeff::<span class="built_in">Vector</span>&#123;R&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> (p::Polynomial)(x)</span><br><span class="line">    val = p.coeff[<span class="keyword">end</span>]</span><br><span class="line">    <span class="keyword">for</span> coeff <span class="keyword">in</span> p.coeff[<span class="keyword">end</span>-<span class="number">1</span>:-<span class="number">1</span>:<span class="number">1</span>]</span><br><span class="line">        val = val * x + coeff</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>去计算多项式，我们简单调用它：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; p = Polynomial([<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>])</span><br><span class="line">Polynomial&#123;<span class="built_in">Int64</span>&#125;([<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">julia&gt; p(<span class="number">3</span>)</span><br><span class="line"><span class="number">931</span></span><br></pre></td></tr></table></figure><h3 id="Constructors-1"><a href="#Constructors-1" class="headerlink" title="Constructors"></a>Constructors</h3><p>参数类型可以显式或隐式构造</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Point(<span class="number">1</span>,<span class="number">2</span>)         <span class="comment"># implicit T</span></span><br><span class="line">Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">julia&gt; Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># explicit T</span></span><br><span class="line">Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">julia&gt; Point(<span class="number">1</span>,<span class="number">2.5</span>)       <span class="comment"># implicit T</span></span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching Point(::<span class="built_in">Int64</span>, ::<span class="built_in">Float64</span>)</span><br></pre></td></tr></table></figure><p>为每个<code>T</code>生成默认的内部和外部构造函数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point&#123;T&lt;:<span class="built_in">Real</span>&#125;</span><br><span class="line">    x::T</span><br><span class="line">    y::T</span><br><span class="line">    Point&#123;T&#125;(x,y) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = new(x,y)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Point(x::T, y::T) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = Point&#123;T&#125;(x,y);</span><br></pre></td></tr></table></figure><p>并且每一个<code>x</code>和<code>y</code>的类型都相同。</p><p>当类型不同时可以：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point(x::<span class="built_in">Real</span>, y::<span class="built_in">Real</span>) = Point(promote(x,y)...);</span><br></pre></td></tr></table></figure><h3 id="Conversion-and-Promotion"><a href="#Conversion-and-Promotion" class="headerlink" title="Conversion and Promotion"></a>Conversion and Promotion</h3><h4 id="Conversion"><a href="#Conversion" class="headerlink" title="Conversion"></a>Conversion</h4><p>数据可以从一个类型转为另一个类型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = <span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">julia&gt; typeof(x)</span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line">julia&gt; convert(<span class="built_in">UInt8</span>, x)</span><br><span class="line"><span class="number">0x0c</span></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line"><span class="built_in">UInt8</span></span><br></pre></td></tr></table></figure><p>我们可以增加自己的<code>convert</code>方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Base.convert(::<span class="built_in">Type</span>&#123;Point&#123;T&#125;&#125;, x::<span class="built_in">Array</span>&#123;T, <span class="number">1</span>&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = Point(x...)</span><br><span class="line"></span><br><span class="line">julia&gt; convert(Point&#123;<span class="built_in">Int64</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="Promotion"><a href="#Promotion" class="headerlink" title="Promotion"></a>Promotion</h4><p><code>Promotion</code>是将混合类型的值转换为单一公共类型：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; promote(<span class="number">1</span>, <span class="number">2.5</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1.0</span>, <span class="number">2.5</span>, <span class="number">3.0</span>)</span><br></pre></td></tr></table></figure><h3 id="Metaprogramming"><a href="#Metaprogramming" class="headerlink" title="Metaprogramming"></a>Metaprogramming</h3><p><code>Julia</code>代码可以表示为语言本身的数据结构。这允许程序转换和生成自己的代码。</p><h4 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h4><p>每一个<code>Julia</code>程序开始都为一个字符串：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; prog = <span class="string">&quot;1 + 2&quot;</span></span><br><span class="line"><span class="string">&quot;1 + 2&quot;</span></span><br></pre></td></tr></table></figure><p>下一步是将每个字符串解析为一个名为表达式的对象，表达式由<code>Julia</code>类型<code>Expr</code>表示：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; ex = Meta.parse(prog)</span><br><span class="line">:(<span class="number">1</span> + <span class="number">2</span>)</span><br><span class="line">julia&gt; typeof(ex)</span><br><span class="line"><span class="built_in">Expr</span></span><br><span class="line">julia&gt; dump(ex)</span><br><span class="line"><span class="built_in">Expr</span></span><br><span class="line">  head: <span class="built_in">Symbol</span> call</span><br><span class="line">  args: <span class="built_in">Array</span>&#123;<span class="built_in">Any</span>&#125;((<span class="number">3</span>,))</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">Symbol</span> +</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">Int64</span> <span class="number">1</span></span><br><span class="line">    <span class="number">3</span>: <span class="built_in">Int64</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><code>dump</code>函数显示带有注释的<code>expr</code>对象。</p><p>表达式可以由<code>:()</code>或<code>quote</code>块构造：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; ex = <span class="keyword">quote</span></span><br><span class="line">           <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">       <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a><code>eval</code></h4><p>可以用<code>eval</code>函数计算表达式的值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; eval(ex)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h4><p>宏可以包括程序中生成的代码。宏将<code>Expr</code>对象的元组直接映射到编译后的表达式：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span> containervariable(container, element)</span><br><span class="line">    <span class="keyword">return</span> esc(:($(<span class="built_in">Symbol</span>(container,element)) = $container[$element]))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Generated-Functions"><a href="#Generated-Functions" class="headerlink" title="Generated Functions"></a>Generated Functions</h4><p>宏<code>@generated</code>根据参数的类型为方法创建专门的代码：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@generated</span> <span class="keyword">function</span> square(x)</span><br><span class="line">    println(x)</span><br><span class="line">    :(x * x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; x = square(<span class="number">2</span>); <span class="comment"># note: output is from println() statement in the body</span></span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line">julia&gt; x              <span class="comment"># now we print x</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">julia&gt; y = square(<span class="string">&quot;spam&quot;</span>);</span><br><span class="line"><span class="built_in">String</span></span><br><span class="line">julia&gt; y</span><br><span class="line"><span class="string">&quot;spamspam&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Missing-Values"><a href="#Missing-Values" class="headerlink" title="Missing Values"></a>Missing Values</h3><p>缺失的值可以通过<code>missing</code>对象表示，该对象是<code>Missing</code>类型的单例实例：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a = [<span class="number">1</span>, <span class="literal">missing</span>]</span><br><span class="line"><span class="number">2</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Union</span>&#123;<span class="built_in">Missing</span>, <span class="built_in">Int64</span>&#125;,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">  <span class="literal">missing</span></span><br><span class="line"></span><br><span class="line">julia&gt; sum(a)</span><br><span class="line"><span class="literal">missing</span></span><br><span class="line"></span><br><span class="line">julia&gt; sum(skipmissing([<span class="number">1</span>, <span class="literal">missing</span>]))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="The-Goodies-Base-and-Standard-Library"><a href="#The-Goodies-Base-and-Standard-Library" class="headerlink" title="The Goodies: Base and Standard Library"></a>The Goodies: Base and Standard Library</h2><h3 id="Measuring-Performance"><a href="#Measuring-Performance" class="headerlink" title="Measuring Performance"></a>Measuring Performance</h3><p>可以使用宏<code>@time</code>来比较程序运行的快慢。</p><h3 id="Collections-and-Data-Structures"><a href="#Collections-and-Data-Structures" class="headerlink" title="Collections and Data Structures"></a>Collections and Data Structures</h3><p>Julia提供了另一种内置类型，称为set，它的行为类似于没有值的字典键的集合。集合提供了计算常见集合操作的函数和运算符。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subtract(d1, d2)</span><br><span class="line">    res = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys(d1)</span><br><span class="line">        <span class="keyword">if</span> key ∉ keys(d2)</span><br><span class="line">            res[key] = <span class="literal">nothing</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subtract(d1, d2)</span><br><span class="line">    setdiff(d1, d2)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> hasduplicates(t)</span><br><span class="line">    d = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> t</span><br><span class="line">        <span class="keyword">if</span> x ∈ d</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        d[x] = <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> hasduplicates(t)</span><br><span class="line">    length(<span class="built_in">Set</span>(t)) &lt; length(t)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> usesonly(word, available)</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> word</span><br><span class="line">        <span class="keyword">if</span> letter ∉ available</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> usesonly(word, available)</span><br><span class="line">    <span class="built_in">Set</span>(word) ⊆ <span class="built_in">Set</span>(available)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h3><p><code>Julia</code>指定了一些非正式的接口来定义行为，例如，具有特定目标的方法。当您为某个类型扩展这样的方法时，可以使用该类型的对象来构建这些行为。</p><p>例如斐波那契：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Fibonacci&#123;T&lt;:<span class="built_in">Real</span>&#125; <span class="keyword">end</span></span><br><span class="line">Fibonacci(d::<span class="built_in">DataType</span>) = d&lt;:<span class="built_in">Real</span> ? Fibonacci&#123;d&#125;() : error(<span class="string">&quot;No Real type!&quot;</span>)</span><br><span class="line"></span><br><span class="line">Base.iterate(::Fibonacci&#123;T&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = (zero(T), (one(T), one(T)))</span><br><span class="line">Base.iterate(::Fibonacci&#123;T&#125;, state::<span class="built_in">Tuple</span>&#123;T, T&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = (state[<span class="number">1</span>], (state[<span class="number">2</span>], state[<span class="number">1</span>] + state[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p>首先定义了结构和构造方法，之后定义了初始循环，返回值第一个为$0$，之后一个元组为<code>state</code>用于下面的下一次循环。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> e <span class="keyword">in</span> Fibonacci(<span class="built_in">Int64</span>)</span><br><span class="line">           e &gt; <span class="number">100</span> &amp;&amp; <span class="keyword">break</span></span><br><span class="line">           print(e, <span class="string">&quot; &quot;</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F0641bd5a05ae260e3167b7a6b6f389143abb0416.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1659401858&amp;t=1004217d7de1a7d354b99be904052734&quot; style=&quot;zoom: 100%;&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;书籍网址：&lt;a href=&quot;https://benlauwens.github.io/ThinkJulia.jl/latest/book.html&quot;&gt;https://benlauwens.github.io/ThinkJulia.jl/latest/book.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="书籍阅读" scheme="https://www.hfcouc.work/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="Julia" scheme="https://www.hfcouc.work/tags/Julia/"/>
    
    <category term="编程" scheme="https://www.hfcouc.work/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
